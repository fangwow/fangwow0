<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="hexo,个人博客,blog">
  <meta name="description" content="个人博客">
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  
  <link rel="dns-prefetch" href="https://widget.daovoice.io">
  <link rel="dns-prefetch" href="https://widget-static-cdn.daovoice.io">
  <link rel="dns-prefetch" href="https://im.daovoice.io">
  
  
  <link rel="dns-prefetch" href="https://hm.baidu.com/">
  
  
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://api.github.com">
  <link rel="dns-prefetch" href="https://avatars3.githubusercontent.com">
  
  <link rel="stylesheet" type="text/css" href="/songfang0/./style/main.d9e3dd.css">
	<link rel="shortcut icon" href="/favicon.ico" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>vue知识总结</title>
  
  <script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?awwssw1snsnsnn1ndndnndnd99j";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();
  </script>
  
  
    <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/123456.js","daovoice");daovoice('init',{app_id: "123456"});daovoice('update');
  </script>
  
</head>
<body>
<canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/songfang0/">web前端总结</a>
  <a class="face-img" href="/songfang0/">
    <img src="https://tse1-mm.cn.bing.net/th?id=OIP.Wo0E2kACycBZa4AF_UoUjwAAAA&amp;w=97&amp;h=100&amp;c=8&amp;rs=1&amp;qlt=90&amp;pid=3.1&amp;rm=2">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    vue知识总结
  </h1>
  


    <ul class="article-info">
      <li>
        发布
        <time datetime="2019-04-13T10:11:07.000Z" itemprop="datePublished">2019-04-13</time>
      </li>
      <li>
        
    更新 <time datetime="2019-08-13T10:16:20.994Z" itemprop="dateUpdated">2019-08-13</time>

      </li>
      <li id="busuanzi_container_page_pv">
        阅读 <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <h3 id="vue知识"><a href="#vue知识" class="headerlink" title="vue知识"></a>vue知识</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line">12、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</span><br><span class="line">答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives</span><br><span class="line">钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）</span><br><span class="line">钩子函数参数：el、binding</span><br><span class="line">14、vue-router是什么？它有哪些组件？</span><br><span class="line">答：vue用来写路由一个插件。router-link、router-view</span><br><span class="line">15、导航钩子有哪些？它们有哪些参数？</span><br><span class="line">答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave</span><br><span class="line">参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</span><br><span class="line">16、Vue的双向数据绑定原理是什么？</span><br><span class="line">答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</span><br><span class="line">具体步骤：</span><br><span class="line">第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter</span><br><span class="line">这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</span><br><span class="line">第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</span><br><span class="line">第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:</span><br><span class="line">1、在自身实例化时往属性订阅器(dep)里面添加自己</span><br><span class="line">2、自身必须有一个update()方法</span><br><span class="line">3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</span><br><span class="line">第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</span><br><span class="line">17、请详细说下你对vue生命周期的理解？</span><br><span class="line"></span><br><span class="line">答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</span><br><span class="line">创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。</span><br><span class="line">载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</span><br><span class="line">更新前/后：当data变化时，会触发beforeUpdate和updated方法。</span><br><span class="line">销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</span><br><span class="line">18、请说下封装 vue 组件的过程？</span><br><span class="line">使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</span><br><span class="line">19、你是怎么认识vuex的？</span><br><span class="line">答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。</span><br><span class="line">通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。</span><br><span class="line">应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</span><br><span class="line">20、vue-loader是什么？使用它的用途有哪些？</span><br><span class="line">答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。</span><br><span class="line">用途：js可以写es6、style样式可以scss或less、template可以加jade等</span><br><span class="line">21、请说出vue.cli项目中src目录每个文件夹和文件的用法？</span><br><span class="line">答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</span><br><span class="line">22、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</span><br><span class="line">    答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default &#123;</span><br><span class="line">    第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’</span><br><span class="line">    第三步：注入到vue的子组件的components属性上面,components:&#123;smithButton&#125;</span><br><span class="line">    第四步：在template视图view中使用，&lt;smith-button&gt;  &lt;/smith-button&gt;</span><br><span class="line">    问题有：smithButton命名，使用的时候则smith-button。</span><br><span class="line">23、聊聊你对Vue.js的template编译的理解？</span><br><span class="line"></span><br><span class="line">答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）</span><br><span class="line">详情步骤：</span><br><span class="line">首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</span><br><span class="line">然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</span><br><span class="line">24、vue的组件是怎么定义的？父组件怎么给子组件传值？</span><br><span class="line"></span><br><span class="line">答：首先注册vue.components，第一个参数是组件名称，第二个参数是选项。</span><br><span class="line">直接绑定一个属性，然后在子组件props里面接收</span><br><span class="line">25、使用过element.ui吗？说下它其中两个组件的使用方法？</span><br><span class="line">    答：使用过用过一个布局的，它是由24份，它的写法是:span后面带的数字它占24份里面的宽度。:offset是它</span><br><span class="line">    的间距，后面也是跟数字，也是从24份里面取的。</span><br><span class="line">    input按钮，标签是el-input，后面type跟上一个属性就是显示不同按钮的类型，有默认的default</span><br><span class="line">    （默认的）、success（成功的）、warning（警告）、danger（危险）、info（）、primary（）</span><br><span class="line">26、说下你对mvvm的理解？双向绑定的理解?</span><br><span class="line">答：MVVM分为Model、View、ViewModel三者。</span><br><span class="line">Model 代表数据模型，数据和业务逻辑都在Model层中定义；</span><br><span class="line">View 代表UI视图，负责数据的展示；</span><br><span class="line">ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</span><br><span class="line">Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。</span><br><span class="line">这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。</span><br><span class="line">27.请说下具体使用vue的理解？</span><br><span class="line">    答：1、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。</span><br><span class="line">    2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，</span><br><span class="line">    3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。</span><br><span class="line">    4、js的代码无形的规范，团队合作开发代码可阅读性更高。</span><br><span class="line">28.你觉得哪些项目适合vue框架？</span><br><span class="line">	答：1、数据信息量比较多的，反之类似企业网站就无需此框架了。</span><br><span class="line">	2、手机web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。</span><br><span class="line"></span><br><span class="line">30、PC端项目你会在哪些场景使用Vue框架？</span><br><span class="line"></span><br><span class="line">答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的dom操作js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。</span><br><span class="line">那么vue为什么解决这些问题呢？</span><br><span class="line">第一：只需用v-for在view层一个地方遍历数据即可，无需复制一段html代码在js和html两个地方。</span><br><span class="line">第二：vue通过Virtual Dom就是在js中模拟DOM对象树来优化DOM操作。</span><br><span class="line">vuex</span><br><span class="line">1、vuex有哪几种属性？</span><br><span class="line">	答：有五种，分别是 State、 Getter、Mutation 、Action、 Module</span><br><span class="line">2、vuex的State特性是？</span><br><span class="line">    答：</span><br><span class="line">    一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data</span><br><span class="line">    二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新</span><br><span class="line">    三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</span><br><span class="line">3、vuex的Getter特性是？</span><br><span class="line">    答：</span><br><span class="line">    一、getters 可以对State进行计算操作，它就是Store的计算属性</span><br><span class="line">    二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</span><br><span class="line">    三、 如果一个状态只在一个组件内使用，是可以不用getters</span><br><span class="line">4、vuex的Mutation特性是？</span><br><span class="line">    答：</span><br><span class="line">    一、Action 类似于 mutation，不同在于：</span><br><span class="line">    二、Action 提交的是 mutation，而不是直接变更状态。</span><br><span class="line">    三、Action 可以包含任意异步操作</span><br><span class="line">5、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</span><br><span class="line">    答：</span><br><span class="line">    一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</span><br><span class="line">    二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。</span><br><span class="line">6、不用Vuex会带来什么问题？</span><br><span class="line">    答：</span><br><span class="line">    一、可维护性会下降，你要想修改数据，你得维护三个地方</span><br><span class="line">    二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的</span><br><span class="line">    三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。</span><br><span class="line">1、什么是vue生命周期？</span><br><span class="line">    答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</span><br><span class="line">2、vue生命周期的作用是什么？</span><br><span class="line">	答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</span><br><span class="line">3、vue生命周期总共有几个阶段？</span><br><span class="line">	答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</span><br><span class="line">4、第一次页面加载会触发哪几个钩子？</span><br><span class="line">	答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</span><br><span class="line">5、DOM 渲染在 哪个周期中就已经完成？</span><br><span class="line">	答：DOM 渲染在 mounted 中就已经完成了。</span><br><span class="line">6、简单描述每个周期具体适合哪些场景？</span><br><span class="line">    答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom </span><br><span class="line">axios</span><br><span class="line">1、axios的特点有哪些？</span><br><span class="line">    答：</span><br><span class="line">    一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API</span><br><span class="line">    二、它可以拦截请求和响应</span><br><span class="line">    三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据</span><br><span class="line">    四、安全性更高，客户端支持防御 XSRF</span><br><span class="line">2、axios有哪些常用方法？</span><br><span class="line">    答：</span><br><span class="line">    一、axios.get(url[, config])   //get请求用于列表和信息查询</span><br><span class="line">    二、axios.delete(url[, config])  //删除</span><br><span class="line">    三、axios.post(url[, data[, config]])  //post请求用于信息的添加</span><br><span class="line">    四、axios.put(url[, data[, config]])  //更新操作</span><br><span class="line">3、说下你了解的axios相关配置属性？</span><br><span class="line">    答：</span><br><span class="line">    `url`是用于请求的服务器URL</span><br><span class="line">    `method`是创建请求时使用的方法,默认是get</span><br><span class="line">    `baseURL`将自动加在`url`前面，除非`url`是一个绝对URL。它可以通过设置一个`baseURL`便于为axios实例的方法传递相对URL</span><br><span class="line">    `transformRequest`允许在向服务器发送前，修改请求数据，只能用在&apos;PUT&apos;,&apos;POST&apos;和&apos;PATCH&apos;这几个请求方法</span><br><span class="line">    `headers`是即将被发送的自定义请求头</span><br><span class="line">    headers:&#123;&apos;X-Requested-With&apos;:&apos;XMLHttpRequest&apos;&#125;,</span><br><span class="line">    `params`是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象</span><br><span class="line">        params:&#123;</span><br><span class="line">            ID:12345</span><br><span class="line">        &#125;,</span><br><span class="line">    `auth`表示应该使用HTTP基础验证，并提供凭据</span><br><span class="line">    这将设置一个`Authorization`头，覆写掉现有的任意使用`headers`设置的自定义`Authorization`头</span><br><span class="line">    auth:&#123;</span><br><span class="line">        username:&apos;janedoe&apos;,</span><br><span class="line">        password:&apos;s00pers3cret&apos;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &apos;proxy&apos;定义代理服务器的主机名称和端口</span><br><span class="line">    `auth`表示HTTP基础验证应当用于连接代理，并提供凭据</span><br><span class="line">    这将会设置一个`Proxy-Authorization`头，覆写掉已有的通过使用`header`设置的自定义`Proxy-Authorization`头。</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        host:&apos;127.0.0.1&apos;,</span><br><span class="line">        port:9000,</span><br><span class="line">        auth::&#123;</span><br><span class="line">            username:&apos;mikeymike&apos;,</span><br><span class="line">            password:&apos;rapunz3l&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">keep-alive</span><br><span class="line">vue性能</span><br><span class="line"></span><br><span class="line">polyfill imort引入并执行 应用场景：页面开始一片空白</span><br><span class="line">1、vue响应式原理？</span><br><span class="line">    当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。</span><br><span class="line">每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</span><br><span class="line">2、vue-router实现原理？</span><br><span class="line">3、为什么要选vue？与其它框架对比的优势和劣势？</span><br><span class="line">4、vue如何实现父子组件通信，以及非父子组件通信？</span><br><span class="line">5、vuejs与angularjs以及react的区别？</span><br><span class="line">6、vuex是用来做什么的？</span><br><span class="line">7、vue源码结构</span><br><span class="line">8、Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？</span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt;</span><br><span class="line">        &#123;&#123;value&#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;button @click=&quot;addObjB&quot;&gt;添加obj.b&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj: &#123;</span><br><span class="line">        a: &apos;obj.a&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addObjB () &#123;</span><br><span class="line">      this.obj.b = &apos;obj.b&apos;</span><br><span class="line">      console.log(this.obj)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br><span class="line">点击button会发现，obj.b 已经成功添加，但是视图并未刷新：</span><br><span class="line">原因在于在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api $set()：</span><br><span class="line">    addObjB () &#123;</span><br><span class="line">      // this.obj.b = &apos;obj.b&apos;</span><br><span class="line">      this.$set(this.obj, &apos;b&apos;, &apos;obj.b&apos;)</span><br><span class="line">      console.log(this.obj)</span><br><span class="line">    &#125;</span><br><span class="line">    $set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</span><br><span class="line">9、delete和Vue.delete删除数组的区别</span><br><span class="line">delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。</span><br><span class="line">Vue.delete直接删除了数组 改变了数组的键值。</span><br><span class="line"></span><br><span class="line">var a=[1,2,3,4]</span><br><span class="line">    var b=[1,2,3,4]</span><br><span class="line">    delete a[1]</span><br><span class="line">    console.log(a)    只是value值变为undefined</span><br><span class="line">    this.$delete(b,1)</span><br><span class="line">    console.log(b)    索引为1的这一项不存在，变成其他的了</span><br><span class="line">10、如何优化SPA应用的首屏加载速度慢的问题？</span><br><span class="line">将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</span><br><span class="line">在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</span><br><span class="line">加一个首屏 loading 图，提升用户体验；</span><br><span class="line">11、前端如何优化网站性能？</span><br><span class="line">减少 HTTP 请求数量</span><br><span class="line">在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。</span><br><span class="line"></span><br><span class="line">CSS Sprites：国内俗称 CSS 精灵，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。</span><br><span class="line">采用 lazyLoad：俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。</span><br><span class="line">控制资源文件加载优先级</span><br><span class="line">浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。</span><br><span class="line">一般情况下都是 CSS 在头部，JS 在底部。</span><br><span class="line"></span><br><span class="line">利用浏览器缓存</span><br><span class="line">浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。</span><br><span class="line">减少重排（Reflow）</span><br><span class="line">基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。</span><br><span class="line">减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。</span><br><span class="line"></span><br><span class="line">减少 DOM 操作</span><br><span class="line">图标使用 IconFont 替换</span><br><span class="line">12、网页从输入网址到渲染完成经历了哪些过程？</span><br><span class="line">大致可以分为如下7步：</span><br><span class="line"></span><br><span class="line">输入网址；</span><br><span class="line">发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；</span><br><span class="line">与web服务器建立TCP连接；</span><br><span class="line">浏览器向web服务器发送http请求；</span><br><span class="line">web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；</span><br><span class="line">浏览器下载web服务器返回的数据及解析html源文件；</span><br><span class="line">生成DOM树，解析css和js，渲染页面，直至显示完成；</span><br><span class="line">13、js 延迟加载的方式有哪些？</span><br><span class="line">方案一：&lt;script&gt;标签的 async=&quot;async&quot;属性（详细参见：script 标签的 async 属性） 方案二：&lt;script&gt;标签的 defer=&quot;defer&quot;属性</span><br><span class="line">方案三：动态创建&lt;script&gt;标签</span><br><span class="line">方案四：AJAX eval（使用 AJAX 得到脚本内容，然后通过 eval_r(xmlhttp.responseText) 来运行脚本）</span><br><span class="line">方案五：iframe 方式</span><br><span class="line">14、</span><br></pre></td></tr></table></figure>

      </div>
        <div class="support-author">
          <p>感谢您的阅读。 🙏
          <a href target="_blank">关于转载请看这里</a>
            <!--<a class="btn-pay"  href="#pay-modal">¥ 打赏支持</a>-->
          </p>
        </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>喜欢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  const gitalk = new Gitalk({
    clientID: '8888a8888',
    clientSecret: '8888886666666',
    repo: 'xxxx.github.io',
    owner: 'admin',
    admin: ['admin'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false
  })

  gitalk.render('comments');
</script>


        </div>
      </div>
    </div>
   
</main>
<div class="footer">
  <div class="info">
    <p>
    <a href="https://hexo.io"> Hexo </a> 强力驱动 |
      <a href="https://github.com/Youthink/hexo-themes-yearn"> Yearn </a>
      主题
    </p>
    <p>&copy;2013-2018 Ren Fang的博客 京ICP备xxxxxx号</p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>//console
  var consoleConfig = '\n欢迎访问 https://hufangyun.com ，围观小猿大圣的博客(づ｡◕‿‿◕｡)づ！\n,\n本博客使用 %cHexo%c 搭建，博客主题为小猿大圣开发的 %chexo-themes-yearn%c ~~~ 🎉🎉🎉 \n\n源码 https://github.com/Youthink/hexo-themes-yearn \n\n如果喜欢可以 star 支持一下 ❤️~\n'.split(',');
  var canConsole = true;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/songfang0/./js/main.d9e3dd.js"></script>

</body>
</html>
