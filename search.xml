<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[扩展知识点]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F26%2F%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Node项目]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F26%2FNode%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Node项目1. 项目功能123456789101.用户模块 用户登录 用户注册 用户退出2.文章 文章列表 文章详情 发布新文章 编辑文章 删除文章 2. 项目准备-介绍123456789101112环境：Node.js + express数据库:mysql分布式管理工具:git实际开发中，先实现注册功能再实现登录功能,有账号才能登录git回顾 git init 目录下多一个.git文件 git status git add . git commit -m &quot;&quot; 新建仓库 关联仓库 git push -u origin master 12345678910111213141516项目准备1.创建文件夹 webkit npm init -y 第一次使用需要初始化 npm i express2.git管理 git init git status node_modues:不需要上传到git 在目录下创建一个.gitignore文件,把不想要用git管理的文件或者文件夹的名字放在这个文件里面 .gitignore：/node_modules git add . 创建远程仓库 github =&gt; + =&gt; new repository =&gt; 名字-public-creating =&gt; git commit -m &quot;&quot; git remote add origin 链接 关联仓库 git push -u origin master 第一次推送 3. 项目文件组成123456789node_modulespackage.jsonpackage-lock.json.gitignoreapp.js 程序入口文件router.js 路由配置文件/fun/fun.js:控制器文件 实现具体功能函数/views:html文件/public:静态资源文件 第一次: app.js 12345678910111213原始代码// 1.导包const express = require(&apos;express&apos;);// 2.实例化const app = express();// 3.配置路由app.get(&apos;&apos;,(req,res) =&gt; &#123; res.send(&apos;//////&apos;);&#125;);// 4.监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it at localhost:12345&apos;);&#125;); 第二次: app.js 1234567891011121314优化代码,提取路由// 1.导包const express = require(&apos;express&apos;);// //配置路由1.1 导包const router = require(&apos;./router&apos;);// 2.实例化const app = express();// 3.配置路由// // //配置路由1.2 使用路由 实例化app.use(router);// 4.监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it at localhost:12345&apos;);&#125;); router.js 12345678910111213文件作用:配置路由// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callbackrouter.get(&apos;&apos;,(req,res) =&gt; &#123; res.send(&apos;//////&apos;);&#125;);// 4.导出成员module.exports = router; 提取路由配置中函数处理部分代码,修改touter.js文件 router.js 12345678910111213// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用router.get(&apos;/&apos;,user.login);// 4.导出成员module.exports = router; user.js 1234// 提取路由配置中函数处理部分代码exports.login = (req,res) =&gt; &#123; res.send(&apos;//////&apos;);&#125;; git 1234git statusgit add .git commit -m &quot;初始化项目文件&quot;此时不需要push，只有大功能时才需要提交 4. 登录功能拆分12341.渲染登录页面2.客户端发送表单请求3.服务端处理客户端的请求,返回响应4.客户端处理服务端返回的响应 4.1 渲染登录页面12345671.导入登录页面的素材 views:signin.html public: css img 2.配置第三方包 3.统一处理静态资源文件 4.增加路由配置+找方法 5.渲染视图 res.render() 4.2 安装第三方包-配置静态资源12345671.配置第三方包 安装包npm i jquery bootstrap@3.3.7包之间加空格,可以同时安装两个包2.统一处理第三方资源在app.js文件中配置app.use(&apos;/node_modules&apos;,express.static(&apos;/node_modules&apos;));app.use(&apos;/public&apos;,express.static(&apos;/public&apos;)); 4.3 渲染登录页面-路由配置12345678910111213141516当标识是signin的时候,渲染登录页面在配置路由页面中配置渲染登录页的代码1.安装express-art-template包 官网:https://www.npmjs.com/package/express-art-template npm i art-template npm i express-art-template2.导入包之后为res对象添加了一个render()方法3.在app.js中配置app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;));4.在配置路由文件中渲染页面router.get(&apos;/&apos;,user.login); 当标识是/时，渲染页面5.在user.js文件中处理函数中的代码// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;; 模板引擎渲染页面参考代码 1234567891011121314151.导包var express = require(&apos;express&apos;);2.实例化var app = express();3.配置 当请求的是html文件时app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;));4.配置路由app.get(&apos;/&apos;, function (req, res) &#123; res.render(&apos;signin.html&apos;, &#123; user: &#123; name: &apos;aui&apos;, tags: [&apos;art&apos;, &apos;template&apos;, &apos;nodejs&apos;] &#125; &#125;);&#125;); 4.4 客户端发送表单请求12345ES6新语法：不是所有浏览器都支持1.找到表单文件2.取消表单默认行为3.获取表单数据4.ajax post signin.html 1234567891011&lt;script&gt; $(&apos;form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signin&apos;,data,function(data)&#123; console.log(data); &#125;); // 取消浏览器默认行为 // return false; e.preventDefault(); &#125;); &lt;/script&gt; 4.5 服务端处理表单-获取表单数据12345服务端 1.获取表单提交的数据 2.先验证邮箱 3.验证该邮箱的密码是否正确 4.返回200状态码 router.js 12在router.js文件中配置路由router.post(&apos;/signin&apos;,user.handleLogin); user.js 12345exports.handleLogin = (req,res) =&gt; &#123; // 获取表单提交的数据 body-parser var body = req.body; body: &#123; email: &apos;111@111.com&apos;, password: &apos;111&apos; &#125;&#125; body-parser包的使用 1234567891.安装 npm i body-parser2.导包 const bodyParser = require(&apos;body-parser&apos;);3.配置 // 配置body-parser app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); app.use(bodyParser.json()); 4.结果就是为req对象添加了body属性，来获取表单数据 var body = req.body; &#123; email: &apos;111@111.com&apos;, password: &apos;111&apos; &#125; 4.6 服务端处理表单-验证邮箱12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849通过数据库来验证在user.js文件中// 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;message&apos;&#125;);// 3.开启链接connection.connect();// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); const sqlStr = &apos;select * from `users` where email = ?&apos;; connection.query(sqlStr,body.email,(error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果results的值 有数据，则返回对应的数据(数组)，没有数据则为空数组。 if(results.length === 0)&#123; res.send(&#123; code:1, msg:&apos;邮箱不存在&apos; &#125;); &#125; //邮箱存在，验证邮箱密码是否正确 // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125; sql包使用 12345678910111213141516171819201.安装 npm i mysql// 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;message&apos;&#125;);// 3.开启链接connection.connect();// 4.执行sql语句const id = 257;const sqlStr = &apos;delete from `posts` where id = ?&apos;;connection.query(sqlStr,[id],(error,results) =&gt; &#123; console.log(results);&#125;);// 5.关闭数据库连接connection.end(); 4.7 服务端处理表单-验证密码-返回响应12345678910111213user.js//邮箱存在，验证邮箱密码是否正确// 邮箱正确,results为查询到的数据if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;);&#125;res.send(&#123; code: 200, msg: &apos;可以登录了&apos;&#125;); 4.8 客户端处理服务端返回的响应121.如果服务端返回的结果为200,邮箱密码都正确，客户端重定向到列表页2.如果不等于200,提示用户错误信息 signin.html 12345678910111213141516&lt;script&gt; $(&apos;form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signin&apos;,data,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/&apos;; &#125;else &#123; alert(data.msg); &#125; &#125;); // 取消浏览器默认行为 // return false; e.preventDefault(); &#125;);&lt;/script&gt; 4.9 登录优化-提取mysql模块fun/user.js 1234567891011121314151617181920212223242526272829303132333435// 导入数据库封装文件const mysql = require(&apos;../sql/user_login&apos;);// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); mysql.checkForm(body.email, (error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果数据存在，则返回的数据数组不为0,否则数组长度为0 if(results.length === 0)&#123; return res.send(&#123; code: 1, msg: &quot;邮箱不存在&quot; &#125;); &#125; // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125; 封装的sql/user_login.js 12345678910111213141516171819202122//专门处理数据库操作的代码并且返回执行的结果// 提取路由配置中函数处理部分代码//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.checkForm = (email,callback) =&gt; &#123; const sqlStr = &apos;select * from `users` where email = ?&apos;; connection.query(sqlStr,email,(error,results) =&gt; &#123; if(error)&#123; return callback(error); &#125; callback(null,results); &#125;);&#125; 扩展 将mysql配置前三步提取到一个文件中 db_config.js 123456789101112//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();module.exports = connection; sql/user_login.js 1234567891011导入db_config.js包const connection = require(../mysql/db_config);exports.checkForm = (email,callback) =&gt; &#123; const sqlStr = &apos;select * from `users` where email = ?&apos;; connection.query(sqlStr,email,(error,results) =&gt; &#123; if(error)&#123; return callback(error); &#125; callback(null,results); &#125;);&#125; 5. 项目-MVC-各司其职123view：视图 html文件+css+js+模板引擎model:操作数据库controls：函数处理逻辑 实现大量业务逻辑 6. 文章列表6.1 渲染列表页1231.当请求标识为&apos;/&apos;时，发起对列表页的渲染2.增加router请求,实现渲染列表的函数代码3.topList.js 实现函数代码 渲染页面 router.js 1234567891011121314151617181920// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topList = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用 //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topList.list);// 4.导出成员module.exports = router; topList.js 1234// 渲染文章列表exports.list = (req,res) =&gt; &#123; res.render(&apos;index.html&apos;);&#125; 6.2 数据处理topList.js 12345678910111213141516const topList = require(&apos;../sql/topic_list.js&apos;);// 渲染文章列表exports.list = (req,res) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器错啦&apos; &#125;); &#125; res.render(&apos;index.html&apos;,&#123; items: results &#125;); &#125;);&#125; toppic_list.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.showList = (callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` order by id desc&apos;; connection.query(sqlStr,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; index.html 123456789101112131415&lt;ul class=&quot;media-list&quot;&gt; &#123;&#123;each items&#125;&#125; &lt;li class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;/&quot;&gt; &lt;img width=&quot;40&quot; height=&quot;40&quot; class=&quot;media-object&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;&quot;&gt;&#123;&#123;$value.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;sueysok 回复了问题 • 2 人关注 • 1 个回复 • 187 次浏览 • 话题创建时间&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt; 6.3 express-session-保存用户信息12345678910111213141.安装 npm install express-session2.导包 const session = require(&apos;express-session&apos;);3.配置 var app = express(); app.use(session(&#123; secret: &apos;keyboard cat&apos;, resave: false, saveUninitialized: true &#125;)); 让req请求对象添加一个session属性4.session req.session.user = data[0]; user.js 12345678910111213141516171819202122232425262728293031323334353637// 导入数据库封装文件const mysql = require(&apos;../sql/user_login&apos;);// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); mysql.checkForm(body.email, (error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果数据存在，则返回的数据数组不为0,否则数组长度为0 if(results.length === 0)&#123; return res.send(&#123; code: 1, msg: &quot;邮箱不存在&quot; &#125;); &#125; // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; req.session.user = results[0]; console.log(req.session.user); res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125; 6.4 登录和注册的显示与隐藏1在列表页的头部部分判断session存在与否 topList.js 123456789101112131415161718const topList = require(&apos;../sql/topic_list.js&apos;);// 渲染文章列表exports.list = (req,res) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器错啦&apos; &#125;); &#125; res.render(&apos;index.html&apos;,&#123; items: results, user: req.session.user // 将保存在session中的数据取出来渲染在列表页 &#125;); &#125;);&#125; header.html 123456789101112131415161718192021判断session中的数据，如果存在就显示。。如果不存在显示登陆注册按钮&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &#123;&#123;if user&#125;&#125; &lt;a class=&quot;btn btn-default navbar-btn&quot; href=&quot;/topic/create&quot;&gt;发起&lt;/a&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;&lt;img width=&quot;20&quot; height=&quot;20&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li class=&quot;dropdown-current-user&quot;&gt; 当前登录用户:爱谁谁 &lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/settings/profile&quot;&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/signout&quot;&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;a class=&quot;btn btn-primary navbar-btn&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;a class=&quot;btn btn-success navbar-btn&quot; href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &#123;&#123;/if&#125;&#125;&lt;/ul&gt; 6.5 显示当前用户名12将user中的数据渲染出来当前登录用户:&#123;&#123;user.nickname&#125;&#125; 7.发布新文章7.1 渲染页面router.js 123456789101112131415161718192021// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topic = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic);// 4.导出成员module.exports = router; topList.js 123456// 添加话题exports.createTopic = (req,res) =&gt; &#123; res.render(&apos;topic/create.html&apos;,&#123; user: req.session.user &#125;);&#125; 7.2 客户端发送表单请求create.html 123456789101112131415161718192021&lt;form id=&quot;form&quot; action=&apos;/topic/create&apos;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;标题&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; name=&quot;title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt;内容&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;content&quot; name=&quot;content&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt; $(&apos;#form&apos;).on(&apos;submit&apos;,function(e)&#123; var dataForm = $(this).serialize(); $.post(&apos;/topic/create&apos;,dataForm,function(data)&#123; console.log(data); &#125;); //阻止浏览器默认提交 e.preventDefault(); &#125;);&lt;/script&gt; 7.3 服务端处理表单请求1231.router.js 当请求标识为/topic/create2.topList.js 接收数据,往数据库中添加数据3.createTopicHandle.js 封装处理数据库函数 router.js 12345678910111213141516171819202122// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topic = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle);// 4.导出成员module.exports = router; fun/topList.js 12345678910111213141516// 处理文章表单逻辑exports.createTopicHandle = (req,res) =&gt; &#123; const data = req.body; createTopicHandl.createHandle(data, (error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code: 500, msg: &quot;服务器出错了&quot; &#125;); &#125; res.send(&#123; code: 200, msg: &quot;话题发布成功&quot; &#125;); &#125;);&#125; createTopicHandle.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.createHandle = (data,callback) =&gt; &#123; const sqlStr = &apos;insert into `topics` set ?&apos;; connection.query(sqlStr,data,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 7.4 客户端处理服务端返回的数据123456789101112&lt;script&gt; $(&apos;#form&apos;).on(&apos;submit&apos;,function(e)&#123; var dataForm = $(this).serialize(); $.post(&apos;/topic/create&apos;,dataForm,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/&apos;; &#125; &#125;); e.preventDefault(); &#125;);&lt;/script&gt; 8. 持久化存储用户信息123456781.express-session:存的数据在服务器的内存中 每次重启服务器数据就会消失 req.session 持久化存储 -mysql或者本地存储2.express-mysql-session作用:把express-session保存的数据req.session自动的保存到数据库中1)安装 npm i express-mysql-session2)app.js文件中配置包3)express-session包也需要导入4)结果 当使用req.session.user = ？ 时,会自动把数据放在mysql中5)结果 当访问req.session.user时,会自动查询数据库 app.js 123456789101112131415161718192021// 1.导入express-mysql-sessionconst session = require(&apos;express-session&apos;);const MySQLStore = require(&apos;express-mysql-session&apos;)(session);// 2.配置express-mysql-sessionconst options = &#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, password: &apos;root&apos;, database: &apos;webkit&apos;&#125;;// 3.实例化express-mysql-sessionconst sessionStore = new MySQLStore(options);//4.app.use(session(&#123; key: &apos;session_cookie_name&apos;, secret: &apos;session_cookie_secret&apos;, store: sessionStore, resave: false, saveUninitialized: false&#125;)); 8.1 设置话题的createdAt123456自动格式化时间 momentjs.com1.安装包 npm i moment2.导包 const moment = require(&apos;moment&apos;);3.使用 在文章表单提交的时候,服务器端获取表单数据,动态的添加数据 createAt 创建时间日期 body.createdAt = moment().format(); 8.2 设置话题的创建者-userId123把当前存的用户id值 赋值给文章里面的userId区分每个文章的创建者body.userId = req.session.user.id; 9. 退出用户9.1 退出用户12delete xxx:js自带方法,删除对象成员点击退出：删除session 退回到登陆页 header.js 123456789&lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li class=&quot;dropdown-current-user&quot;&gt; 当前登录用户:&#123;&#123;user.nickname&#125;&#125; &lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/settings/profile&quot;&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/signout&quot;&gt;退出&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; router.js 1234567891011121314151617181920212223// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topic = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout);// 4.导出成员module.exports = router; fun/user.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 导入数据库封装文件const mysql = require(&apos;../sql/user_login&apos;);// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); mysql.checkForm(body.email, (error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果数据存在，则返回的数据数组不为0,否则数组长度为0 if(results.length === 0)&#123; return res.send(&#123; code: 1, msg: &quot;邮箱不存在&quot; &#125;); &#125; // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; // 将用户信息存在session中 req.session.user = results[0]; // console.log(req.session.user); res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125;// 退出登陆页处理exports.signout = (req,res) =&gt; &#123; // 删除session delete req.session.user; // 退出到登陆页 res.redirect(&apos;/login&apos;);&#125; 10. 文章详情10.1 渲染页面index.html 12345678910111213141516&lt;ul class=&quot;media-list&quot;&gt; &#123;&#123;each items&#125;&#125; &lt;li class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;/&quot;&gt; &lt;img width=&quot;40&quot; height=&quot;40&quot; class=&quot;media-object&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;/detail/topic&quot;&gt;&#123;&#123;$value.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;sueysok 回复了问题 • 2 人关注 • 1 个回复 • 187 次浏览 • 话题创建时间 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt; router.js 1234567891011router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) .get(&apos;/detail/topic&apos;,topic.detail);// 4.导出成员module.exports = router; topList.js 1234// 话题详情页exports.detail = (req,res) =&gt; &#123; res.render(&apos;topic/show.html&apos;);&#125; 10.2 配置路由–标识是动态的1/detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 index.html 12&lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;/detail/topic/&#123;&#123;$value.id&#125;&#125;&quot;&gt;&#123;&#123;$value.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;给每个标识后面添加动态的id,方便详情页通过id查询数据 router.js 12345678910111213141516// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.detail);// 4.导出成员module.exports = router; topList.js 123456789// 话题详情页标识:.get(&apos;/detail/topic/:topicID&apos;,topic.detail);exports.detail = (req,res) =&gt; &#123; // 获取标识动态路由参数的值 :冒号后面的 req.params &#123;topicID:9&#125; const topicID = req.params.topicID; console.log(topicID); // res.render(&apos;topic/show.html&apos;);&#125; 10.3 处理数据12341.在router.js文件中配置路由2.在fun/topList.js文件中 处理详情页逻辑业务3.在sql/detail.js文件中 处理 数据库查询代码4.在fun/topList.js文件中渲染页面数据 router.js 12345678910111213141516// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail);// 4.导出成员module.exports = router; fun/topList.js 12345678910111213141516171819202122// 话题详情页exports.topicDetail = (req,res) =&gt; &#123; // 获取标识动态参数的值 const topicID = req.params.topicID; detailData.detail(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg:&apos;服务器出错了&apos; &#125;); &#125; if(results.length == 0)&#123; return res.send(&#123; code: 1, msg:&apos;数据已经被删除&apos; &#125;); &#125; res.render(&apos;topic/show.html&apos;,&#123; topic: results[0] &#125;); &#125;);&#125; detail.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.detail = (id,callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 10.4 处理数据不存在的情况show.html 1234567891011121314151617181920212223242526272829303132333435&lt;div class=&quot;col-md-9&quot;&gt; &#123;&#123;if !topic&#125;&#125; &lt;p&gt;此话题不存在或已被删除。&lt;/p&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;/&quot;&gt;返回首页&lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;article class=&quot;markdown-body&quot;&gt; &lt;h1&gt;&#123;&#123;topic.title&#125;&#125;&lt;/h1&gt; &lt;a href=&quot;/topic/detail/edit&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;/topic/detail/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt; &lt;hr&gt; &#123;&#123;topic.content&#125;&#125; &lt;/article&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;span&gt;lzz&lt;/span&gt; commented &lt;span&gt;24 minutes ago&lt;/span&gt; &lt;span class=&quot;action&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-thumbs-up pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; 评论测试 &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;添加回复&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;&quot; id=&quot;&quot; cols=&quot;10&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;回复&lt;/button&gt; &lt;/form&gt; &#123;&#123;/if&#125;&#125;&lt;/div&gt; 10.5 编辑与删除按钮的显示与隐藏12如果文章的用户Id与session中的id一样，则显示编辑与删除按钮，否则隐藏。将session中的数据保存在数组中,在显示页面判断显示与隐藏 topList.js 1234567891011121314151617181920212223// 话题详情页exports.topicDetail = (req,res) =&gt; &#123; // 获取标识动态参数的值 const topicID = req.params.topicID; detailData.detail(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg:&apos;服务器出错了&apos; &#125;); &#125; // if(results.length == 0)&#123; // return res.send(&#123; // code: 1, // msg:&apos;数据已经被删除&apos; // &#125;); // &#125; res.render(&apos;topic/show.html&apos;,&#123; topic: results[0], userId: req.session.user ? req.session.user.id : 0 &#125;); &#125;);&#125; show.html 12345678910111213141516171819202122232425262728293031323334353637&lt;div class=&quot;col-md-9&quot;&gt; &#123;&#123;if !topic&#125;&#125; &lt;p&gt;此话题不存在或已被删除。&lt;/p&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;/&quot;&gt;返回首页&lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;article class=&quot;markdown-body&quot;&gt; &lt;h1&gt;&#123;&#123;topic.title&#125;&#125;&lt;/h1&gt; &#123;&#123;if topic.userId === userId&#125;&#125; &lt;a href=&quot;/topic/detail/edit&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;/topic/detail/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt; &#123;&#123;/if&#125;&#125; &lt;hr&gt; &#123;&#123;topic.content&#125;&#125; &lt;/article&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;span&gt;lzz&lt;/span&gt; commented &lt;span&gt;24 minutes ago&lt;/span&gt; &lt;span class=&quot;action&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-thumbs-up pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; 评论测试 &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;添加回复&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;&quot; id=&quot;&quot; cols=&quot;10&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;回复&lt;/button&gt; &lt;/form&gt; &#123;&#123;/if&#125;&#125;&lt;/div&gt; 10.6 删除话题12341.在a链接中设置href地址，地址中将id参数传入2.在ruter.js中,添加配置路由3.在topList.js文件中,处理配置路由函数代码4.在delete.js文件中,处理数据库代码 show.html 12将当前话题的id传入参数中&lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt; router.js 12345678910111213141516当请求删除标识时,执行对应的函数处理代码// 3.配置路由// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete);// 4.导出成员module.exports = router; fun/topList.js 1234567891011121314函数逻辑处理代码// 删除话题exports.delete = (req,res) =&gt; &#123; const topicID = req.params.topicID; deleteData.delete(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器出错了&apos; &#125;); &#125; res.redirect(&apos;/&apos;); &#125;);&#125; delete.js 123456789101112131415161718192021数据库处理代码//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.delete = (id,callback) =&gt; &#123; const sqlStr = &apos;delete from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 10.7 编辑话题-渲染页面show.html 1&lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/edit&quot;&gt;编辑&lt;/a&gt; router.js 1234567891011121314router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit);// 4.导出成员module.exports = router; topList.html 12345678910111213141516// 编辑话题exports.edit = (req,res) =&gt; &#123; const topicID = req.params.topicID; editData.edit(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器出错了&apos; &#125;); &#125; 渲染编辑页面 res.render(&apos;topic/edit.html&apos;,&#123; topic: results[0] &#125;); &#125;);&#125; edit.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.edit = (id,callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; edit.html 12345678910111213&lt;form id=&quot;form&quot; action=&quot;/topic/edit&quot;&gt; &lt;!-- 表单隐藏域 --&gt; &lt;input type=&quot;hidden&quot; id=&quot;topic_id&quot; value=&quot;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;标题&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; name=&quot;title&quot; value=&quot;&#123;&#123;topic.title&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt;内容&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;content&quot; name=&quot;content&quot; rows=&quot;10&quot;&gt;&#123;&#123;topic.content&#125;&#125;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 10.8 编辑话题-处理表单客户端发送表单提交 edit.html 123456789101112131415161.获取id的方式可以在表单中添加隐藏项来设置topic.id2.可以在js中使用模板引擎获取id&lt;script&gt; $(&apos;#form&apos;).on(&apos;submit&apos;,function(e)&#123; var dataForm = $(this).serialize(); // var url = &quot;/topic/edit/&quot; + &#123;&#123;topic.id&#125;&#125;; var url = &quot;/topic/edit/&quot; + &quot;&#123;&#123;topic.id&#125;&#125;&quot;; $.post(url,dataForm,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/detail/topic/&#123;&#123;topic.id&#125;&#125;&apos;; &#125; &#125;); e.preventDefault(); &#125;);&lt;/script&gt; router.js 12345678910111213141516// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit) .post(&apos;/topic/edit/:topicID&apos;,topic.editHandle);// 4.导出成员module.exports = router; editHandle.js 1234567891011121314151617181920// 修改话题处理exports.editHandle = (req,res) =&gt; &#123; // 获取要修改的数据topicID const topicID = req.params.topicID; // 接收提交的数据 const body = req.body; // console.log(body); editHandle.editHandle(topicID,body,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; res.send(&#123; code: 200, msg: &quot;编辑成功&quot; &#125;); &#125;);&#125; topList.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.edit = (id,callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 11. 用户注册11.1 渲染注册页面signin.html 1&lt;p&gt;没有账号? &lt;a href=&quot;/signup&quot;&gt;点击创建&lt;/a&gt;.&lt;/p&gt; router.js 123456789101112131415161718// 3.配置路由// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit) .post(&apos;/topic/edit/:topicID&apos;,topic.editHandle) .get(&apos;/signup&apos;,user.signup);// 4.导出成员module.exports = router; user.js 1234// 渲染注册页面exports.signup = (req,res) =&gt; &#123; res.render(&apos;signup.html&apos;);&#125; 11.2 客户端发送表单请求signup.html 123456789$(&apos;#signup_form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signup&apos;,data,function(data)&#123; // console.log(data); &#125;); // 取消浏览器默认行为 // return false; e.preventDefault();&#125;); 11.3 服务端处理表单-获取表单数据router.js 12345678910111213141516171819202122// 3.配置路由// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit) //话题编辑表单处理 .post(&apos;/topic/edit/:topicID&apos;,topic.editHandle) //注册页面请求 .get(&apos;/signup&apos;,user.signup) //注册页面表单处理 .post(&apos;/signup&apos;,user.signUpHandle);// 4.导出成员module.exports = router; user.js 123456//注册页面表单数据渲染exports.signUpHandle = (req,res) =&gt; &#123; //接收表单提交的数据 const body = req.body; console.log(body);&#125; 11.4 服务端处理表单-验证邮箱和昵称user.js 123接收注册表单提交的请求验证邮箱是否存在，如果不存在，则可以注册验证昵称是否存在，如果昵称不存在，则可以添加新用户 user.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//注册页面表单数据渲染exports.signUpHandle = (req,res) =&gt; &#123; const body = req.body; // console.log(body); // 验证邮箱的代码与登录一样 userLogin.checkForm(body.email,(error,results) =&gt; &#123; if(error) &#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; if(results[0]) &#123; return res.send(&#123; code: 1, msg: &quot;邮箱已存在&quot; &#125;); &#125; // 如果邮箱不存在，验证昵称 signUpHandle.signUpHandle(body.nickname,(error,results) =&gt; &#123; if(error) &#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; console.log(results); if(results[0]) &#123; return res.send(&#123; code: 2, msg: &quot;昵称已存在&quot; &#125;); &#125; // 验证完邮箱和昵称之后，把数据添加到数据库 signUpHandle.signUpData(body,(error,results) =&gt; &#123; if(error) &#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; res.send(&#123; code: 200, msg: &quot;添加成功&quot; &#125;); &#125;); &#125;); &#125;);&#125; signUpHandle.js 1234567891011121314151617181920212223242526272829//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.signUpHandle = (data,callback) =&gt; &#123; const sqlStr = &apos;select * from `users` where nickname = ?&apos;; connection.query(sqlStr,data,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125;exports.signUpData = (data,callback) =&gt; &#123; const sqlStr = &apos;insert into `users` set ?&apos;; connection.query(sqlStr,data,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 11.5 客户端处理响应signup.html 1234567891011121314&lt;script&gt; $(&apos;#signup_form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signup&apos;,data,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/login&apos;; &#125; &#125;); // 取消浏览器默认行为 // return false; e.preventDefault(); &#125;);&lt;/script&gt; 12. 处理中间件12中间件：是express框架的一个功能作用: 处理所有的请求和响应 12.1 中间件123456789101112131415161718191.搭建服务器const express = require(&apos;express&apos;);const app = express();需求: 想输出所有请求的请求方法和请求标识任何请求都会监听到,不限定请求标识app.use((req,res,next) =&gt; &#123; console.log(`$&#123;req.method&#125;,$&#123;req.path&#125;`); 调用next()方法:作用是把当前的请求交给下一个能匹配到的中间件继续处理 next();&#125;);app.get(&apos;/a&apos;,(req,res) =&gt; &#123; res.send(&apos;aaa&apos;);&#125;);app.get(&apos;/b&apos;,(req,res) =&gt; &#123; res.send(&apos;bbb&apos;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it---&apos;);&#125;); app.use 123456789app.use((req,res,next) =&gt; &#123; 处理当前请求并且执行下一个能匹配到的标识&#125;)next(): 把当前请求交给下一个能匹配到的中间件继续处理注意:app.use((req,res,next) =&gt; &#123;&#125;) 所有请求都会监听到next形参类型是函数 next()中间件的执行有顺序问题(从上到下一一匹配) 12.2 中间件-常用API方法123456781.处理所有请求app.use((req,res,next) =&gt; &#123;&#125;);2.处理标识为 /a 请求方式是get的请求app.get(&apos;/a&apos;,(req,res,next) =&gt; &#123;&#125;);3.处理标识为 /a 请求方式是post的请求app.post(&apos;/a&apos;,(req,res,next) =&gt; &#123;&#125;);4.处理标识以/a开头的所有请求 /a /a/b /abcapp.use(&apos;/a&apos;,(req,res,next) =&gt; &#123;&#125;); 12.3 中间件-执行顺序121.中间件的执行有顺序问题2.按照中间件写的位置从上到下一一匹配 app.js 123456789101112131415161718app.use((req,res,next) =&gt; &#123; console.log(`$&#123;req.method&#125;,$&#123;req.path&#125;`); 调用next()方法:作用是把当前的请求交给下一个能匹配到的中间件继续处理 next();&#125;);app.get(&apos;/a&apos;,(req,res) =&gt; &#123; res.send(&apos;aaa&apos;);&#125;);app.get(&apos;/b&apos;,(req,res) =&gt; &#123; res.send(&apos;bbb&apos;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it---&apos;);&#125;);1.没有next形参如果匹配 /a标识，只会执行app.use(),因为没有next()方法,告诉下面的请求2.有next形参如果匹配 /a标识，不仅执行app.use(),而且执行下面的app.get(&apos;/b&apos;,(req,res)=&gt; &#123;&#125;);next()会执行下面的请求 12.4 中间件-给req增加属性1231.在第一个中间件给req增加属性body2.在下一个能匹配到的中间件中使用req.body属性3.项目中的包 body-parser原理也是如此 app.js 1234567891011121314151617181920app.use((req,res,next) =&gt; &#123; console.log(`$&#123;req.method&#125;,$&#123;req.path&#125;`); 给req增加一个属性 req.obj = &#123; name = &apos;cheng&apos; &#125; 调用next()方法:作用是把当前的请求交给下一个能匹配到的中间件继续处理 next();&#125;);app.get(&apos;/a&apos;,(req,res) =&gt; &#123; 获取到req中的属性 console.log(req.obj); res.send(&apos;aaa&apos;);&#125;);app.get(&apos;/b&apos;,(req,res) =&gt; &#123; res.send(&apos;bbb&apos;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it---&apos;);&#125;); 12.5 中间件-next参数1234app.use((req,res,next) =&gt; &#123;&#125;);处理函数可以有三个参数，请求对象、响应对象、next函数1.next形参 是函数2.next(); 作用:把当前请求交给下一个能匹配到的中间件 12.6 中间件-模拟express-static方法的实现1234567891011121314151617181920const express = require(&apos;express&apos;);const fs = require(&apos;fs&apos;);const app = express();app.use((req, res, next) =&gt; &#123; const path = req.path; fs.readFile(&quot;./public&quot; + path, &quot;utf8&quot;, (err, data) =&gt; &#123; if (err) &#123; // throw err; // 如果代码来到这 证明当前文件读不到 /a -&gt; res.send(&quot;aaaa&quot;); return next(); &#125; res.send(data); &#125;);&#125;);app.get(&quot;/a&quot;, (req, res, next) =&gt; &#123; res.send(&quot;aaaaa&quot;);&#125;);app.listen(23456, () =&gt; &#123; console.log(&quot;run it----&quot;);&#125;); 1234567891011121314151617181920212223const express = require(&apos;express&apos;);const fs = require(&apos;fs&apos;);const app = express();function static(filepath) &#123; return (req, res, next) =&gt; &#123; const path = req.path; fs.readFile(filepath + path, &quot;utf8&quot;, (err, data) =&gt; &#123; if (err) &#123; // throw err; // 如果代码来到这 证明当前文件读不到 /a -&gt; res.send(&quot;aaaa&quot;); return next(); &#125; res.send(data); &#125;); &#125;&#125;app.use(static(&quot;./public&quot;));app.get(&quot;/a&quot;, (req, res, next) =&gt; &#123; res.send(&quot;aaaaa&quot;);&#125;);app.listen(23456, () =&gt; &#123; console.log(&quot;run it----&quot;);&#125;); 12.7 中间件-next()-传参数123456789101112131.next函数不传参数next()2.next传参数next()实参要求是错误对象next()如果传了实参是错误对象，会匹配处理函数有4个参数的中间件4个参数的中间件 app.use((error,req,res,next) =&gt; &#123;&#125;)4个参数的中间件 其中error指的是next()的实参错误对象3.js的代码块try&#123; 把可能出现的错误代码放在这块儿&#125;catch(error)&#123; 如果try中代码确实出错,catch形参error就是错误对象&#125; next实参 123456789101112try&#123; console.log(111); JSON.parse(&apos;saf;hslafhdslak;f&apos;); 错误代码&#125;catch(error)&#123; catch形参error就是try中代码的错误对象 console.log(222); next(error);&#125;处理函数中4个参数 (错误对象，请求对象，响应对象，next方法)app.use((error,req,res,next) =&gt; &#123; console.log(333);&#125;); 12.8 中间件作用和分类作用 12341.执行任何代码2.修改request或者response响应对象 给req增加任意一个属性3.调用下一个中间件 next()4.可以发送响应 res.send() 分类 12345应用程序级别中间件 app.use(express.static())路由级别中间件 express.Router()错误级别中间件 (err,req,res,next) =&gt; &#123;&#125;内置中间件 express.static()第三方中间件 body-parser express-session mogran serve-index 13. 项目13.1 统一处理-500-错误topList.html 123456789101112131415传入错误对象,如果出现错误,执行next(error);会匹配处理函数有4个参数的中间件// 渲染文章列表exports.list = (req,res,next) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return next(error); &#125; res.render(&apos;index.html&apos;,&#123; items: results, user: req.session.user // req.session.user session中的数据 &#125;); &#125;);&#125; app.js 12345678910// 3.配置路由// // //配置路由1.2 使用路由 实例化app.use(router);匹配这个中间件app.use((error,req,res,next) =&gt; &#123; res.send(&#123; code:500, msg:error.message &#125;);&#125;); 13.2 404页面的处理1234567891011121314151617// 3.配置路由// // //配置路由1.2 使用路由 实例化app.use(router);// 渲染404页面对于router.js文件中 匹配不到的标识，会进行如下请求// 处理所有请求，如果前面的配置路由请求不到，则进行如下渲染app.use((req,res,next) =&gt; &#123; res.render(&apos;404.html&apos;); next();&#125;);// 统一处理500错误的中间件app.use((error,req,res,next) =&gt; &#123; res.send(&#123; code:500, msg:error.message &#125;);&#125;); 13.3 请求日志1234567891011121314151617输出项目中所有的请求日志1.app.use(req,res,next) =&gt; &#123; console.log(req.method,req,path); next();&#125;);2.使用第三方来打印所有请求日志morgan:给所有功能输出日志1)安装 npm i morgan2）导入包 var morgan = require(&apos;morgan&apos;);3）配置 app.use(morgan(&apos;combined&apos;)); 或者 app.use(morgan(&apos;tiny&apos;)); 或者 app.use(morgan(&apos;:method :url :status :res[content-length] - :response-time ms&apos;)); 13.4 公共成员的使用1234app对象有一个属性locals,值类型是一个对象app.locals里面的成员num,num可以在页面文件中通过模板引擎的语法去使用app.locals.num = 100找html文件 &#123;&#123;num&#125;&#125; 123456将req.session中的数据保存在公共成员中app.localsapp.use((req,res,next) =&gt; &#123; app.locals.sessionUser = req.session.user; next();&#125;); user.js 1在模板引擎中，添加数据时，不需要user:req.session.user topList.js 12345678910111213exports.list = (req,res,next) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return next(error); &#125; res.render(&apos;index.html&apos;,&#123; items: results // user: req.session.user // req.session.user session中的数据 &#125;); &#125;);&#125; header.html 1234567891011121314151617181920&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &#123;&#123;if sessionUser&#125;&#125; &lt;a class=&quot;btn btn-default navbar-btn&quot; href=&quot;/topic/create&quot;&gt;发起&lt;/a&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;&lt;img width=&quot;20&quot; height=&quot;20&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li class=&quot;dropdown-current-user&quot;&gt; 当前登录用户:&#123;&#123;sessionUser.nickname&#125;&#125; &lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/settings/profile&quot;&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/signout&quot;&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;a class=&quot;btn btn-primary navbar-btn&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;a class=&quot;btn btn-success navbar-btn&quot; href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &#123;&#123;/if&#125;&#125;&lt;/ul&gt; show.html 1234&#123;&#123;if topic.userId === sessionUser.id&#125;&#125; &lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/edit&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt;&#123;&#123;/if&#125;&#125; 14. ES6-展开运算符数组 123456789101112131415161718192021222324252627281.const arr= [1,2,3];const temp = [...arr];console.log(temp); 1 2 32.拼接数组1）const arr = [1,2,3,4];const arr1 = [1,2,3,4,5];console.log(arr.concat(arr1));2）const arr = [1,2,3,4];const arr1 = [1,2,3,4,5];const arr2 = [...arr,...arr1];console.log(arr2);3.合并对象const per = &#123; name: &apos;zhangsan&apos;&#125;const per1 = &#123; age: 10&#125;const per2 = &#123; ...per, ...per1&#125;console.log(per2);4. 数组去重const arr = [1,2,2,3,3,6,5,5,5,4,4];const set = new Set(arr);console.log(set);Set集合 是ES6新数据类型 扩展链接12搜索网站 国内、国际 https://cn.bing.com自动格式化时间 momentjs.com 补充12windows wox+everything多窗口终端 windows conemu/cmd/Powershell/Xshell/cmder web扩展12345phoneGap打包|React-NativePC端:考虑各个浏览器 各个浏览器各个版本苹果安卓代码版本控制工具: git|svn 客户端发送表单请求12form: 默认提交 传数据 同步 整个页面都刷新ajax post 传数据 异步 页面局部刷新 页面重定向12服务端重定向： res.redirect(&apos;/&apos;); 只适用于同步请求(form表单)客户端重定向: window.location.href = &apos;&apos;; 适用于异步请求 比如说ajax请求 是异步的。这种方式不能服务端重定向，只能返回响应，让客户端重定向 GET和POST121.场景： get 查询 post:上传/添加2.安全性： post比get安全性好 POST:请求体 GET:URL中 文件扩充12.psd : ps切图文件.prd :产品需求文档 VSCode快捷键1234567选中相同代码 ctrl+D行尾行首来回跳 Fn + 左|右选中一个单词 ctrl+shift+左|右垂直方向选中 ctrl+alt+上关闭目录 ctrl+b分屏 ctrl+alt+左|右到文件所在目录 shift+alt+r]]></content>
  </entry>
  <entry>
    <title><![CDATA[promise知识点]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F26%2Fpromise%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Promise语法1. Promise使用123Promise是一个构造函数,既然是构造函数,那么我们就可以new Promise()得到一个Promise的实例在Promise上,有两个函数,分别叫做resolve(成功之后的回调)和reject(失败之后的回调)在Promise构造函数的Promise函数的Prototype属性上,有一个.then()方法,也就是说,只要Promise构造函数创建的实例,都可以访问到.then()方法 1234567891011121314151617var fs = require(&apos;fs&apos;);// new Promise是一个构造函数 对象本身不是异步的,里面的任务是异步的console.log(1);const p1 = new Promise(function(resolve)&#123; console.log(2); // 此处是异步的 fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; throw err; &#125;else&#123; console.log(3); console.log(data); &#125; &#125;); &#125;);console.log(4);打印结果是: 1 2 4 3 文件中的数据aaa 2. then方法1234567891011121314151617181920212223var fs = require(&apos;fs&apos;);// new Promise是一个构造函数 对象本身不是异步的,里面的任务是异步的const p1 = new Promise(function(resolve,reject)&#123; // 此处是异步的 fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; // 异步任务失败执行 // throw err; reject(err); &#125;else&#123; // 异步任务成功执行 resolve(data); &#125; &#125;);&#125;);p1.then(function(data)&#123; // function就是容器中的resolve函数 // 异步任务成功执行的函数就是这个函数 console.log(data);&#125;,function(err)&#123; // 异步任务失败执行此方法 console.log(err);&#125;); 3. 总结123456789101112131415var fs = require(&apos;fs&apos;);var p1 = new Promise(function(resolve,reject)&#123; fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; reject(err); 异步任务失败执行 reject &#125;else&#123; resolve(data); 异步任务成功执行 resolve &#125; &#125;);&#125;);p1.then(function(data)&#123; console.log(data); 异步任务成功 resolve()函数&#125;,function(err)&#123; console.log(err); 失败reject函数&#125;) 4. 返回Promise对象123456789101112131415161718192021222324252627282930313233343536373839404142434445var fs = require(&apos;fs&apos;);// new Promise是一个构造函数 对象本身不是异步的,里面的任务是异步的const p1 = new Promise(function(resolve,reject)&#123; // 此处是异步的 fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; // 异步任务失败执行 // throw err; reject(err); &#125;else&#123; // 异步任务成功执行 resolve(data); &#125; &#125;);&#125;);const p2 = new Promise(function(resolve,reject)&#123; // 此处是异步的 fs.readFile(&apos;./bbb.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; // 异步任务失败执行 // throw err; reject(err); &#125;else&#123; // 异步任务成功执行 resolve(data); &#125; &#125;);&#125;);p1.then(function(data)&#123; // function就是容器中的resolve函数 // 异步任务成功执行的函数就是这个函数 // console.log(data); // 当前函数return到的结果可以在后面then中function接收到 // return 123; // 当return的是一个Promise对象时,后面的then中的方法的第一个参数会作为p2对象的resolve函数调用 return p2;&#125;,function(err)&#123; // 异步任务失败执行此方法 console.log(err);&#125;).then(function(data)&#123; console.log(data); //bbb&#125;,function(err)&#123; console.log(err);&#125;); 1234567891011121314如果前面的函数执行失败了,不想影响后面函数的执行p1.then(function(data)&#123; console.log(data); return p2;&#125;,function(err)&#123; // 异步任务失败执行此方法 console.log(err); return p2; 返回该对象之后，会继续执行下面的代码&#125;).then(function(data)&#123; console.log(data); //bbb&#125;,function(err)&#123; console.log(err);&#125;); 1234567891011121314151617181920如果前面的函数执行失败了,立即结束所有后续函数的执行p1.then(function(data)&#123; console.log(data); return p2;&#125;,function(err)&#123; // 异步任务失败执行此方法 如果不想前面文件失败结束后面代码的执行,那么需要给文件添加失败的回调，返回一个新的promise对象 console.log(err); return p2; 返回该对象之后，会继续执行下面的代码&#125;).then(function(data)&#123; console.log(data); //bbb&#125;,function(err)&#123; console.log(err);&#125;)不管前面哪个then执行失败,都会立即结束后续代码执行,进入到这个catch函数catch作用: 如果前面有任何的Promise执行失败,则立即终止所有Promise的执行,并马上进入catch去处理Promise中抛出的异常.catch(function(err)&#123; console.log(err);&#125;); 5. 封装文件的回调123456需求: 封装一个方法,要读取文件的路径const fs = require(&apos;fs&apos;);fs.readFile(&apos;a.txt&apos;,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err console.log(data);&#125;); file.js 12345678const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err console.log(data); &#125;);&#125;getFile(&apos;a.txt&apos;); file1.js 123456789const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err return data; &#125;); 没有return,返回的是undefined&#125;console.log(getFile(&apos;a.txt&apos;)); undefined file2.js 12345678910const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err callback(data); &#125;);&#125;getFile(&apos;a.txt&apos;,(data) =&gt; &#123; console.log(data);&#125;); file3.js 1234567891011const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) return callback(err) callback(null,data); &#125;);&#125;getFile(&apos;a.txt&apos;,(err,data) =&gt; &#123; if(err) return console.log(err) console.log(data);&#125;); file4.js 123456789101112const fs = require(&apos;fs&apos;);function getFile(fPath,callbackErr,callbackSuc)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) return callbackErr(err) callbackSuc(data); &#125;);&#125;getFile(&apos;a.txt&apos;,(err) =&gt; &#123; console.log(&apos;失败了&apos;);&#125;,(data) =&gt; &#123; console.log(&apos;成功了&apos;);&#125;); 6. 回调地狱1234567891011先读取文件1,再读取文件2,再读取文件3getFile(&apos;file1.txt&apos;,funciton(data)&#123; console.log(data); getFile(&apos;file2.txt&apos;,funciton(data)&#123; console.log(data); getFile(&apos;file3.txt&apos;,funciton(data)&#123; console.log(data); &#125;); &#125;);&#125;);使用ES6中的Promise来解决回调地狱的问题 7. jQuery中的Promise123456789101112$(function()&#123; $(&apos;#btn&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url: &apos;&apos;, type: &apos;get&apos;, dataType: &apos;json&apos; &#125;) .then(function(data)&#123; console.log(data); &#125;); &#125;);&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[ajax知识点]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F26%2Fajax%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ajax1.ajax请求xml数据12345678910111213141516171819202122232425262728293031323334353637如果ajax发送请求，后台返回的是xml数据，那么需要在后台返回数据时，声明返回的是xml数据。.xml&lt;root&gt; &lt;name&gt;小明&lt;/name&gt; &lt;age&gt;20&lt;/age&gt;&lt;/root&gt;.php&lt;php&gt; 接收提交的数据 声明返回的是什么类型的数据 编码格式是什么 header(&apos;content-type:text/xml;charset=utf-8&apos;) 读取.xml文件中的数据 $data = filr_get_content(&apos;文件名.xml&apos;); echo $data;&lt;/php&gt;.html document.querySelector(&apos;id&apos;).onclick = function()&#123; 1.创建异步对象 var xhr = new XMLhttpRequest(); 2.设置请求行 xhr.open(&apos;get&apos;,&apos;.php&apos;); 3.post请求设置请求体 4.注册状态改变事件 xhr.onreadyStatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; status == 200 )&#123; console.log(xhr.responseText); 接收返回的字符串 console.log(xhr.responseXML); 接收返回的xml #document 解析XML console.log(xhr.responseXML.querySelector(&apos;name&apos;)); &lt;name&gt;小明&lt;/name&gt; console.log(xhr.responseXML.querySelector(&apos;name&apos;).innerText); 小明 &#125; &#125; 5.发送请求 xhr.send(null); &#125;; xml：缺点： 数据传输量大 2. ajax请求json数据12345678910111213141516json是一种数据的格式json的载体是字符串基本上所有语言都支持JSON语法简洁 基本上所有的语言 都提供了对应的方法 来解析jsonjson: 属性名和值都必须使用&quot;&quot;包裹，如果属性值是数组，可以不使用双引号json字符串转化为数据/对象var jsonStr = &apos;&#123;&quot;&quot;:&quot;&quot;,&quot;&quot;:&quot;&quot;&#125;&apos;var obj = JSON.parse(json字符串); 转化为对应的数组/对象将响应的结果转化为json对象var arr = JSON.parse(xhr.responseText);console.log(arr);.php设置服务器返回的格式header(&apos;content-type:application/json;charset=utf-8&apos;);$str = file_get_content(&apos;.json&apos;);echo $str; 3. 模板引擎的使用123456789101.引入文件2.定义模板&lt;script type=&apos;text/template&apos; id=&apos;template&apos;&gt; &#123;&#123;name&#125;&#125;&lt;/script&gt;var json = &#123; name: &quot;&quot;&#125;var data = template(&apos;template&apos;,json);document.body.innerHTML(data); 4. jsonp的使用1234567891011jsonp在线接口测试:http://api.asilu.com/#geo在线工具：https://www.sojson.com/api/$(&apos;input&apos;).click(function()&#123; $.ajax(&#123; url: &quot;&quot;, success: function(data)&#123; console.log(data); &#125;, dataType: &apos;jsonp&apos; &#125;);&#125;); 5. 模板引擎原理1234567891011121314151617181920211.通过id获取模板中的内容2.找到字符串中特殊符号 &#123;&#123;name&#125;&#125;3.使用字符串中特殊符号进行替换4.返回字符串&lt;script&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/script&gt;var str = document.querySelector(&apos;#template&apos;).innerHtml;var data = &#123; name:&apos;&apos;， skill:&apos;&apos;&#125;var reg = /&#123;&#123;(\w+)&#125;&#125;g/;var = reg.exec(str);替换：while(result)&#123; str = str.replace(result[0],data[result[0]]); result = reg.exec(str);&#125; 12345var str = &apos;ssssahfsdha&#123;&#123;name&#125;&#125;sdaf &#123;&#123;age&#125;&#125;&apos;;var reg = /&#123;&#123;\w+&#125;&#125;/;console.log(reg.exec(str));reg.test(str):返回值是布尔类型reg.exec(str); 返回值是被检索到的值，没有返回null 6. 模板引擎补充1234567891011条件: &#123;&#123;if name ===&apos;&apos;&#125;&#125; &#123;&#123;else if&#125; &#123;&#123;/if&#125;&#125;循环: &#123;&#123;each arr&#125;&#125; &#123;&#123;$index&#125;&#125;&#123;&#123;$vale&#125;&#125; 键－值 &#123;&#123;&#125;&#125;原文输出： 输出链接 &#123;&#123;@name&#125;&#125; 7. 瀑布流插件 masonry1https://masonry.desandro.com/ github masonry 8. 同源跨域概念123同源：协议 地址 IP号全都相同只要有一个不一样就叫跨域跨域报错： Access-control-Allow-Origin 9. 解决同源的办法123456789101112131415161.jsonp JSONP就是利用src属性 支持跨域获取资源 script:src img src index.html &lt;script&gt; fucntion doSomething(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script src=&apos;http:127.168.10.12/addData.php?callback=doSomething&apos;&gt; addData.php: &lt;?php $something = $_GET[&apos;callback&apos;]; echo $Something.&apos;(&#123;&quot;name&quot;:&quot;jack&quot;&#125;)&apos; ?&gt;2.cros 后台程序员设置 header(&apos;Access-control-Allow-Origin:*&apos;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端vue项目]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F25%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFvue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1. 项目123456789101112131415161718192021222324252627mysql 打开后台服务器创建项目: vue init webpack mobile 设置项目运行后自动打开浏览器 在package.json文件中配置,加--open自动打开浏览器 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --open&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;使用git管理项目: 添加文件 .gitignore node_modules .idea .vscode .git readme.md LICENSE:开源协议 开源协议之间的区别 git init 初始化本地仓库 git status git add . git commit -m &quot;初始化项目&quot; 本地仓库 提交到远程仓库 与远程仓库建立连接 git remote add origin 链接 git push -u origin master 1.1 制作项目首页的header和Tabbar区域12345678按需导入Mint-ui中的组件header: Mint-UI 中的 CSS Comonents中的header import MintUI from &apos;mint-ui&apos; import &apos;../node_modules/mint-ui/lib/style.css&apos; Vue.use(MintUI)Tabbar: Mui中的Tabbar import &apos;@/assets/css/mui.min.css&apos; import &apos;@/assets/css/icons-extra.css&apos; App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561.header部分 引入:mian.js import &#123; Header &#125; from &apos;mint-ui&apos;; Vue.component(Header.name, Header); 使用: &lt;mt-header fixed title=&quot;固定在顶部&quot;&gt;&lt;/mt-header&gt;2.中间部分3.tabbar部分 导入样式 import &apos;./lib/mui/css/mui.min.css&apos; 导入tabbar结构4.代码实现 &lt;template&gt; &lt;div id=&quot;app&quot; class=&apos;home&apos;&gt; &lt;mt-header fixed title=&quot;小桃优惠App&quot;&gt;&lt;/mt-header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;nav class=&quot;mui-bar mui-bar-tab&quot;&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/home&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-home&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;首页&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/class&apos;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-class&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;分类&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/chat&apos;&gt; &lt;span class=&quot;mui-icon mui-icon mui-icon-chat&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;桃粉圈&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/cart&apos;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-cart&quot;&gt;&lt;span class=&quot;mui-badge&quot;&gt;9&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;购物车&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/contact&apos;&gt; &lt;span class=&quot;mui-icon mui-icon-contact&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;我的&lt;/span&gt; &lt;/router-link&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &apos;App&apos;, data()&#123; return &#123; selected: [] &#125; &#125; &#125; &lt;/script&gt; &lt;style&gt; .home &#123; padding-top: 40px; &#125; &lt;/style&gt;注意：在配置tab图标时,需要引入 扩展图标的样式和字体 问题12345678910111213141516171819202122解决mui在严格模式下不支持问题导入mui的js和css文件之后,会报如下错误Uncaught TypeError: &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.d.extend (mui.min.js?5414:7)解决办法:在.babelrc文件下,配置如下代码即可,排除掉mui.js文件&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125; &#125;], &quot;stage-2&quot; ], &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;], 添加的配置 &quot;ignore&quot;: [ &quot;./src/assets/dist/js/mui.min.js&quot; ]&#125; 1.2 修改tabbar图标1234567mui扩展图标引入mui扩展样式引入扩展图标和字体文件 &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/cart&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-cart&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;购物车&lt;/span&gt; &lt;/router-link&gt; 1.3 配置路由1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556引入路由router.jsimport Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Home from &apos;@/components/home.vue&apos;import Class from &apos;@/components/class.vue&apos;import Chat from &apos;@/components/chat.vue&apos;import Cart from &apos;@/components/cart.vue&apos;import Contact from &apos;@/components/contact.vue&apos;Vue.use(Router)const router = new Router(&#123; 配置路由高亮 linkActiveClass: &apos;mui-active&apos;, //覆盖默认的路由高亮的样式，默认的类样式是 router-link-active routes: [ &#123; name: &apos;home&apos;, path: &apos;/home&apos;, component: Home &#125;, &#123; name: &apos;class&apos;, path: &apos;/class&apos;, component: Class &#125;, &#123; name: &apos;chat&apos;, path: &apos;/chat&apos;, component: Chat &#125;, &#123; name: &apos;cart&apos;, path: &apos;/cart&apos;, component: Cart &#125;, &#123; name: &apos;contact&apos;, path: &apos;/contact&apos;, component: Contact &#125; ]&#125;)export default router;main.jsimport router from &apos;./router.js&apos;var vm = new Vue(&#123; el: &apos;#app&apos;, router&#125;);路由连接的改造和路由高亮 修改tabbar为router-link to 设置路由高亮 linkActiveClass: &apos;router-link-active&apos;实现tabbar路由组件切换功能 在router.js文件中根据标识引入对应的组件注意修改：页面的样式,否则看不要效果 padding-top: 40px;新建组件 1.4 轮播图12345678910111213mint-ui组件Swipe: https://cloud.tencent.com/developer/section/1489968参考文档import &#123; Swipe, SwipeItem &#125; from &apos;mint-ui&apos;;Vue.component(Swipe.name, Swipe);Vue.component(SwipeItem.name, SwipeItem);&lt;mt-swipe :auto=&quot;4000&quot;&gt; &lt;mt-swipe-item&gt;1&lt;/mt-swipe-item&gt; &lt;mt-swipe-item&gt;2&lt;/mt-swipe-item&gt; &lt;mt-swipe-item&gt;3&lt;/mt-swipe-item&gt;&lt;/mt-swipe&gt;轮播图需要手动设置高度 1234567891011121314151617使用scss设置样式&lt;style lang=&apos;scss&apos; scoped&gt; .mint-swope &#123; height: 200px; .mint-swipe-item &#123; &amp;:nth-child(1)&#123; background-color: red; &#125; &amp;:nth-child(2)&#123; background-color: yellow; &#125; &amp;:nth-child(3)&#123; background-color: cyan; &#125; &#125; &#125;&lt;/style&gt; 1234567891011121314151617181920212223发送请求获取数据,将数据保存在数组中，轮播图遍历数组安装 axios 导入 使用npm i axios// 导入axiosimport axios from &apos;axios&apos;Vue.prototype.$http = axios;获取数据// 获取轮播图数据async getData()&#123; const res = await this.$http.get(`/api/getlunbo`); console.log(res.body); if(res.body.status === 200)&#123; this.lunboList = res.body.message; &#125;else&#123; Toast(&apos;获取数据失败&apos;); &#125;&#125;渲染轮播图页面&lt;mt-swipe :auto=&quot;4000&quot;&gt; &lt;mt-swipe-item v-for=&apos;(item,i) in lunboList&apos; :key=&apos;i&apos;&gt; &lt;img :src=&apos;item.src&apos; url=&apos;item.url&apos; alt=&apos;&apos;&gt; &lt;/mt-swipe-item&gt;&lt;/mt-swipe&gt; vue中使用axios跨域解决:跨域请求代理1234567891011121.打开config/index.jsproxyTable: &#123; 配置一下代码 &apos;/api&apos;: &#123; target: &apos;http://121.41.130.58:9090&apos;,//设置你调用的接口域名和端口号 别忘了加http changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos;//这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用&apos;http://40.00.100.100:3002/user/add&apos;，直接写‘/api/user/add’即可 &#125; &#125;&#125;2.注意不要全局配置：axios.defaults.baseURL = &apos;http://vue.studyit.io&apos;; 一定不要配置这个 1.5 九宫格123456789101112131415161718192021222324252627mui/examples/hello-mui/examples/grid-default.htmlWW&lt;ul class=&quot;mui-table-view mui-grid-view mui-grid-9&quot;&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu1.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;新闻资讯&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu2.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;图片分享&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu3.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;商品购买&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu4.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;留言反馈&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu5.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;视频专区&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu6.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;联系我们&lt;/div&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 1.6 中间main区域动画切换12345678910111213141516171819202122&lt;transtion&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;.v-enter &#123; opacity: 0; transform: translateX(100%);&#125;.v-leave-to &#123; opacity: 0; transform: translateX(-100%); position: absolute;&#125;.v-enter-active,.v-leave-active &#123; transition: all 0.5s ease;&#125;解决滚动条问题:.app-container &#123; padding-top: 40px; overflow-x: hidden;&#125; 点击tabbar区域实现动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div id=&quot;app&quot; class=&apos;home&apos;&gt; &lt;mt-header fixed title=&quot;小桃优惠App&quot;&gt;&lt;/mt-header&gt; &lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;nav class=&quot;mui-bar mui-bar-tab&quot;&gt; &lt;router-link class=&quot;mui-tab-item mui-active&quot; to=&quot;/tabbar&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-home&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;首页&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/search&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-search&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;搜索&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/cart&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-cart&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;购物车&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/contact&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-contact&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;个人&lt;/span&gt; &lt;/router-link&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;App&apos;, data()&#123; return &#123; selected: [] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .home &#123; padding-top: 40px; overflow-x: hidden ; &#125; .v-enter &#123; opacity: 0; transform: translateX(100%); &#125; .v-leave-to &#123; opacity: 0; transform: translateX(-100%); position: absolute; &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.2s ease; &#125;&lt;/style&gt; 2. 使用git管理项目1234567891011121314151617.gitignore 忽略文件 node_modules .idea webstorm 生产的 默认配置 .vscode vscode配置 .gitreadme.mdLICENSE:开源协议管理项目: git config --global user.name &apos;&apos; git config --global user.email &apos;&apos; git init git status git add . git status git commit -m &quot;&quot; git remote add origin 链接 与远程仓库链接 git push -u origin master 3. 点击新闻资讯跳转到列表页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811.新闻资讯 a修改为router-link to2.配置路由 新建组件3.&lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt; &lt;router-link to=&apos;/home/newList&apos;&gt; &lt;img src=&quot;../assets/image/menu1.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;新闻资讯&lt;/div&gt; &lt;/router-link&gt;&lt;/li&gt;4.创建组件 使用mui组件的列表 media-list &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;ul class=&quot;mui-table-view&quot;&gt; &lt;li class=&quot;mui-table-view-cell mui-media&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;../assets/image/shuijiao.jpg&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; 幸福 &lt;p class=&apos;mui-ellipsis&apos;&gt; &lt;span&gt;发表时间: 2017年7月2日&lt;/span&gt; &lt;span&gt;点击次数: 5次&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; &#125; &lt;/script&gt; &lt;style&gt; .main &#123; padding-top: 40px; &#125; .mui-ellipsis &#123; display: flex; justify-content: space-between; &#125; &lt;/style&gt;5.配置路由import NewList from &apos;@/components/newList.vue&apos;&#123; name: &apos;newList&apos;, path: &apos;/home/newList&apos;, component: NewList&#125;6.获取数据渲染界面&lt;li class=&quot;mui-table-view-cell mui-media&quot; v-for=&apos;(item,i) in newsList&apos; :key=&apos;i&apos;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; :src=&quot;item.img_url&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;p class=&apos;mui-ellipsis&apos;&gt; &lt;span&gt;发表时间: &#123;&#123;item.add_time&#125;&#125;&lt;/span&gt; &lt;span&gt;点击次数: &#123;&#123;item.click&#125;&#125;次&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/a&gt;&lt;/li&gt;export default &#123; data()&#123; return &#123; newsList: [] &#125; &#125;, mounted()&#123; this.getData(); &#125;, methods: &#123; async getData()&#123; const res = await this.$http.get(`/api/getnewslist`); console.log(res); this.newsList = res.data; &#125; &#125;&#125;7.格式化时间 4. 详情页12345678910111213141516171819202122232425261.修改组件样式： 修改router-link to &lt;li class=&quot;mui-table-view-cell mui-media&quot;&gt; &lt;router-link :to=&quot;&apos;/home/newlist/&apos; + item.id&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;../assets/image/shuijiao.jpg&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; 幸福 &lt;p class=&apos;mui-ellipsis&apos;&gt; &lt;span&gt;发表时间: 2019.09.09&lt;/span&gt; &lt;span&gt;点击次数: 4次&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/router-link r&gt; &lt;/li&gt;2.配置路由&#123; path: &apos;/home/newList/:id&apos;, component: Detial&#125;3.组件中获取传过来的id$route.params.iddata()&#123; return &#123; id: this.$route.params.id //将url地址中传递过来的值挂载到data数据中 &#125;&#125;4.获取数据渲染组件 5. 评论组件1封装成一个子组件,在需要的地方引入]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决sublime无法安装package control问题]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F25%2F%E8%A7%A3%E5%86%B3sublime%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85package-control%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[###解决sublime无法安装package control问题 12345手动安装的,其他的方法试了但不可以,成功的方法记录一下1.先下载https://github.com/wbond/sublime_package_control中的zip文件，解压后将文件夹名更改为package control2.将解压的文件放在 preferences/Browse-packages/package Control文件夹下即Sublime\Data\Packages\Package Control下3.重启sublime即可看到成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类参数]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F20%2F%E5%88%86%E7%B1%BB%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[###分类参数 1. 导航栏配置标识1&lt;el-menu-item index=&quot;params&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;分类参数&lt;/el-menu-item&gt; 2. 配置路由123456789101112131415161718192021222324252627282930313233343536373839import Vue from &apos;vue&apos;import vueRouter from &apos;vue-router&apos;Vue.use(vueRouter);import Home from &apos;@/components/home.vue&apos;import Params from &apos;@/components/params.vue&apos;import &#123;Message&#125; from &apos;element-ui&apos;const router = new vueRouter(&#123; routes: [ &#123; name: &apos;home&apos;, path: &apos;/&apos;, component: Home, children: [ &#123; name: &apos;params&apos;, path: &apos;/params&apos;, component: Params &#125; ] &#125; ]&#125;); 路由钩子函数 路由拦截router.beforeEach((to,from,next) =&gt; &#123; if(to.name === &apos;login&apos;)&#123; next(); &#125;else&#123; if(!window.localStorage.getItem(&apos;token&apos;))&#123; // 提示消息 Message.warning(&apos;请先登录&apos;); router.push(&#123; name: &apos;login&apos; &#125;); &#125;else&#123; next(); &#125; &#125;&#125;);export default router; 3. 组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;head-bread level1=&apos;商品管理&apos; level2=&apos;分类参数&apos;&gt;&lt;/head-bread&gt; &lt;el-alert title=&quot;注意只允许为第三级分类设置参数&quot; type=&quot;info&quot; show-icon&gt; &lt;/el-alert&gt; &lt;el-form label-position=&quot;left&quot; v-model=&apos;form&apos;&gt; &lt;el-form-item label=&quot;请选择分类&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-tabs type=&quot;border-card&quot; v-model=&apos;active&apos;&gt; &lt;el-tab-pane active=&apos;1&apos; label=&quot;动态参数&quot;&gt; &lt;el-button type=&apos;primary&apos;&gt;设置动态参数&lt;/el-button&gt; &lt;el-table :data=&quot;tableData&quot; stripe height=&apos;300px&apos; style=&quot;width: 100%&quot;&gt; &lt;el-table-column type=&apos;extend&apos; label=&apos;#&apos; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;属性名称&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&apos;small&apos; icon=&quot;el-icon-edit&quot; circle @click=&apos;edit(scope.row.goods_id)&apos;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&apos;small&apos; icon=&quot;el-icon-delete&quot; circle @click=&apos;del(scope.row.goods_id)&apos;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;静态参数&quot;&gt; &lt;el-button active=&apos;2&apos; type=&apos;primary&apos;&gt;设置静态参数&lt;/el-button&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/div&gt;&lt;/template&gt; 4. 获取数据1231.选中三级分类,并且选中的是第一个tab栏时获取数据2.选中的是第一个tab栏时,并且三级分类的长度为3时获取动态数据3.选中的是第二个tab栏时,并且三级分类的长度为3时获取静态数据 5. 处理tag标签可删除可添加123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;el-table-column type=&apos;expand&apos; label=&apos;#&apos; width=&quot;180&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-tag :key=&quot;i&quot; v-for=&quot;(item,i) in scope.row.attr_vals&quot; closable :disable-transitions=&quot;false&quot; @close=&quot;handleClose(scope.row,item)&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/el-tag&gt; &lt;el-input class=&quot;input-new-tag&quot; v-if=&quot;inputVisible&quot; v-model=&quot;inputValue&quot; ref=&quot;saveTagInput&quot; size=&quot;small&quot; @keyup.enter.native=&quot;handleInputConfirm(scope.row)&quot; @blur=&quot;handleInputConfirm(scope.row)&quot; &gt; &lt;/el-input&gt; &lt;el-button v-else class=&quot;button-new-tag&quot; size=&quot;small&quot; @click=&quot;showInput&quot;&gt;+ New Tag&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt;export default &#123; data()&#123; return &#123; form: &#123;&#125;, // 三级分类的数据 options: [], // 选中值的id值 selectedOptions2: [], // 级联选择器配置 defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, active: &apos;1&apos;, arrDy: [], inputVisible: false, inputValue: &apos;&apos; &#125; &#125;, created()&#123; this.getGoods(); &#125;, methods: &#123; // 回车或者失去焦点触发的事件 handleClose(vals,tag) &#123; vals.attr_vals.splice(vals.attr_vals.indexOf(tag), 1); &#125;, showInput() &#123; this.inputVisible = true; this.$nextTick(_ =&gt; &#123; this.$refs.saveTagInput.$refs.input.focus(); &#125;); &#125;, handleInputConfirm(vals) &#123; let inputValue = this.inputValue; if (inputValue) &#123; vals.attr_vals.push(inputValue); &#125; this.inputVisible = false; this.inputValue = &apos;&apos;; &#125;, // tab切换时 tabChange()&#123; if(this.active === &apos;1&apos; &amp;&amp; this.selectedOptions2.length === 3)&#123; this.getArrDy(); &#125; &#125;, //获取动态参数的数据 async getArrDy()&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; // 处理动态数据中的attr_vals属性 变成一个数组 this.arrDy.forEach(function(item)&#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;, // 级联选择器改变时 获取数据 handleChange()&#123; if(this.selectedOptions2.length === 3 &amp;&amp; this.active === &apos;1&apos;)&#123; this.getArrDy(); &#125; &#125;, // 页面加载完毕获取三级分类的数据 async getGoods()&#123; const res = await this.$http.get(`categories?type=3`); // console.log(res); this.options = res.data.data; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .el-alert &#123; margin: 20px 0; &#125; .el-tabs &#123; margin-top: 10px; &#125; .el-tag + .el-tag &#123; margin-left: 10px; &#125; .button-new-tag &#123; margin-left: 10px; height: 32px; line-height: 30px; padding-top: 0; padding-bottom: 0; &#125; .input-new-tag &#123; width: 90px; margin-left: 10px; vertical-align: bottom; &#125;&lt;/style&gt; 6. 动态参数-动态编辑-发送请求12345678910111213141516171819async handleInputConfirm(vals) &#123; let inputValue = this.inputValue; if (inputValue) &#123; vals.attr_vals.push(inputValue); // 发送请求修改数据 const putData = &#123; attr_name: attr.attr_name, attr_sel: attr_sel, attr_vals: attr_vals.join(&apos;,&apos;); &#125; const res = await this.$http.put(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes/$&#123;attr.attr_id&#125;`,putData); console.log(res); &#125; this.inputVisible = false; this.inputValue = &apos;&apos;;&#125;问题一:接口中参数错误问题二:接口中请求参数中attr_vals类型为数组 应该是字符串 扩展12消息推送: 手机软件接收到消息-&gt;app或者网站-&gt;第三方sdk-&gt;友盟(RN/混合app)/share SDK实现分享功能: www.mob.com 社会化分享功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[商品管理]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F19%2F%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[###商品管理 1. 商品列表1234561.添加标识 :/goods 配置路由: &#123;name: &apos;goods&apos;, path: &apos;/goods&apos;, component: ()=&gt;require(&apos;@assets/components/Goods&apos;)&#125; 渲染组件: 面包屑／搜索框／表格 实现功能： 渲染列表／实现商品的删除和修改 1.1 增加商品功能1234添加标识 :/goodsadd配置路由 &#123;name: &apos;goodsadd&apos;, path: &apos;/goodsadd&apos;, component: ()=&gt;require(&apos;@assets/components/Goodsadd&apos;)&#125;渲染组件: 面包屑／alert警告/步骤条／tab栏切换 1.2 实现tab栏切换123456789101112131415161718192021222324点击基本信息－－－－－渲染表单 添加商品的基本信息级联选择器:&lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;options&quot; 级联选择器的数据 v-model=&quot;selectedOptions2&quot; 级联选择器选中项的id号 :props = &quot;defaultProp&quot; 默认配置项 @change=&quot;handleChange&quot;&gt; 级联选择器改变时触发&lt;/el-cascader&gt; data()&#123; return &#123; options: [], selectedOptions2: [], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125; &#125;&#125;页面加载完毕请求数据获取级联选择器的数据const res = await this.$http.get(`categories?type=3`);// console.log(res);this.options = res.data.data; 1.3 商品参数123456789101112131415161718192021222324252627282930311.3.1 当点击的是tab栏的第二项时,判断级联选择器选中的数组的长度是不是等于3,如果tab选中的是第二项并且级联选择器的长度等于3,发请求获取动态参数的数据,否则提示用户选择级联选择器@tab-click = &apos;changeTab()async changeTab()&#123; if(this.active == &quot;2&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; this.arrDy.forEach(function(item)&#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125;&#125;1.3.2根据获取的动态参数的数据 渲染商品参数的数据 复选框 &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrDy&quot; :key=&apos;i&apos;&gt; &lt;el-checkbox-group v-model=&quot;item.attr_vals&quot;&gt; &lt;el-checkbox :label=&quot;item1&quot; border size=&quot;medium&quot; v-for=&quot;(item1,i) in item.attr_vals&quot; :key=&apos;i&apos;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt;1.3.3 默认复选框全选中v-model绑定的是所有选中的复选框的label值 而item.attr_vals是所有的复选框的值&lt;el-checkbox-group v-model=&quot;item.attr_vals&quot;&gt; &lt;el-checkbox v-model=&quot;checked&quot; :label=&quot;item1&quot; border size=&quot;medium&quot; v-for=&quot;(item1,i) in item.attr_vals&quot; :key=&apos;i&apos;&gt;&lt;/el-checkbox&gt;&lt;/el-checkbox-group&gt; 1.4 商品属性-获取静态参数12345678910111213141516171.4.1当点击的是tab栏的第三项时,判断级联选择器选中的数组的长度是不是等于3,如果tab选中的是第三项并且级联选择器的长度等于3,发请求获取静态参数的数据,否则提示用户选择三级分类if(this.active == &quot;3&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125;1.4.2 渲染组件&lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrStatic&quot; :key=&apos;i&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;/el-tab-pane&gt; 1.5 图片上传12345678910111213141516171819202122232425262728293031323334353637&lt;el-form-item&gt; &lt;el-upload class=&quot;upload-demo&quot; multiple action=&quot;http://localhost:8888/api/private/v1/upload&quot; 上传路径 :headers = &apos;header&apos; :on-remove=&quot;handleRemove&quot; 移除事件 :on-success=&apos;handleSuccess&apos; 上传成功事件 list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt;&lt;／el-form-item&gt; data()&#123; return &#123; header: &#123; Authorization: localStorage.getItem(&quot;token&quot;) &#125; &#125;&#125;handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file);&#125;,handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); 无效token,因为请求拦截器 是在axios中设置的,需要在文件上传的header中设置请求体 &#123;data: null, meta: &#123;…&#125;&#125; data: null meta: &#123;msg: &quot;无效token&quot;, status: 400&#125; __proto__: Object &#123;data: &#123;…&#125;, meta: &#123;…&#125;&#125; data: &#123;tmp_path: &quot;tmp_uploads\5f629ba1357ffa667fc5b0484bcfeba3.jpg&quot;, url: &quot;http://127.0.0.1:8888/tmp_uploads\5f629ba1357ffa667fc5b0484bcfeba3.jpg&quot;&#125; meta: &#123;msg: &quot;上传成功&quot;, status: 200&#125; __proto__: Object&#125;, 1.6 富文本编辑器12345678910vue插件import &apos;quill/dist/quill.core.css&apos;import &apos;quill/dist/quill.snow.css&apos;import &apos;quill/dist/quill.bubble.css&apos;import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos;expore default &#123; components: quillEditor&#125;&lt;quill-editor v-model=&apos;goods_introduce&apos;&gt;&lt;/quill-editor&gt; 1.7 点击添加商品按钮添加商品发送请求1234567891011121314151617181920212223242526272829303132333435363738async addGoods()&#123; 处理商品分类数据 goods_cat this.form.goods_cat = this.selectedOptions.join(&quot;,&quot;); 处理路径 处理动态静态参数 const arr1 = this.arrDy; const arr2 = this.arrStatic; const newArr1 = arr1.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); const newArr2 = arr2.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); this.form.attrs = [...newArr1, ...newArr2]; 发送请求,请求成功回到列表页 const res = await this.$http.post(`goods`,this.form); console.log(res); this.$router.push(&#123; name: &apos;goods&apos; &#125;);&#125; 当删除文件时 handleRemove(file)&#123; 从当前的this.form.pics中移除当前元素 const index = this.form.pics.findIndex((item) =&gt; &#123; 返回满足条件的索引 return item.pics === file.response.data.tmp_path; &#125;); this.form.pics.splice(index,1); &#125; 当文件上传成功时,将文件的临时路径保存在 handleSuccess(response)&#123; this.form.pics.push(&#123; pics: response.data.tmp_path &#125;) &#125; 1.8 代码总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;!-- 自定义面包屑 --&gt; &lt;head-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/head-bread&gt; &lt;!-- alert警告框 --&gt; &lt;el-alert class=&apos;info&apos; center title=&quot;添加商品信息&quot; type=&quot;info&quot; show-icon&gt; &lt;/el-alert&gt; &lt;!-- 步骤条：步骤条的active与tab的active一致,才能在点击哪个tab时显示第几步 --&gt; &lt;el-steps :active=&quot;+active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;!-- tab --&gt; &lt;el-form label-position=&quot;top&quot; label-width=&quot;80px&quot; :model=&quot;form&quot;&gt; &lt;el-tabs v-model=&apos;active&apos; tab-position=&quot;left&quot; @tab-click = &apos;changeTab()&apos; style=&quot;height: 400px;overflow: auto&quot;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_weight&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrDy&quot; :key=&apos;i&apos;&gt; &lt;el-checkbox-group v-model=&quot;item.attr_vals&quot;&gt; &lt;el-checkbox :label=&quot;item1&quot; border size=&quot;medium&quot; v-for=&quot;(item1,i) in item.attr_vals&quot; :key=&apos;i&apos;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrStatic&quot; :key=&apos;i&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;el-form-item&gt; &lt;el-upload class=&quot;upload-demo&quot; multiple :headers=&apos;headers&apos; action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&apos;handleSuccess&apos; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt; &lt;el-button type=&apos;primary&apos; plain style=&apos;margin-bottom: 10px&apos; @click=&apos;add()&apos;&gt;添加商品&lt;/el-button&gt; &lt;quill-editor v-model=&apos;form.goods_introduce&apos;&gt;&lt;/quill-editor&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 富文本编辑器组件import &apos;quill/dist/quill.core.css&apos;import &apos;quill/dist/quill.snow.css&apos;import &apos;quill/dist/quill.bubble.css&apos;import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos;export default &#123; data()&#123; return &#123; // 添加商品所需参数 form: &#123; goods_name:&apos;&apos;, goods_price: &apos;&apos;, goods_weight: &apos;&apos;, goods_number: &apos;&apos;, goods_introduce: &apos;&apos;, goods_cat: &apos;&apos;, //选中的3级分类 以,号分割的分类列表 pics: [], //图片路径 pics: [&#123;pics: &quot;&quot;&#125;] attrs: &apos;&apos; //静态动态参数 [商品参数] &#125;, active: &quot;1&quot;, // 级联选择器数据 options: [], // 选中的级联选择器 selectedOptions2: [], // 级联默认配置 defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, // 动态参数 arrDy: [], // 静态参数 arrStatic: [], // 复选框选中时的值 checked: [], // 上传文件时的请求头配置 token headers: &#123; Authorization: localStorage.getItem(&quot;token&quot;) &#125; &#125; &#125;, components: &#123; quillEditor &#125;, mounted()&#123; this.getGoods(); &#125;, methods: &#123; // 添加商品 async add()&#123; // 处理文件路径 //this.form.pics // 处理分类 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;); // 处理动态静态列表 const arr1 = this.arrDy; const arr2 = this.arrStatic; const newArr1 = arr1.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); const newArr2 = arr2.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); this.form.attrs = [...newArr1, ...newArr2]; const res = await this.$http.post(`goods`,this.form); console.log(res); this.$router.push(&#123; name: &apos;goods&apos; &#125;); &#125;, // 如果选中的tabs是商品参数,并且级联选择器的长度=3,获取动态参数的数据 async changeTab()&#123; if(this.active == &quot;2&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; // 处理动态数据中的attr_vals属性 变成一个数组 this.arrDy.forEach(function(item)&#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125; if(this.active == &quot;3&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125; &#125;, handleChange()&#123; &#125;, // 移除图片时 handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file); // 找到当前图片的索引,删除这一项 const index = this.form.pics.findIndex((item) =&gt; &#123; return item.pics === file.response.data.tmp_path; &#125;); this.form.pics.splice(index,1); &#125;, // 图片上传成功时,往数组添加一项 handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); //response.data.tmp_path this.form.pics.push(&#123; pics: response.data.tmp_path &#125;); &#125;, // 获取三级分类数据 async getGoods()&#123; const res = await this.$http.get(`categories?type=3`); // console.log(res); this.options = res.data.data; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .info &#123; margin-top: 20px; &#125;&lt;/style&gt; 扩展12345678ES6数组新方法1)findIndex 返回满足条件的索引 1. 数组遍历方法 2. 该方法的形参是 callback 3. 该方法有返回return条件 4. 该方法会把符合条件的元素item的索引自动返回2)map 返回一个新数组3) 复选框 点击就消失 v-model v-m-v]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fvue%2F</url>
    <content type="text"><![CDATA[vuex豆瓣项目1.项目功能12公共组件： 头部组件+侧边栏功能组件： 列表组件 + 详情组件 2. 新建项目1234567vue2: vue init webpack-simple/webpack 项目名vue3:vue create 项目名 vue3:生成项目的目录更简洁 babel： 将ES6转化为 其他低版本 js eslint: 自动检查代码规范cd 目录npm run serve 3. 安装第三方资源1234567891011121314151617181920212223npm i vue-router bootstrap@3.3.7 vuex配置组件 新建组件，在app.vue文件中国引入，并配置组件 new Vue(&#123; el:&apos;&apos;, components: &#123; 组件名：组件常量 &#125; &#125;);配置路由 在index.js文件中配置路由 import Vue from &apos;vue&apos; import VueRouter from &apos;vue-router&apos; Vue.use(VueRouter) const router = new VueRouter(&#123; routes: [ &#123; name:&quot;&quot;, path: &quot;&quot;, component: 组件名 &#125; ] &#125;); 4. 配置vuex1234567891011121314151617181920212223242526272829301.在main.js文件中导入vuex配置vuex 实例化vuex 挂载vuex2.由于vuex是一段有独立功能的代码，所以把vuex的代码进行封装store／store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; title: &apos;sadflihafkljsl&apos; &#125;, mutations: &#123; setTitle(state)&#123; state.title = &apos;sadfsaf&apos;; &#125; &#125;, actions: &#123; getDateList(context)&#123; context.commit(&apos;setTitle&apos;); &#125; &#125;&#125;)export default store;3.由于项目中数据很多，所以需要把每个组件的数据都单独写在一个文件中，引入到store.js文件中４.新建movielist.js 模块：专门处理列表组件的数据的部分 －数据管理模块// 使用仓库store选项modules让仓库状态与模块状态进行关联 modules: &#123; movieList &#125; store.js 1234567891011import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import movieList from &apos;./movielist&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; // 使用仓库store选项modules让仓库状态与模块状态进行关联 modules: &#123; movieList &#125;&#125;)export default store; movieList.js 12345678910111213// 模块：专门处理列表组件的数据的部分 数据管理模块const movieList = &#123; state: &#123; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;export default movieList; 12每个组件的数据管理－&gt;交给自家的数据管理模块movielist．vue -&gt; movielist.js 5. 配置列表数据处理模块1234567891.以前写在data中的数据写在state中2.发送请求 豆瓣API 不支持跨域 支持jsonp axios:有跨域问题 不支持jsonp jsonp: 可以发送jsonp 库 工具3.安装 jsonp npm i jsonp 使用： jsonp(url.options,fn); fn(error,data)4.导入包 import jsonp from &quot;jsonp&quot; jsonp(url,(error,data) =&gt; &#123;&#125;); movielist.js 12345678910111213141516171819202122232425262728// 模块：专门处理列表组件的数据的部分 数据管理模块import jsonp from &apos;jsonp&apos;const movieList = &#123; state: &#123; // 声明数据 title: &apos;&apos;, subjects: [] &#125;, mutations: &#123; // 修改数据 // title数据来源于actions异步请求接收的数据 setTitle(state,payload)&#123; state.title = payload.title; state.subjects = payload.subjects; &#125; &#125;, actions: &#123; getDateList(context)&#123; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(&apos;http://api.douban.com/v2/movie/in_theaters&apos;,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125;&#125;export default movieList; movielist.vue 12345678910111213141516171819202122232425262728293031323334&lt;template&gt;&lt;div&gt; &lt;h1 class=&quot;page-header&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;标题&lt;/h4&gt; 详情 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState([&apos;title&apos;]) &#125;, created()&#123; this.getDateList() &#125;, methods: &#123; ...mapActions([&apos;getDateList&apos;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123在组件中调用title数据之后页面上不显示数据原来：&#123;&#123;title&#125;&#125; =&gt; 计算属性 = store = state = state.title现在： &#123;&#123;title&#125;&#125; =&gt; 计算属性 = store = modules = state= state.title 6. 开启命名空间123456789101112131415161718192021221.在使用数据时，需要写使用那个模块的哪个属性 ...mapState(模块名，[属性名]) computed: &#123; ...mapState(&quot;movieList&quot;,[&apos;title&apos;]) &#125;, methods: &#123; ...mapActions(&quot;movieList&quot;,[&apos;getDateList&apos;]) &#125; 2. 使用模块名字之前，需要在模块中开启命名空间 const movielist = &#123; 开启命名空间 namespaced: true, state: &#123; &#125;, mutations: &#123; &#125;, sctions: &#123; &#125; &#125; 7. 点击不同列表，发送不同请求1在发请求是，jsonp中请求标识就是路由配置中的path值 movielist.js 1234567891011121314151617181920212223242526272829const movieList = &#123; // 开启命名空间 namespaced: true, state: &#123; // 声明数据 title: &apos;&apos;, subjects: [] &#125;, mutations: &#123; // 修改数据 // title数据来源于actions异步请求接收的数据 setTitle(state,payload)&#123; state.title = payload.title; state.subjects = payload.subjects; &#125; &#125;, actions: &#123; 在方法中传入一个参数，该参数可以获取路由配置中的path值 getDateList(context,payload)&#123; const id = payload.path; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(`http://api.douban.com/v2/movie$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125;&#125; movielist.vue 1234567在方法调用时将路由参数传进去 点哪个标识获取哪个的数据created()&#123; this.getDateList(this.$route)&#125;,只有在第一个方法标识改变时，才能获取到数据，因为调用请求数据的方法只触发一次 钩子函数只执行一次，组件已经有了，组件会被复用 8. watch检测路由123456789101112131415161718检测路由参数的变化在组件中检测movielist.vuenew Vue(&#123; watch: &#123; $route(to,from)&#123; console.log(&apos;标识变了&apos;); 对路由变化做出相应 this.getDateList(to); &#125; &#125;&#125;);movielist.jsactions: &#123; getDateList(context,payload)&#123; const id = payload.path &#125;&#125; movielist.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt;&lt;div&gt; &lt;h1 class=&quot;page-header&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;media&quot; v-for=&quot;(item,i) in subjects&quot; :key=&apos;i&apos;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/h4&gt;&#123;&#123;item.original_title&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState(&quot;movieList&quot;,[&apos;title&apos;,&apos;subjects&apos;]) &#125;, created()&#123; this.getDateList(this.$route) &#125;, watch: &#123; $route(to,from)&#123; console.log(to); this.getDateList(to); &#125; &#125;, methods: &#123; ...mapActions(&quot;movieList&quot;,[&apos;getDateList&apos;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; movielist.js 12345678910111213141516171819202122232425262728293031// 模块：专门处理列表组件的数据的部分 数据管理模块import jsonp from &apos;jsonp&apos;const movieList = &#123; // 开启命名空间 namespaced: true, state: &#123; // 声明数据 title: &apos;&apos;, subjects: [] &#125;, mutations: &#123; // 修改数据 // title数据来源于actions异步请求接收的数据 setTitle(state,payload)&#123; state.title = payload.title; state.subjects = payload.subjects; &#125; &#125;, actions: &#123; getDateList(context,payload)&#123; const id = payload.path; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(`http://api.douban.com/v2/movie$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125;&#125;export default movieList; 9. 列表渲染数据12345678&lt;div class=&quot;media&quot; v-for=&quot;(item,i) in subjects&quot; :key=&apos;i&apos;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img :src=&quot;item.images.small&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/h4&gt;&#123;&#123;item.original_title&#125;&#125; &lt;/div&gt; &lt;/div&gt; 10. 列表-vuex-router-sync12345678910请求数据的url是从外部传递过来的，如果能从context中有路由参数，context本身没有路由参数，可以考虑找一个vuex的插件给仓库增加路由信息1.插件： vuex-router-sync2.安装： npm i vuex-touter-sync// npm install --save vuex-touter-sync3.导入并配置 放在main.js文件中 import &#123;sync&#125; from &apos;vuex-touter-sync&apos;; import store from &apos;vuex/store&apos; import router from &apos;router/index.js&apos; const unsync = sync(store,router);4.导入之后 context仓库中就会多一些路由参数信息const path = context.rootState.route.path; main.js 12345678910111213141516import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import vuex from &apos;vuex&apos;import router from &apos;./router/index&apos;import store from &apos;./vuex/index.js&apos;import &apos;../node_modules/bootstrap/dist/css/bootstrap.min.css&apos;import &apos;./assets/css/index.css&apos;给仓库添加路由信息import &#123;sync&#125; from &apos;vuex-touter-sync&apos;;const unsync = sync(store,router);Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App),&#125;).$mount(&apos;#app&apos;) movielist.js 12345678910111213actions: &#123; getDateList(context,payload)&#123; // const id = payload.path; 给仓库添加路由信息 vuex-router-sync const id = context.rootState.route.path; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(`http://api.douban.com/v2/movie$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125; movielist.vue 123456789101112131415161718192021&lt;script&gt;import &#123;mapState,mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState(&quot;movieList&quot;,[&apos;title&apos;,&apos;subjects&apos;]) &#125;, created()&#123; 调用方法时不用传参数 this.getDateList() &#125;, watch: &#123; $route(to,from)&#123; console.log(to); this.getDateList(to); &#125; &#125;, methods: &#123; ...mapActions(&quot;movieList&quot;,[&apos;getDateList&apos;]) &#125;&#125;&lt;/script&gt; 11. 豆瓣电影-详情11.1 配置路由12345678910111213141516171819点击图片跳转到详情页movielist.vue&lt;template&gt;&lt;div&gt; &lt;h1 class=&quot;page-header&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;media&quot; v-for=&quot;(item,i) in subjects&quot; :key=&apos;i&apos;&gt; 配置路由 &lt;router-link :to=&quot;&#123;name: &apos;moviedetail&apos;,params: &#123;id: item.id&#125;&#125;&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img :src=&quot;item.images.small&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/h4&gt;&#123;&#123;item.original_title&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt; 11.2 详情-渲染movieDetail.js 12345678910111213141516171819202122232425import jsonp from &apos;jsonp&apos;const movieDetail = &#123; namespaced: true, state: &#123; movie: &#123; &#125; &#125;, mutations: &#123; setMovie(state,payload)&#123; state.movie = payload; &#125; &#125;, actions: &#123; getDetail(context)&#123; console.log(context); const id = context.rootState.route.params.id; jsonp(`https://api.douban.com/v2/movie/subject/$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setMovie&apos;,data); &#125;); &#125; &#125;&#125;export default movieDetail; store.js 12345678910111213import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import movieList from &apos;./movielist&apos;import movieDetail from &apos;./movieDetail&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; // 使用仓库store选项modules让仓库状态与模块状态进行关联 modules: &#123; movieList, movieDetail &#125;&#125;)export default store; movieDetail.vue 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;movie.title&#125;&#125;&lt;/h2&gt; &lt;img :src=&quot;movie.images.large&quot; alt=&quot;电影海报&quot;&gt; &lt;hr&gt; 简介： &lt;p&gt;简介：&#123;&#123;movie.summary&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState(&quot;movieDetail&quot;,[&apos;movie&apos;]) &#125;, created()&#123; this.getDetail(); &#125;, methods: &#123; ...mapActions(&quot;movieDetail&quot;,[&quot;getDetail&quot;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 12. webpack12.1 webpack介绍1234webpack : 打包 处理项目的资源 闭包： 避免全局变量被污染webpack需要配置parcel: 快速、零配置的web应用程序打包器 https://www.css88.com 12.2 webpack安装1234567891011121314151.webpack文档： https://www.webpackjs.com2.处理项目中所有的资源处理成 对应的模块js/css/jpg/png3.安装： 前提是安装node.js的最新版本4.本地安装： 对大部分项目建议本地安装 每个项目的配置是不一样的 为了保证每个项目有自己的配置5.创建一个文件夹 mkdir 文件夹名 npm第一次使用需要 npm init -y 初始化配置文件 webpack安装某个版本或者特定版本 npm install --save-dev webpack npm install --save-dev webpack@版本号 如果使用的是webpack 4+版本,还需要安装cli npm install --save-dev webpack-cli6.安装结果是可以在当前目录下使用指令进行打包7.webpack和vue没有关系8.指令： webpack --help 查看所有指令 同时测试webpack有没有安装成功 12.3 目录设置123456789101.在下载的webpack文件夹中添加文件 index.html 首页 src/ assets/index.css main.js 程序入口文件 index.js 自己模块2.执行webpack指令 报错： no entry found 没有入口 入口： entry webpack从哪个文件开始打包 出口： output 打包后生成什么文件 12.4 配置文件12345678910111213141516171819202122232425262728291.新建配置文件 webpack.config.js文件 2.配置 从node中引入了path模块 与 const fs = require(&apos;fs&apos;); const path = require(&apos;path&apos;); module.exports = &#123; 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125; &#125;3.重新打包 指令： webpack 默认打包结果是一个压缩文件 dist/bundle.js 用webpack打包后,会提示一个警告,mode选项没有被设置，webpack将使用production这个值，可以设置mode选项为development(非压缩文件)或者production(压缩文件) const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125; &#125; 12.5 webpack-css-loader(处理样式文件)123456789101112131415161718192021222324252627282930webpack默认不能处理样式文件在webpack官网的指南/管理资源下/加载CSS1)安装 npm install --save-dev style-loader css-loader2)const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, 配置css样式 module: &#123; rules: [ &#123; test: /\.css$/, use为什么是数组，里面指的存储是有顺序的，而对象是没有顺序的 use: [ &apos;style-loader&apos;, =&gt; 把处理完的样式代码放在head标签中 &apos;css-loader&apos; =&gt;处理 .css中的样式代码=&gt;放在style 标签里 ] &#125; ] &#125; &#125;webpack默认只能处理.js文件, 非js文件,css需要安装/配置对应的loader加载器 12.6 图片资源12345678910111213141516171819202122232425262728293031323334需要加载器来处理1.安装 npm install --save-dev file-loader2. const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, 配置css样式 module: &#123; rules: [ &#123; test: /\.css$/, use为什么是数组，里面指的存储是有顺序的，而对象是没有顺序的 use: [ &apos;style-loader&apos;, =&gt; 把处理完的样式代码放在head标签中 &apos;css-loader&apos; =&gt;处理 .css中的样式代码=&gt;放在style 标签里 ] &#125;,&#123; 配置图片 test: /\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ] &#125; ] &#125; &#125;3.重新打包 12.7 字体文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051自定义字体文件css3属性@font-face &#123; font-family: &quot;自定义字体名&quot; src: url(&quot;路径&quot;)&#125;使用body &#123; font-family: &apos;字体名&apos;&#125;2.webpack配置2.1 const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, 配置css样式 module: &#123; rules: [ &#123; test: /\.css$/, use为什么是数组，里面指的存储是有顺序的，而对象是没有顺序的 use: [ &apos;style-loader&apos;, =&gt; 把处理完的样式代码放在head标签中 &apos;css-loader&apos; =&gt;处理 .css中的样式代码=&gt;放在style 标签里 ] &#125;,&#123; 配置图片 test: /\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ] &#125;,&#123; 配置字体 &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ] &#125; &#125; ] &#125; &#125;3.打包 webpack 12.8 服务器12345678910111213141516171819202122webpack官网 ： 指南=&gt;管理资源是处理各种资源的配置 指南=&gt;管理输出 清理dist文件夹 指南=&gt;开发 使用webpack-dev-serve配置服务器功能能够实时重新加载 1)安装 npm install --save-dev webpack-dev-server 2)配置 devServer: &#123; contentBase: &apos;./dist&apos; &#125; 3)自定义指令package.json 文件中的scripts是写自定义指令的 &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --open&quot; &#125; 在所有指令中 其他的都是 npm run 指令名 start比较特别 直接 npm start就可以执行指令 webpack服务器]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端项目]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[电商项目1. git介绍1.1 git命令及创建、切换、合并分支1234567891011121314151617181920212223初始化本地仓库 创建目录，在目录中右键打开 git Bash Here , git init 初始化本地仓库 git status 查看文件状态 git add -A 将已经修改的文件和新文件提交到暂存区 git commit -m &quot;&quot; 本地仓库 创建分分支 git branch 分支名：创建分支 git checkout 分支名: 来到了这个分支上（使用分支，或者说切换到哪个分支） 使用分支实现了不同代码的互相独立 git status 查看状态 git add user.html 将新文件user.html提交到暂存区 git commit -m &quot;&quot; 提交到了新分支 不同分支下，相同的文件不会相互影响，只是里面的代码内容那个不同 git log 查看提交过几次 主分支会继承次分支的提交 次分支3次 一共提交4次 还有主分支提交（思考） 合并分支 git checkout master 切换到主分支 git merge 分分支 合并哪个分分支 conflict: 冲突 1.2 git分支相关命令12345678git branch 分支名 创建分支git checkout 分支名 切换分支git merge 分支名 合并分支git branch 查看有几个分支 *号指向哪说明当前在哪个分支下git branch -D 分支名 (大写D或者小写d均可，大写表示强制删除) 只能在当前分支下删除其他分支，不能删除当前分支git checkout -b 分支 创建分支并切换到该分支 1.3 多人协同介绍1.3.1 冲突1234567891011121314同一个文件同一行代码在执行合并的时候，在两个分支上不一样，就会发生冲突。解决冲突后重新提交 git add -A git commit -m &quot;&quot;; git merge master如果进入vim代码编辑模式，按shift+:+q 退出 （:q）master分支： base.css background:red; 第九行user分支: base.css background:yellow; 第九行出现冲突，不知道要保留哪个，如果不是同一行不会出现冲突 1.3.2 远程仓库123456789101112131415161718192021221.创建共享仓库 git要求共享仓库是一个以.git结尾的目录 mkdir git.git 创建以.git结尾的目录 cd git.git 进入这个目录 git init --bare 初始化一个共享仓库，也叫裸仓库 这样就创建好了一个共享的仓库，但这时仓库是空的，并且不允许在这个仓库中进行任何的修改2.向共享仓库共享(同步)内容 将自己开发的项目同步到这个目录中，其他开发者就可以共享你开发的项目 git push ../git.git（远程仓库） master 把自己的项目提交到远程仓库的主分支上 把自己的项目的主分支与分分支合并之后再推到远程仓库的主分支 git checkout master git merge user git push ../git.git master 3.如果别人要使用你提交的项目，克隆 git clone git.git(远程仓库) web(把代码克隆到哪) 克隆下来之后进行操作，再推到远程仓库 git checkout -b cart git add -A git commit -m &quot;&quot; git push ./git.git cart 推到远程仓库的cart分支4.如果自己要使用别人修改之后的远程仓库中的项目，需要把项目拉下来 git pull ../git.git cart 1.3.3 远程仓库相关命令1234567891011创建目录git.git git init --bare 初始化远程仓库将自己的代码提交到远程仓库 git push git.git master从远程仓库拉下代码，第一次是clone git clone ../git.git web(文件夹名项目名) 完成或者修改自己的项目后,推到远程仓库 git push ../git.git cart(分支) 把别人的代码拉下来 git pull ../git.git login(分支) 2. github介绍123456781.点击+号，new repository=&gt;项目名=&gt;描述=&gt;public=&gt;不勾选InInitialize=&gt;create repository2.链接使用SSH将项目提交到github，远程仓库 git push SSH链接 master 第一次将github上的代码赋值下来 git clone SSH链接 项目名 2.1 配置SSH12345678不使用密码登录github在命令行窗口打开 ssh-keygen -t rsa 一直回车键 在c盘用户下有一个.ssh文件，id_rsa.pub文件 中的内容复制到github中 github设置中settings=&gt;SSH and GPG keys=&gt;New SSH key=&gt;title:随便写，内容粘到key中=&gt;add SSH Key如果没有配置SSH，输入git push 链接 master会报致命错误使用https会总是提示输入用户名和密码，如果使用SSH需要以上配置 2.2 练习12345678910111213141516171819202122232425创建文件，添加文件并初始化仓库git init git add -Agit commmit -m &quot;&quot;git push 链接 master另一个人git clone 链接 项目名 不写项目名，默认以.git前面的文件为名称git add -Agit commit -m &quot;&quot;git push 链接 master自己：git pull 链接 分支错误： 如果修改了文件之后没有add commit，不会让你pull error:Your local changes to the following files would be overwritten by merge: index.html Please commit your changes or stash them before you merge.错误： 如果一个人push了，另一个人不能同时push，必须先把代码pull下来以后，才能push，防止冲突 提示：在push之前先做pull防止冲突 2.3 添加远程主机12git remote add origin 链接使用origin代替链接地址 2.4 github pages12345678910111213创建项目=&gt;项目名=&gt;描述=&gt;public =&gt;create repository进入项目文件夹=&gt;git init git add -A git commit -m &quot;&quot; git remote add origin 链接 git push origin master代码右上有一个settings github pages source=&gt;master branch=&gt;save刷新页面 进入github pages进入网站链接即可注意： 只能是静态网站 大小不能超过100M 2.5 git和svn12git是分布式的代码管理工具svn是集中式的代码管理工具 3. 电商项目3.1 介绍12轮播图实现： zepto swiper iScroll滚动 3.2 配置前端服务器1234567配置Apache配置域名： PHPStudy 其他选项菜单=&gt;站点域名管理=&gt;网站域名 网站根目录 第二域名 网站端口可不写 新增 保存并生成 修改host文件配置域名： 其他选项菜单=&gt;打开host=&gt;localhst www.letao.com 或者打开C盘目录,windows/system32/extc/hosts 3.3 配置后端服务器123见文档前端地址：http://www.letao.com后端地址：http://localhost:3030 3.4 后端接口跨域问题123456修改API文档中的app.js文件中,去除注释 app.all(&apos;*&apos;,function(req,res,next)&#123; res.header(&apos;Access-Control-Allow-Origin&apos;,&apos;*&apos;); next(); &#125;); 重启node ,输入两次^C，退出node,再次输入npm start,重新启动node 3.5 登录问题123456789101112131415161718192021222324252627282930313233343536373839user/login.html添加form表单，修改按钮，发送ajax请求步骤： 1.引入jquery.js文件 2.实现登录功能 2.1 获取用户输入表单的信息 2.2 将信息通过ajax请求发送到服务器端 2.3 等待服务器端的响应结果，处理登录后的逻辑 接收地址中的url参数，将?号及?号后面的内容提取出来 var search = location.search.slice(1); var reg = /url=(.+)/; 利用正则表达式来匹配url地址 var match = reg.exec(search); var url = match &amp;&amp; match[1]; 如果有url地址则跳转到该地址，如果没有则跳转到Index.html页面 url = url || &apos;/&apos;; $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; var data = $(this).serialize(); console.log(data); username=xxx&amp;password=123456; $.ajax(&#123; // url:&apos;http://localhost:3000/user/login&apos;, 反向代理 url:&apos;http://58.com/api/user/login&apos;, 可以被简写为 &apos;/api/user/login&apos; 访问api就是访问localhost:3000,不会出现跨域问题 type:&apos;post&apos;, data:data, 对象|字符串都可以 success:function(info)&#123; console.log(info); location.href = &apos;url&apos;; &#125; &#125;); 由于使用ajax发送请求，不需要刷新，所以取消默认跳转功能 return false; |e.preventDefault(); | e.cancelBubble = true; &#125;); 12密码是md5加密的；serialize()：jquery的方法获取表单数据 返回数据是value=key&amp;value2=key2格式的 3.6 查询用户信息(cookie跨域)1234567891011121314151617user/index.html 会员中心 引入jquery.js文件步骤： 获取用户信息 1.发送请求获取用户信息 $.ajax(&#123; // url:&apos;http://localhost:3000/user/queryUserMessage&apos;, 出现跨域问题，使用反向代理实现跨域 url:&apos;http://58.com/api/user/queryUserMessage&apos;, 简写为 url:&apos;/api/user/queryUserMessage&apos;, type:&apos;get&apos;, 参数无 success:function(info)&#123; console.log(info); 无法获取已登录信息，因为跨域限制了cookie 根据响应结果判断是否登录 if(info.error)&#123; location.href = &apos;/user/login.html&apos;; &#125; &#125; &#125;); 123注意： 跨域不但限制了XMLHttpRequest(即ajax)也限制了cookie。 CORS中设置的Access-Control-Allow-Origin:*只是用来解决XMLHttpRequest的跨域限制的，并不能解决cookie的跨域问题。 3.7 配置Apache的反向代理123456789通过配置apache可以实现代理访问nodejs服务器配置apache： 1.phpstudy中=&gt;其他选项菜单=&gt;打开配置文件=&gt;vhosts-conf proxyRequests Off 关闭正向代理 proxyPass /api http://localhost:3000 如果访问的地址是/api开头 代理到localhost:3000 2.phpstudy中=&gt;其他选项菜单=&gt;打开配置文件=&gt;httpd-conf LoadModule proxy_module modules/mod_proxy.so 解开注释 LoadModule proxy_http_module modules/mod_proxy_http.so 解开注释 重新启动PHPStudy 3.8 退出登录1234567891011121314151617181920通过git实现,下载代码到目录，创建新分支，并切换到该分支 feature-userindex.html点击退出按钮，跳转到登录页面步骤： 1.添加点击事件 2.发送请求 3.等待后端响应 4.处理响应的逻辑 $(&apos;.btn_outLogin&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url:&apos;/api/user/logout&apos;, type:&apos;get&apos;, 不需要参数 success:function(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/index.html&apos;; &apos;/&apos; &#125; &#125; &#125;); &#125;); 3.9 用户注册123456789101112131415161718192021222324252627282930313233343536373839404142434445register.html引入jquery.js文件步骤： 修改html文件，添加form表单，修改注册a链接为button按钮 1.获取表单中用户填写的信息 2.发送这些信息 3.等待后端响应结果 4.处理响应的逻辑 $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; 获取表单中用户填写的信息,serialize方法会自动忽略没有name的表单信息，如果不需要确认密码，那么可以把确认密码的name属性去掉 var data = $(this).serialize(); $.ajax(&#123; url:&apos;/api/user/register&apos;, type:&apos;post&apos;, data:data, success:funtion(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/user/login.html&apos;; return; &#125; 错误提示 alert(info.message); &#125; &#125;); 阻止表单默认提交 return false; &#125;); 获取验证码 步骤： 1.点击事件 2.发送请求 3.等待服务端响应结果 4.处理相应的逻辑 $(&apos;.btn_getCode&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url:&apos;/api/user/vCode&apos;, type:&apos;get&apos;, 参数无 success:function(info)&#123; console.log(info); &#125; &#125;); &#125;); 3.10 修改密码1234567891011121314151617181920212223242526272829303132333435363738394041424344password.html引入jquery.js文件，添加form表单，修改按钮a链接为button步骤： 1.获取表单信息 2.发送表单信息 3.等待服务器响应结果 4.处理相关业务逻辑 $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; 获取表单中用户填写的信息,serialize方法会自动忽略没有name的表单信息，如果不需要确认密码，那么可以把确认密码的name属性去掉 var data = $(this).serialize(); $.ajax(&#123; url:&apos;/api/user/updatePassword&apos;, type:&apos;post&apos;, data:data, success:funtion(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/user/login.html&apos;; return; &#125; 错误提示 alert(info.message); &#125; &#125;); 阻止表单默认提交 return false; &#125;); 获取验证码 步骤： 1.点击事件 2.发送请求 3.等待服务端响应结果 4.处理相应的逻辑 $(&apos;.btn_getCode&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url:&apos;/api/user/vCodeForUpdatePassword&apos;, type:&apos;get&apos;, 参数无 success:function(info)&#123; console.log(info); &#125; &#125;); &#125;); 123456789用户模块完成git statusgit add -Agit commit -m &quot;用户模块完成，等待测试&quot; 确定分支，和修改的文件，将代码发送到远程仓库上的feature-user分支上git push origin feature-user创建新的分支，首先先切换到主分支master，再创建新分支，因为原来的feature-user分支还没测试完毕。git checkout mastergit checkout -b feature-address 3.11 收货地址列表1234567891011121314151617181920212223242526272829303132333435363738394041git checkout feature-addressuser/address.html引入jquery.js文件，引入模板引擎template-web.js文件获取地址列表 步骤: 1.发送ajax请求 2.等待服务器响应 3.处理数据 $.ajax(&#123; url:&apos;/api/address/queryAddress&apos;, type:&apos;get&apos;, 参数无,修改文档参数为无。 success:function(info)&#123; console.log(info); if(info.error)&#123; location.href = &quot;/user/login.html?url=&quot;+location.href; return; &#125; 可以简写为： if(info.error) return location.href=&quot;/user/login.html?url=&quot;+location.href; 处理数据使用模板引擎 调用模板引擎 var html = template(&apos;template&apos;,&#123;lists:info&#125;); $(&apos;ul&apos;).html(html); &#125; &#125;); 模板引擎： 定义模板 &lt;script type=&quot;text/html&quot; id=&quot;template&quot;&gt; &#123;&#123;each lists value&#125;&#125; &lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;div class=&quot;mui-slider-right mui-disabled&quot;&gt; &lt;a class=&quot;mui-btn mui-btn-red&quot; data-id=&apos;&#123;&#123;value.id&#125;&#125;&apos;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;a href=&quot;addressManage.html&quot; class=&quot;mui-navigate-right mui-slider-handle&quot;&gt; &lt;div class=&quot;delivery&quot;&gt;邮编：&lt;span&gt;&#123;&#123;value.postCode&#125;&#125;&lt;/span&gt;&amp;nbsp;收货人：&lt;span&gt;&#123;&#123;value.recipients&#125;&#125;&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;address&quot;&gt;&#123;&#123;value.address&#125;&#125;&#123;&#123;value.addressDetail&#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/script&gt; 3.12 乐淘添加地址123456789101112131415161718192021222324252627282930313233343536371)在address.html页面添加添加地址按钮&lt;style&gt; .add_btn &#123; padding: 0 30px; &#125;&lt;/style&gt;&lt;div class=&quot;add_btn&quot;&gt; &lt;a href=&quot;/user/addAddress.html&quot; type=&quot;submit&quot; class=&quot;mui-btn mui-btn-primary btn-login&quot;&gt;新增地址&lt;/a&gt;&lt;/div&gt;2)给列表添加a链接，跳转到修改页面3)添加form表单，修改提交按钮新增地址步骤： 1.获取表单数据 2.发送数据到服务端 3.等待服务器响应结果 4.处理响应逻辑 $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; 获取表单数据 var data = $(this).serialize(); $.ajax(&#123; url:&apos;/api/address/addAddress&apos;, type:&apos;post&apos;, data:data, success:function(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/user/address.html&apos;; &#125; &#125; &#125;); 阻止默认跳转 return false; &#125;); 3.13 删除地址123456789101112131415161718192021不能直接给删除按钮绑定点击事件，因为地址列表是由模板引擎渲染来的，当点击按钮的时候，ajax还没渲染完，所以需要事件委托来绑定事件。$(&apos;#address&apos;).on(&apos;click&apos;,&apos;.mui-btn-red&apos;,function()&#123; var id = $(this).attr(&apos;data-id&apos;); var _this = $(this); $.ajax(&#123; url:&apos;/api/address/deleteAddress&apos;, type:&apos;post&apos;, data:&#123;id:id&#125;, success:function(info)&#123; console.log(info); if(info.success)&#123; 这里面的this是ajax里面的this // _this.parent().parent().parent(); // parents(); 获取祖先的方法,获取祖先中的li父元素 _this.parents(&apos;li&apos;).fadeOut(function()&#123; $(this).remove(); &#125;); &#125; &#125; &#125;);&#125;); 3.14 编辑地址12 3.15 将feature-address分支提交到远程仓库1234567切换到分支： git checkout feature-address git add -A git commit -m &quot;收货地址&quot; git push origin feature-address git checkout master git merge feature-address git checkout -b featrue-product 3.16 优化登录123456789101112131415address.html从哪个页面点击到登录页面，登录之后再跳转到原来的页面跳转到登录页面时,传入参数url记录当前传入的是哪个地址，if(info.error) return location.href= &apos;/user/login.html?url=&apos;+location.href;login.html获取地址参数，如果有url参数，登录成功后跳转到url参数所对应的地址，如果没有url参数，则默认跳转到首页。location.search: 获取的是url地址后面 ？号及？号后面的内容var search = location.search.slice(1); 从下标为1的地方开始截取，截取到结尾。search:url=location.href通过正则表达式获取地址中的参数var reg = /url=(.+)/;var match = reg.exec(search);var url = match &amp;&amp; match[1];url = url || &apos;/&apos;; 4. mui组件介绍1234dev.dcloud.net.cn/mui mui组件图片轮播区域滚动组件提示框：4种 5. 商品列表123456789101112131415161718192021222324252627282930index.html引入模板引擎$.ajax(&#123; url:&apos;/api/product/queryProduct&apos;, type:&apos;get&apos;, data:&#123; page: 1, pageSize:6 &#125;, success:function(info)&#123; console.log(info); 调用模板引擎 var html = template(&apos;template&apos;,info); $(&apos;#product&apos;).html(html); &#125;&#125;);模板引擎&lt;script type=&apos;text/template&apos; id=&apos;template&apos;&gt; &#123;&#123;each data value&#125;&#125; &lt;a href=&quot;/product.html?id=&#123;&#123;value.id&#125;&#125;&quot; class=&quot;cz_product&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;/api&#123;&#123;value.pic[0].picAddr&#125;&#125;&quot; alt=&quot;&quot;/&gt; &lt;p class=&quot;name&quot;&gt;&#123;&#123;value.proName&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span class=&quot;price&quot;&gt;&amp;yen;&#123;&#123;value.price&#125;&#125;&lt;/span&gt;&lt;span class=&quot;oldPrice&quot;&gt;&amp;yen;&#123;&#123;value.oldPrice&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;button class=&quot;button&quot;&gt;立即购买&lt;/button&gt; &lt;/div&gt; &lt;/a&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; 6. 商品详情123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990product.html 获取地址中的商品id，然后根据id获取商品详情1.获取地址参数 a.解析地址参数数据 var search = location.search.slice(1); var arr = search.split(&apos;&amp;&apos;); var obj = &#123;&#125;; arr.forEach(function(item)&#123; var temp = item.split(&apos;=&apos;); console.log(temp[0]); console.log(temp[1]); obj[temp[0]] = temp[1]; &#125;);2.发送请求$.ajax(&#123; url:&apos;/api/product/queryProductDetail&apos;, type:&apos;get&apos;, data:&#123;id: obj.id&#125;, success:function(info)&#123; console.log(info); 将info.size中的数据，分割成数组 info.size = info.size.split(&apos;-&apos;); 计算折扣： toFixed(1):保留几位小数点 info.discount = (info.price/info.oldPrice*10).toFixed(1); 调用模板引擎 var html = template(&apos;template&apos;,info); $(&apos;#detail&apos;).html(html); &#125; &#125;);3.处理json数据定义模板引擎只有一条数据，不需要遍历&lt;script type=&quot;text/html&quot; id=&quot;template&quot;&gt; &lt;div class=&quot;cz_banner mui-slider&quot;&gt; &lt;div class=&quot;mui-slider-group mui-slider-loop&quot;&gt; &lt;div class=&quot;mui-slider-item mui-slider-item-duplicate&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-item mui-active&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-item mui-active&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-item mui-slider-item-duplicate&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-indicator&quot;&gt; &lt;div class=&quot;mui-indicator mui-active&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mui-indicator&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;p_title&quot;&gt; &#123;&#123;proName&#125;&#125; &lt;/div&gt; &lt;div class=&quot;p_price&quot;&gt; &lt;span class=&quot;fold&quot;&gt;&lt;span&gt;&#123;&#123;discount&#125;&#125;&lt;/span&gt;折&lt;/span&gt; 价格：&lt;strong class=&quot;present&quot;&gt;¥ &#123;&#123;price&#125;&#125;&lt;/strong&gt; &lt;del class=&quot;original&quot;&gt;¥&#123;&#123;oldPrice&#125;&#125;&lt;/del&gt; &lt;/div&gt; &lt;div class=&quot;p_size&quot;&gt; 尺码： &#123;&#123;each size val&#125;&#125; &lt;span class=&quot;btn_size&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/span&gt; &#123;&#123;/each&#125;&#125; &lt;/div&gt; &lt;div class=&quot;p_number&quot;&gt; 数量： &lt;span class=&quot;jian btn_act&quot;&gt;-&lt;/span&gt; &lt;input type=&quot;tel&quot; class=&quot;btn_num&quot; value=&quot;1&quot; /&gt; &lt;span class=&quot;jia btn_act&quot;&gt;+&lt;/span&gt; 剩余：&#123;&#123;num&#125;&#125; 件 &lt;/div&gt; &lt;div class=&quot;p_detail&quot;&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;/script&gt;删除除轮播图和区域滚动以外的js插件, 上拉刷新 图片懒加载 7. 添加购物车12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758修改produce.html中的购物车按钮，跳转到/cart.html点击购物车添加购物车： 1.添加点击事件 获取商品信息 2.发送ajax请求 $(&apos;.btn_addCart&apos;).on(&apos;click&apos;,function()&#123; 获取商品信息 数量 var num = $(&apos;.btn_count&apos;).val(); var size = $(&apos;span.active&apos;).text(); $.ajax(&#123; url: &apos;/api/cart/addCart&apos;, type:&apos;post&apos;, data:&#123; productId:obj.id, num:num, size: 40 &#125; success:function(info)&#123; console.log(info); if(info.error)&#123; return mui.alert( &apos;请先登录&apos;, &apos;提示&apos;, &apos;确认&apos;, function()&#123; location.href = &apos;/user/login.html?url=&apos;+location.href; &#125; ); &#125; mui.toast(&apos;添加成功&apos;); &#125; &#125;); &#125;);选择型号:由于元素是动态添加的不能直接给元素添加事件，通过实践委托来实现 // 获取型号 $(&apos;#detail&apos;).on(&apos;click&apos;, &apos;.btn_size&apos;, function () &#123; $(this).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); &#125;)// 修改商品数量$(&apos;#detail&apos;).on(&apos;click&apos;, &apos;.btn_act&apos;, function () &#123; // 获取数量 var input = $(this).siblings(&apos;input&apos;); var n = input.val()-0; 转数字 if($(this).is(&apos;.jia&apos;)) &#123; // 加 如果n的值大于库存的值，return if(n &gt;= $(&apos;.btn_total&apos;).text()-0) return; return input.val(++n); &#125; // 减 if(n &lt;= 1) return; input.val(--n);&#125;)注意：如果商品数量手动修改的话，添加失去焦点事件 8. 购物车列表123456789101112131415161718192021222324252627cart.html获取购物车列表1.发送ajax请求2.等待响应3.处理json数据$.ajax(&#123; url:&apos;/api/cart/queryCart&apos;, type:&apos;get&apos;, data:&#123;id: obj.id&#125;, success:function(info)&#123; console.log(info); if(info.error)&#123; return mui.alert( &apos;请先登录&apos;, &apos;提示&apos;, &apos;确认&apos;, function()&#123; location.href = &apos;/user/login.html?url=&apos;+location.href; &#125; ) &#125; var html = template(&apos;template&apos;,&#123;lists:info&#125;); $(&apos;#cart&apos;).html(html); &#125; &#125;);模板引擎 9. 分类123456789cate.html获取分类1.发送请求获取顶级分类$.ajax(&#123; &#125;);2.处理顶级分类数据3.点击顶级分类，获取相应的二级分类4.处理二级分类数据 10. cookie跨域12 11. mui上拉下拉刷新1直接调用mui组件 12. 购物车上下拉交互12 13. 分类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869发送ajax请求，获取一级二级分类&lt;!-- 自定义顶级分类模板 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;topTpl&quot;&gt; &lt;ul&gt; &#123;&#123;each rows val&#125;&#125; &lt;li data-id=&quot;&#123;&#123;val.id&#125;&#125;&quot;&gt;&#123;&#123;val.categoryName&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/script&gt;&lt;!-- 自定义二级分类模板 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;childTpl&quot;&gt; &lt;span class=&quot;title&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;ul class=&quot;mui-clearfix&quot;&gt; &#123;&#123;each rows val&#125;&#125; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;/api&#123;&#123;val.brandLogo&#125;&#125;&quot; alt=&quot;&quot;/&gt; &lt;p&gt;&#123;&#123;val.brandName&#125;&#125;&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/script&gt;发送ajax请求// 获取分类// 1. 发送请求获取顶（一）级分类$.ajax(&#123; url: &apos;/api/category/queryTopCategory&apos;, type: &apos;get&apos;, success: function (info) &#123; // 2. 处理顶（一）级分类数据 console.log(info); // 调用模板引擎 var html = template(&apos;topTpl&apos;, info); // 添加DOM $(&apos;#top&apos;).html(html); // 添加默认数据 $(&apos;#top li:first-child&apos;).trigger(&apos;click&apos;); &#125;&#125;); // 3. 再次点击顶（一）级分类，获取相应的二级分类$(&apos;#top&apos;).on(&apos;click&apos;, &apos;li&apos;, function () &#123; // 获取顶级分类id var id = $(this).attr(&apos;data-id&apos;); // 顶级分类名称 var text = $(this).text(); // 改变顶级分类的样式 $(this).addClass(&apos;now&apos;).siblings().removeClass(&apos;now&apos;); $.ajax(&#123; url: &apos;/api/category/querySecondCategory&apos;, type: &apos;get&apos;, data: &#123;id: id&#125;, success: function (info) &#123; // 4. 处理二级分类数据 console.log(info); // 顶级分类名称 info.text = text; // 调用模板引擎 var html = template(&apos;childTpl&apos;, info); // 添加DOM $(&apos;#child&apos;).html(html); &#125; &#125;);&#125;) 14. cors跨域1cors可以同时支持ajax跨域和cookie跨域。反向代理可以支持cookie跨域。 15. 关于上拉下拉操作12购物车上拉刷新下拉加载mui官网案例：上拉加载 下拉刷新 16. 购物车上下拉交互1添加mui上拉下拉组件，实现功能 17. 下拉刷新1下拉取数据 18. 上拉加载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104上拉取数据&lt;!-- 自定义购物车模板 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt; &#123;&#123;each data val&#125;&#125; &lt;li data-product=&quot;&quot; class=&quot;mui-table-view-cell&quot;&gt; &lt;div class=&quot;mui-slider-right mui-disabled&quot;&gt; &lt;a class=&quot;mui-btn mui-btn-blue&quot;&gt;编辑&lt;/a&gt; &lt;a class=&quot;mui-btn mui-btn-red&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;mui-navigate-right mui-slider-handle&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;/api&#123;&#123;val.pic[0].picAddr&#125;&#125;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; &lt;p class=&quot;name&quot;&gt;&#123;&#123;val.proName&#125;&#125;&lt;/p&gt; &lt;p class=&quot;info&quot;&gt; &lt;span class=&quot;price&quot;&gt;&amp;yen;&#123;&#123;val.price&#125;&#125;&lt;/span&gt; &lt;span class=&quot;oldPrice&quot;&gt;&amp;yen;&#123;&#123;val.oldPrice&#125;&#125;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;x&#123;&#123;val.num&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span class=&quot;size&quot;&gt;鞋码：&#123;&#123;val.size&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt;&lt;script&gt;// 初始化变量var page = 1;var pageSize = 5;mui(function()&#123; mui.init(&#123; pullRefresh : &#123; container: &quot;.cz_container&quot;, down: &#123; height: 50, auto: true, contentdown: &quot;下拉可以刷新&quot;, contentover: &quot;释放立即刷新&quot;, contentrefresh: &quot;正在刷新...&quot;, callback: function () &#123; $.ajax(&#123; url: &apos;/api/cart/queryCartPaging&apos;, type: &apos;get&apos;, data: &#123; // 刷新永远为第1页 page: 1, pageSize: pageSize &#125;, success: function (info) &#123; // console.log(info); // 调用模板引擎 var html = template(&apos;tpl&apos;, info); // 添加DOM $(&apos;#cart&apos;).html(html); // 当请求完成时需要手动 // 终止请求（官方文档有误） mui(&apos;.cz_container&apos;).pullRefresh().endPulldownToRefresh(); // 下拉刷新后将页码重置为1 page = 1; mui(&apos;.cz_container&apos;).pullRefresh().enablePullupToRefresh(); &#125; &#125;); &#125; &#125;, up: &#123; height: 50, auto: false, contentrefresh: &quot;正在加载...&quot;, contentnomore: &apos;没有更多数据了&apos;, callback: function () &#123; page++; // 发送请求请求更多数据 $.ajax(&#123; url: &apos;/api/cart/queryCartPaging&apos;, type: &apos;get&apos;, data: &#123; page: page, pageSize: pageSize &#125;, success: function (info) &#123; console.log(info); // 终止上拉交互 if(info.length == 0) &#123; mui(&apos;.cz_container&apos;).pullRefresh().endPullupToRefresh(true); return; &#125; // 调用模板引擎 var html = template(&apos;tpl&apos;, info); // 一定追加 $(&apos;#cart&apos;).append(html); // 手动终止请求 mui(&apos;.cz_container&apos;).pullRefresh().endPullupToRefresh(); &#125; &#125;) &#125; &#125; &#125; &#125;);&#125;);&lt;/script&gt; 19. 购物车完善12 20. 后端登录123456789101112131415161718192021222324252627282930313233343536373839进入后台首页，判断有没有登录，没登陆跳转到登录页1.检测用户登录// 检测用户登录$.ajax(&#123; url: &apos;/api/employee/checkRootLogin&apos;, type: &apos;get&apos;, success: function (info) &#123; if(info.error) location.href = &apos;/admin/login.html&apos;; &#125;&#125;);2.登录页面// 获取地址参数var search = location.search.slice(1);// 使用正则匹配 url 参数的值var reg = /url=(.+)/;// 匹配到的地址var match = reg.exec(search);var url = match &amp;&amp; match[1];url = url || &apos;/admin&apos;;$(&apos;form&apos;).on(&apos;submit&apos;, function () &#123; // 1. 获取用户表单填写的信息 var data = $(this).serialize(); // 2. 发送请求至服务端 $.ajax(&#123; url: &apos;/api/employee/employeeLogin&apos;, type: &apos;post&apos;, data: data, success: function (info) &#123; // 3. 待待响应结果 console.log(info); if(info.success) &#123; return location.href = url; &#125; // 提示错误 alert(info.message); &#125; &#125;) return false;&#125;) 21. 后台退出登录12345678910111213// 退出登录$(&apos;.fa-sign-out&apos;).parent().on(&apos;click&apos;, function () &#123; // 发送请求 $.ajax(&#123; url: &apos;/api/employee/employeeLogout&apos;, type: &apos;get&apos;, success: function (info) &#123; if(info.success) &#123; location.href = &apos;/admin/login.html?url=&apos; + location.href; &#125; &#125; &#125;);&#125;) 22. 后台用户列表1234567891011121314151617181920212223242526272829303132333435363738// 获取用户列表$.ajax(&#123; url: &apos;/api/user/queryUser&apos;, type: &apos;get&apos;, data: &#123; page: 1, pageSize: 100 &#125;, success: function (info) &#123; console.log(info); // 调用模板引擎 var html = template(&apos;tpl&apos;, info); // 添加DOM $(&apos;tbody&apos;).html(html); &#125;&#125;);模板引擎&lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt; &#123;&#123;each rows val key&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;key+1&#125;&#125;&lt;/td&gt; 因为使用id删除数据后编号不是连续的 &lt;td&gt;&#123;&#123;val.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;val.mobile&#125;&#125;&lt;/td&gt; &#123;&#123;if(val.isDelete == 0)&#125;&#125; &lt;td&gt;是&lt;/td&gt; &#123;&#123;else&#125;&#125; &lt;td&gt;否&lt;/td&gt; &#123;&#123;/if&#125;&#125; &lt;td data-id=&quot;&#123;&#123;val.id&#125;&#125;&quot; data-status=&#123;&#123;val.isDelete&#125;&#125;&gt; &#123;&#123;if(val.isDelete == 0)&#125;&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;btn btn-info btn-xs&quot;&gt;启 用&lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;btn btn-warning btn-xs&quot;&gt;禁 用&lt;/a&gt; &#123;&#123;/if&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; 23. 后台修改用户12 24. 省市县插件12 项目中问题121.后端端口号不正确，导致发生ajax请求之后没有响应。2.表单默认提交，导致控制台测试的数据，打印后会立刻消失 扩展相对路径和绝对路径12345671.凡是以./或者是../开头的都叫相对路径2.在window系统中，凡是以盘符开头的都叫绝对路径 c:\admin3.在linux或者是MAC系统中，凡是以/开头的都叫绝对路径 4.在网络环境中，凡是以http://域名：端口号/a/b/c开头的叫绝对路径http://letao.com 可以被简写成 /http://letao.com/a/b 可以被简写成 /a/bhttp://letao.com/api/user/login 可以被简写成 /api/user/login git创建分支特点123如果是添加新功能： feature-user如果是修复bug: fix-user如果是着急修复的bug:hotfix-user 保留几位小数点12var num = 123.456;num.toFixed(1); 保留一位小数点 字符串的数字相比较12如果是字符串的数字相比较,先比较第一位数字，第一位大的就大&apos;3&apos; &gt; &apos;20&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[node笔记]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Node1. Node是什么123456789101112131415161718nodejs.cn node中文网https://nodejs.org/en 英文网node社区: https://cnodejs.orgjs代码是浏览器里面的解释器来运行js代码。Node.js是一个基于Chrome V8引擎的JavaScript的运行环境，node.js使用了一个事件驱动、非阻塞式I/O的模型，使其轻量又高效。。node是js的运行环境。浏览器和node中js的区别： 1.没有DOM和BOM 2.有ECMAScript 3.有自己的APInode -v:检测是否安装好node按node回车：进入REPL环境中,进行代码的简单测试按ctrl+c两次退出REPL环境node运行js文件： 1.命令行窗口进入.js文件所在目录 2.node+空格+.js文件名+回车 3.输入cls命令 清屏 node helloworld.js 2. 模块体验2.1 fs文件模块12345678910111213141516171819202122232425262728293031321.node中模块fs 读取本地文件 1)导入模块 var fs = require(&apos;fs&apos;); 2)使用该模块的API fs.readFile(形参1，形参2，形参3); 形参1:path要读取文件的文件路径 形参2:可选参数 形参3:回调函数 callback(err,data) fs.readFile(&apos;txt.txt&apos;,function(error,data)&#123; console.log(error); 如果错误，抛出异常，后续代码不会执行，不需要写return|else;s throw： js关键字 if(error)&#123; throw error; &#125; data默认类型是Buffer16进制数据,toString()把数据转化为字符串格式 data = data.toString(); console.log(data); &#125;);2.node中模块fs 写入文件 1）导入fs模块 var fs = require(&apos;fs&apos;); 2）使用fs的API fs.writeFile(形参1，形参2，形参3,形参四); 形参1:path要读取文件的文件路径 形参2:要写入的数据 形参3:可选参数 形参4:回调函数 callback(err) fs.writeFile(&apos;txt.txt&apos;,&apos;我是数据&apos;,function(error)&#123; console.log(error); &#125;); 注意:如果文件路径不存在此文件,会自动创建该文件;如果文件存在，会把数据重新写入此文件,会覆盖原来的内容。 2.2 http模块12345678910111213141516171819202122232425262728http快速搭建服务器1.导入http模块var http = require(&apos;http&apos;);2.创建服务器实例对象var server = http.createServer();3.绑定事件，处理请求和响应.on(&apos;request&apos;,callback(request,response));&apos;request&apos;:固定语法回调函数中,request是请求对象(请求路径/请求浏览器信息/系统信息等)，reponse是响应对象var app = server.on(&apos;request&apos;,function(request,response)&#123; 处理请求对象 返回响应 console.log(&apos;发送请求&apos;); 向发起请求的页面写入字符串 response.write(&apos;sadfjsakjfla&apos;); 结束当前响应 response.end(); 如果没有结束响应，前端发起请求，会一直等待服务端返回响应,当超时之后就会。。&#125;);4.监听端口号.listen(端口号，callback());app.listen(8080,function()&#123; console.log(&apos;run it at localhost:12345 in your bower&apos;);&#125;);注意： 在客户端输入localhost:8080,页面上会出现字符 在node服务端会显示两次&quot;发送请求&quot;,原因是发送了两次请求 除了自己发送的请求之外，还有浏览器默认的请求，网站的小图标，facvico.ico 2.3 模块特点123456789101112模块：具有独立功能的js文件是一个模块导出: module.exports.xxx = xxx;导入模块： require(&quot;文件路径&quot;);111.jsvar model = require(&apos;./222.js&apos;);console.log(model); &#123;num: 10&#125;console.log(model.num); 10222.jsvar num = 10;module.exports.num = num; 2.4 模块系统2.4.1 导出模块12345678910111213每个js模块都会有一个module.exports对象module.exports.成员名 = 值;var add = function(x,y)&#123; return x + y;&#125;导出module.exports: 原来是个空对象 &#123;&#125;module.exports.add = add;module.exports: &#123;add:function()&#123;&#125; &#125;导入vae model = require(&apos;222.js&apos;);console.log(model.add(1+5)); 2.4.2 导入模块1234567891011121314require方法的注意事项： 1.require方法的作用 导入模块并且执行模块中的代码 var model = require(&quot;./b.js&quot;); 2.require方法 同步加载模块 3.加载模块时，如果后面是js文件，可以不写后缀 var model = require(&quot;./b&quot;); 4.require方法导入模块时，路径是不能省略的，如果省略了，就会当作是自己模块中的方法，会报错。必须添加./或../ require(&apos;b&apos;); 报错，找不到b模块 require(&apos;./b&apos;); 5.不会重复加载 var model1 = require(&apos;./b&apos;); var model2 = require(&apos;./b&apos;); var model3 = require(&apos;./b&apos;); 就会执行一次结果，不会重复执行,会把第一次执行结果，自动缓存，无论后面导入几次，都不会去执行，为了提高性能，提高内存。 2.5 模块分类及第三方包的使用12345678910111213141.核心模块 由module本身自己提供,例如fs文件模块、http模块2.自己定义的模块 自己写的.js文件，按照路径来加载，注意./或者../不能省略3.第三方模块 1)在npm网站找包（模块） https://www.npmjs.com/ npmjs官网 npm -v npm init npm install 包名：安装包,会多node_modules等很多文件 2)打开cmd，使用命令npm install 包名 安装 3)在需要使用的位置，通过require(&apos;第三方包名&apos;)加载包 var $ = require(&apos;jquery&apos;); 第三方包的加载方式和核心模块的方式一样。 4)看文档调用API 3. node命令使用123npm -v 查看npm版本npm initnpm install 包名： npm install jquery 4. npm包管理器4.1 npm是什么1234567npm:Node Package Manager第一次使用npm需要npm initnpm init 一直回车，在项目的目录下，会生成一个配置文件，package.json文件。npm install jquery 1.在目录下,会生成node_module文件，各种第三方包的源码，同时会生成一个package-lock.json文件 2.修改配置文件package.json的信息，在依赖项里面增加包的名字 4.2 npm常用指令1234567891011121.npm init简化 npm init -y 生成package.json 使用这个指令，不需要一直敲回车，会自动生成默认值2.npm install 包名|npm i 包名 会默认下载最新稳定版3.npm install 包名@版本号 下载指定版本的jquery npm install jquery@1.11.2 install可以简写为i4.简写 npm i 包名5.卸载包 npm uninstall 包名 简写为 npm un 包名6.升级/更新包 npm i npm -g 4.3 package.json文件1234dependencies 依赖项:当前项目依赖了哪些包如果只输入npm i会自动的去package.json的dependencies中找依赖的包并下载。npm i 如果写完项目,需要上传到github,不需要上传node_module文件夹，只需上传package.json文件即可。 4.4 package-lock.json文件1231.锁定包的版本 更安全2.锁定包下载地址 第二次下载时速度更快npm5以下的版本不会自动生成 npm5以上版本会自动生成这个文件 4.5 npm使用总结123456npm init -y 生成package.json文件npm i 包名@版本号npm i npm un 包名 卸载包node_modules 不需要关心这个文件夹里面的东西，是各个包package-lock.json:锁定包版本和下载地址 5. ES6介绍12http://es6.ruanyifeng.comECMAScript 6 入门 5.1 ES6关键字 - let12345678910111213141516171819202122var变量： 变量提升 全部变量/局部变量 可以声明同名的变量 没有块级作用域let: 用来声明变量 1.在同一个作用域内不能声明多个同名变量 let a = 10; let a = 20; console.log(a); 报错,a已经声明 2.变量必须先声明再使用，如果直接使用会报错,变量没有被定义，没有变量提升 console.log(a); let a = 10; 变量不会被提升 3.let声明的变量有块级作用域 &#123;&#125; if(1)&#123; let a = 10; &#125; console.log(a); 4.let声明的变量可以被重新赋值 let a= 10; a = 20; console.log(a); 20 5.2 ES6关键字 - const123456789101112const:用来声明常量const a = 10;console.log(a); 10特点： 1.声明的同时必须赋值 const a; 报错，少了一个初始值 2.const声明的常量不能被重新赋值 const a = 10; a = 20; 3.其他特点和let一样 块级作用域 先声明后使用 没有变量提升 在同一个作用域内不能声明多个同名变量 4.如果不知道变量和常量怎么区分，建议全使用const，如果报错，使用let. 5.3 ES6 解构赋值1解构赋值：把变量的值提取出来赋值给新变量的过程 5.3.1 数组的解构赋值12345678910111213141516171819201.var arr = [1,2,3];var [a,b,c] = arr;console.log(a,b,c); 1 2 32.var arr = [1,2,3];var [a,b] = arr;console.log(a,b); 1 23.var arr = [1,2,3];var [a, ,c] = arr;console.log(a,c); 1 34.var arr = [1,2,3];var [a,b,c,d] = arr;console.log(a,b,c,d); 1 2 3 undefined5.var arr = [1,2,3];var [a,b,c,d=20] = arr;console.log(a,b,c,d); 1 2 3 206.交换两个变量的值var a = 10;var b = 20;var [a,b] = [b,a];console.log(a,b); 5.3.2 对象的解构赋值1234567891011121314151617写法一：1.var per = &#123; name: &apos;哈哈哈&apos;， age:19&#125;var &#123;name,age&#125; = per;console.log(name,age); 哈哈哈 192.对象的结构赋值与参数的顺序无关，但参数名必须一样。 var &#123;age,name&#125; = per; 正确 var &#123;xxx,age&#125; = per; 错误3.写法二：给每个key起一个新名字var per = &#123; name: &apos;小四&apos;, age: 20&#125;;var &#123;name:newname, age:newage&#125; = per;console.log(newname,newage); 小四 20 6. ES6字符串新特性6.1 新增API1234567891011121.startsWith()判断字符串是不是以形参的字符串开始，返回值是boolean类型var bool = &quot;abc&quot;.startsWith(&apos;ab&apos;);console.log(bool); true2.endsWith();判断字符串是不是以形参的字符串结尾，返回值是boolean类型var result = &quot;abc&quot;.endsWith(&apos;c&apos;);console.log(result);3.includes();判断字符串是不是包含形参字符，返回值是boolean类型var result = &quot;abc&quot;.includes(&apos;b&apos;);console.log(result); 6.2 模板字符串12345678910111.模板字符串使用的是反引号： 1旁边的符号2.模板用 $&#123;&#125;来填充3.支持换行var per = &#123; name: &apos;哈哈哈&apos;, age:18&#125;;var strHtml = `我的名字是$&#123;per.name&#125;,年龄是$&#123;per.age&#125;`;console.log(strHtml); 7. 函数新特性=&gt;箭头函数7.1 新特性=&gt;形参123456789101112131415161718192021222324252627282930313233343536373839404142431.函数参数可以指定默认值function fn1()&#123; x = x||10; return x;&#125;console.log(fn1());2.函数如果给定了实参，则使用实参，否则的话使用默认值。function fn(x=10)&#123; return x;&#125;console.log(fn());function fn(x=10,y)&#123; return x+y;&#125;console.log(fn(1,2)); 3 3.函数形参可以和数组解构赋值连用function fn2([x,y])&#123; return x+y;&#125;var arr = [10,20];console.log(fn2(arr));4.函数参数 剩余参数...rest ...参数名 相当于argumentsrest 是形参名...rest 保存函数的剩余参数rest是数组...rest 取代arguments 1)function fn3(x,...rest)&#123; console.log(x,rest); &#125; fn3(1,2,3,5); 1 [2,3,5] 2)function fn3(...rest)&#123; console.log(rest); &#125; fn3(1,2,3,5); [1,2,3,5] 3)不能这样写 剩余参数必须写在参数列表的末尾，不能写在首位 function fn4(...rest,x)&#123; &#125; fn4(1,2,3,4); 7.2 新特性=&gt;箭头函数7.2.1 箭头函数=&gt;形参123456789101112131415161718192021222324252627var 函数名 = 形参 =&gt; &#123;函数体&#125;var fn1 = (x) =&gt; &#123; return x;&#125;console.log(fn1(10));1.箭头函数=&gt;形参的不同情况1)没有形参 ()不能省略 var fn = () =&gt; &#123; console.log(10); &#125; fn();2)一个形参,括号可以省略 写法一： var fn = (x) =&gt; &#123; console.log(x); &#125; fn(10); 写法二：一个形参，括号可以省略 var fn = x =&gt; &#123; console.log(x); &#125; fn(10);3)多个形参 ()号不能省略var fn3 = (x,y) =&gt; &#123; console.log(x+y);&#125;fn3(10,20); 7.3.2 箭头函数=&gt;函数体12345678910111.只有一句函数体,&#123;&#125;可以省略,默认返回，相当于前面有returnvar fn = (x) =&gt; x;=&gt; 等价于 var fn = (x) =&gt; &#123;return x;&#125;;console.log(fn(10));2.函数体有多行,&#123;&#125;不能省略var fn = (x) =&gt; &#123; x++; return x;&#125;var result = fn(10);console.log(result); 7.3.3 箭头函数=&gt;this问题1234567891011121314151617181920212223242526272829303132333435361.对象中的thisvar per = &#123; name: &apos;哈哈哈&apos;, sayHi: function()&#123; setTimeout(function()&#123; console.log(this.name); //undefined &#125;,1000); &#125; 改为箭头函数 sayHi: () =&gt; &#123; setTimeout(function()&#123; console.log(this.name); //undefined &#125;,1000); &#125; 改为箭头函数,箭头函数中没有自己的this sayHi: () =&gt; &#123; console.log(this); &#123;&#125; 空对象 setTimeout(() =&gt; &#123; console.log(this); &#123;&#125;空对象 ？？？？？？？？？？？？？？？？？？ console.log(this.name); //undefined &#125;,1000); &#125;&#125;2.箭头函数var per = &#123; name: &apos;哈哈哈&apos;, // 改为箭头函数,箭头函数中没有自己的this sayHi: function() &#123; 此时this是per对象 上级作用域:当前对象 setTimeout(() =&gt; &#123; console.log(this.name); //哈哈哈 &#125;,1000); &#125;&#125;per.sayHi(); 123456注意： 1.箭头函数中没有自己的this 2.会逐层向上一级作用域找this 3.箭头函数不可以用于构造函数，因为没有this 4.箭头函数通常用于匿名函数，在写匿名函数时，最好变成箭头函数，好处是：不需要关心this的指向变来变去，会自动找this的产生效应的位置。 定时器 8. 导出模块成员的几种写法12345678910写法1: 导出多个成员b.jsvar num = 100;var add = function()&#123;&#125;module.exports.num = num;module.exports.add = add;a.jsvar model = require(&apos;./b.js&apos;);console.log(model); 123456789写法2：导出多个成员exports相当于module.exports别名var num = 100;var add = function()&#123;&#125;console.log(exports); //&#123;&#125;exports.num = num;exports.add = add;console.log(exports); &#123;num:100,add:fun&#125;console.log(module.exports === exports); true 12345678910写法3:导出一个成员var num = 100;var add = function()&#123;&#125;module.exports = &#123; num: num, add: add&#125;;module.exports = 100;如果只导出一个成员，不能使用exports,使用的是module.exports。如果使用exports导出一个成员，在另一个页面导入后，为&#123;&#125;空对象。 12345678910111213每个模块末尾默认导出的是module.exports；return module.exports;如果只导出一个成员，不能使用exports。解释： 原来 module.exports = &#123;&#125;; module.exports = exports; exports = &#123;&#125;; 如果只导出一个成员,那么 exports = &#123; name:&apos;&apos;, fn:function()&#123;&#125; &#125;; 相当于给exports重新赋值,改变this的指向 123451.导出多个成员时 module.exports.成员= 值2.导出多个成员时 exports.成员= 值3.导出一个成员时 module.exports = 成员每个模块最终导出的是module.exports，而不是exports当导出一个成员时,使用exports不可以。 9. express9.1 express介绍及安装123456789express是基于node.js平台开发出来的一个框架。可以搭建服务器express官方文档： expressjs.com中文网: www.expressjs.com.cn安装express npm i express package.json：文件中会多一个express配置项使用express需要先导入 var obj = require(&apos;express&apos;); 9.2 体验express代码1234567891011121314151617181920使用express提供的API快速搭建服务器1.使用node2.使用express 1)导包 const express = require(&apos;express&apos;); express是一个对象，同时自带一个方法，express中的所有方法，都需要express方法的返回值去调用。 2）实例化app const app = express(); 3)配置路由 监听客户端请求 请求方式是get 请求标识是/ 服务端要做处理 app.get(请求标识，callback(req,res)); app.get(&apos;/&apos;,function(req,res)&#123; res.write(&quot;asfsdaf----&quot;); res.end(); &#125;); 4)监听端口 app.listen(端口,函数); app.listen(12345，function()&#123; console.log(&quot;run it=----&quot;); &#125;); 9.3 express路由123456789101112131415161718路由配置|路由分发：根据客户端不同的请求（请求方式、请求标识），服务端去做不同的处理app.get(&apos;/&apos;,(req,res)=&gt;&#123; res.write(&apos;dfd&apos;); res.end();&#125;);app.get(&apos;/login&apos;,(req,res)=&gt;&#123; res.write(&apos;sdafsaf&apos;); res.end();&#125;);app.post(&apos;login&apos;,(req,res)=&gt;&#123; res.write(&apos;ssdafafsaf&apos;); res.end();&#125;);注意：res.write(&apos;ssdafafsaf&apos;);res.end();这两个方法可以简化为res.send(&apos;sfad&apos;); 9.4 返回字符串到页面1234567891011121)导包const express = require(&apos;express&apos;);2）实例化const app = express();3）配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.send(&apos;&lt;p&gt;我是p标签&lt;/p&gt;&apos;);&#125;);4）监听端口app.listen(12345,()=&gt;&#123; console.log(&apos;run it as localhost&apos;);&#125;); 1234567891011121314151617181920const fs = require(&apos;fs&apos;);const express = require(&apos;express);const app = express();app.get(&apos;/&apos;,(req,res) =&gt; &#123; 读取页面文件 编码格式 fs.readFile(&apos;./login.html&apos;,(err,data) =&gt; &#123; 把十六进制转化为字符串 data = data.toString(); res.send(data); &#125;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localost&apos;);&#125;);如果不使用toString()方法，则需要在参数中添加一个utf8格式fs.readFile(&apos;./login.html&apos;, &quot;utf8&quot;, (err,data) =&gt; &#123; res.send(data);&#125;） 10. 留言板案例10.1 案例说明和准备1234567目的： 练习express中的常用API 熟悉ES6中的新特性: const 箭头函数()=&gt;&#123;&#125; 使用常用的第三方包,如mysql express-art-template介绍： 留言板列表页 新增页面 10.2 搭建服务器123456789101112131415161718191.创建一个空文件夹 先初始化文件: npm init -y 安装express包: npm i express2.新建一个js文件app.js// 搭建服务器// 导包const express = require(&apos;express&apos;);const app = express();// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; // res.write(&apos;sfafsaklf&apos;); // res.end(); res.send(&apos;/////&apos;);&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 10.3 服务端渲染列表页123456789101112131415161718app.js// 搭建服务器// 导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const app = express();// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; // res.write(&apos;sfafsaklf&apos;); // res.end(); fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; res.send(data); &#125;);&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 12345678910111213141516171819202122232425262728293031323334353637383940index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;留言板列表&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; a &#123; display: block; margin: 20px; &#125; ul &#123; margin-left: 20px; list-style: none; &#125; li &#123; height: 30px; line-height: 30px; &#125; .name &#123; padding: 0 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板案例&lt;/h1&gt; &lt;a href=&quot;/publish&quot;&gt;发布留言&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 10.4 模板引擎渲染页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601.使用假数据操作数据库=&gt;获取数据 const list = &#123; items: [&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;] &#125;2.下载模板引擎 官方文档: http://aui.github.io/art-template/zh-cn/docs/syntax.html npm install art-template 下载包之后,在package.json文件中配置项中会增加art-template 1)导包 const template = require(&apos;art-template&apos;); 2)使用方法 在渲染页面的同时把数据添加进去 template.render(source,data,options); source:页面字符串 data:该页面要使用的数据 要求类型是：&#123;&#125;对象 options:可选项 返回值: 携带了数据的页面字符串 3）配置路由 app.get(&apos;/&apos;,(req,res) =&gt; &#123; // res.write(&apos;sfafsaklf&apos;); // res.end(); fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; 模板引擎 var strHtmlWithData = template.render(data,&#123; items: list.items &#125;); res.send(strHtmlWithData); &#125;); &#125;); 4）渲染页面 &lt;ul&gt; &#123;&#123;each items&#125;&#125; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;&#123;&#123;$value.name&#125;&#125;&lt;/span&gt;&lt;span&gt;&#123;&#123;$value.content&#125;&#125;&lt;/span&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; 10.5 编辑页面搭建1234567891011121314151617181920212223242526272829303132333435363738394041publish.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;编辑页面&lt;/title&gt; &lt;style&gt; label &#123; display: inline-block; width: 80px; text-align: right; &#125; .box &#123; margin-top: 10px; &#125; #btn &#123; margin-left: 85px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;添加留言&lt;/h1&gt; &lt;form action=&quot;/publish&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;label for=&quot;&quot;&gt;名字:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&apos;名字&apos;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;label for=&quot;&quot;&gt;邮箱:&lt;/label&gt; &lt;input type=&quot;url&quot; name=&quot;email&quot; value=&apos;邮箱&apos;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;label for=&quot;&quot;&gt;评论内容:&lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&apos;btn&apos;&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 10.6 服务端渲染编辑页面123456781.列表页 &lt;a href=&apos;/publish&apos;&gt;&lt;/a&gt;2.http.js文件中 配置路由 app.get(&apos;/publish&apos;,(req,res) =&gt; &#123; fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; res.send(data); &#125;); &#125;); 10.7 第三方包-express-art-template123456789101112131415161718192021222324使用第三方包简化配置路由的代码: express-art-template1.安装包: npm i express-art-template 使用express-art-template包时,需要下载包art-template，依赖此包 npm install --save art-template npm install --save express-art-template2.配置express-art-template包并且导入包 当渲染后缀是html的文件时 使用express-art-template进行渲染 结果是res对象增加一个方法render() res.render();原来没有这个方法，是配置并引入express-art-template包之后增加的方法 app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));3.配置路由简化代码app.get(&apos;/&apos;, function (req, res) &#123; res.render(参数1，参数2); 参数1：要渲染的文件的名字 自动的去文件夹名为views的下面去找文件后缀为html的文件， 文件夹名必须为views,不能任意命名 参数2：类型为对象 该文件要用的数据 res.render(&apos;index.html&apos;, &#123; items: list.items &#125;);&#125;);4. res.render()方法内部做的事 1)fs读文件 2)使用模板引擎处理数据 3)发送页面字符串并且结束响应 12345678910111213141516171819202122232425262728293031323334353637383940414243简化后的代码// 搭建服务器// 导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const template = require(&apos;art-template&apos;);const app = express();// 第一步：配置并导入包// 结果是为res对象添加了一个方法 render();app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));const list = &#123; items: [&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;,&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;]&#125;;// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.render(&apos;index.html&apos;,&#123; items: list.items &#125;); // fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // var strHtmlWithData = template.render(data,&#123; // items: list.items // &#125;); // res.send(strHtmlWithData); // &#125;);&#125;);app.get(&apos;/publish&apos;,(req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); // fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // res.send(data); // &#125;);&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 10.8 获取表单post请求的表单数据req1234567891011121314151617增加第三方包给req请求对象增加一个body属性来获取表单数据// post请求的数据 隐藏在请求的请求体中// 通过第三方包body-parser 给req增加属性 body -&gt; 请求体数据// req.body就是post请求中的表单数据 &#123;&#125;1.安装包 npm i body-parser2.导包 var bodyParser = require(&apos;body-parser&apos;);3.配置body-parser app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); app.use(bodyParser.json());4.获取表单数据 app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; req.body就是post请求中的表单数据 console.log(req.body); //&#123; name: &apos;dg&apos;, email: &apos;saf&apos;, content: &apos;safdafafs&apos; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445表单&lt;form action=&quot;/publish&quot; method=&apos;post&apos;&gt;&lt;/form&gt;// 搭建服务器// 导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const template = require(&apos;art-template&apos;);// 给req增加一个body属性来获取表单中的数据const bodyParser = require(&apos;body-parser&apos;);const app = express();// 配置body-parserapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 第一步：配置并导入包// 结果是为res对象添加了一个方法 render();app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));const list = &#123; items: [&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;,&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;]&#125;;// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.render(&apos;index.html&apos;,&#123; items: list.items &#125;);&#125;);app.get(&apos;/publish&apos;,(req,res) =&gt; &#123; res.render(&apos;publish.html&apos;);&#125;);app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; console.log(req.body); //获取表单请求体中的数据&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 10.9 编辑页—更新数据12345678获取表单数据 =&gt; post请求 =&gt; 请求体里 =&gt; body-parser =&gt; req.body =&gt; &#123;&#125;获取到表单数据 =&gt; 将数据添加到items对象中app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; // console.log(req.body); const body = req.body; list.items.unshift(body); console.log(list);&#125;); 10.10 编辑页—重定向到列表页12345在list数组数据变化之后，回到列表页将/publish的标识改为/由于服务端没有BOM和DOM,所以不能使用window.location.href = &apos;/&apos;;使用服务端重定向的方法,将/publish的标识改为/,跳转到列表页res.redirect(&quot;/&quot;); 根据/表示发送的请求，重新渲染页面 1234567app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; // console.log(req.body); const body = req.body; list.items.unshift(body); 页面重定向 res.redirect(&quot;/&quot;);&#125;); 11. 数据持久化-本地文件11.1 数据持久化-本地文件-列表数据1234567每次重新启动服务器，之前添加的数据都没有了数据持久化1.本地文件保存数据2.操作数据库步骤: 1.把数据保存在data.json文件中 2.读取文件中的数据,把字符串转化为json对象 12345678910111213141516171819202122232425262728293031data.jsonjson文件中，key和value都必须使用双引号包裹&#123; &quot;items&quot;: [ &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125; ]&#125; 123456789101112http.jsapp.get(&apos;/&apos;,(req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;);&#125;); 11.2 数据持久化-本地文件-编辑数据123456789101112131415161718192021如果要写入数据，先把文件中的数据拿出来app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; 通过第三方包获取表单数据 body-parser 0.获取表单数据 const body = req.body; 1.读文件 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; 2.把读取文件中的字符串转化为json对象 data = JSON.parse(data); 3.把获取的表单的数据添加到json对象中 data.items.unshift(body); 5.将json对象转化为json字符串 data = JSON.stringify(data); 4.写入文件 参数: 文件名字 要写入的数据（类型是字符串） 回调函数 fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; 6.页面重定向 res.redirect(&apos;/&apos;); &#125;); &#125;);&#125;); 11.3 请求样式文件的处理123456789101112131415161718192021引入css文件&lt;link rel=&quot;stylesheet&quot; href=&quot;../css/common.css&quot;&gt;1.由于引入文件common.css文件,页面请求的是http://localhost:12345/css/common.css,而服务器并没有对标识为/css/common.css的文件做对应的处理，所以不能访问，客户端请求失败2.在路由配置中，配置对/css/common.css文件的发送请求的处理// 读取样式文件app.get(&apos;/css/common.css&apos;,(req,res) =&gt; &#123; // 当客户端请求这个文件时,服务器读取文件中的内容，将内容响应给客户端 2.1 读取样式文件 fs.readFile(&apos;./css/common.css&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // console.log(data); // 将获取到的内容发送给客户端，由于默认的返回客户端的响应类型为 text/html,所以没有效果 // 将响应类型设置为text/css 2.2 修改返回给客户端的内容的响应类型 res.setHeader(&apos;Content-Type&apos;,&apos;text/css&apos;); // 返回相应 2.2 返回给客户端 res.send(data); &#125;);&#125;);以上方法，可以处理css样式文件，但是对于处理多个样式文件，这样写起来比较麻烦 11.4 统一处理静态资源(样式文件)12345678910静态资源 样式文件、图片、字体1.使用express的方法来处理 const app = express();2.统一处理所有静态资源文件 static(静态资源文件路径); app.use(express.static(&quot;./css&quot;)); 公开暴露css文件夹的所有静态资源3.在引入静态资源文件时，直接写文件名即可 &lt;link rel=&quot;stylesheet&quot; href=&quot;/common.css&quot;&gt;4.使用此方法，不需要在路由配置中，对静态文件分别处理 11.5 统一处理第三方资源123456789第一种:app.use(只写一个参数);1.安装第三方文件资源 npm i bootstrap2.公开暴露node_modules文件夹下的资源文件 app.use(express.static(&apos;./node_modules&apos;));3.引入样式文件时 &lt;!-- 引入第三方资源文件,直接引入node_modules文件夹下的资源文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/bootstrap/dist/css/bootstrap.css&quot;&gt; 1234567第二种:限定请求的前缀2.公开暴露node_modules文件夹下的资源文件当请求标识是以/abc开始的,暴露node_modules文件夹下的资源文件app.use(&apos;/abc&apos;,express.static(&apos;./node_modules&apos;));3.引入样式文件时 &lt;!-- 引入第三方资源文件,资源文件的标识是/abc --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/abc/bootstrap/dist/css/bootstrap.css&quot;&gt; 123公开根目录下的所有资源文件app.use(express.static(&apos;./&apos;));但是不要这么些，不安全 11.6 统一处理静态资源-小结123456789101112配置包//处理资源 // 1. 自己静态资源app.use(express.static(&quot;./public&quot;))// app.use(&quot;/abc&quot;, express.static(&quot;./public&quot;))// app.use(&quot;/public&quot;, express.static(&quot;./public&quot;))// 2. 第三方资源// app.use(express.static(&quot;./node_modules&quot;))app.use(&quot;/node_modules&quot;, express.static(&quot;./node_modules&quot;))// 3. 统一配置// app.use(express.static(&quot;./&quot;)); 12345678对应的客户端代码1.自己静态资源&lt;link rel=&quot;stylesheet&quot; href=&quot;/base.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/abc/main.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/main.css&quot;&gt; 2.第三方资源&lt;link rel=&quot;stylesheet&quot; href=&quot;/bootstrap/dist/css/bootstrap.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&gt; 11.7 提取路由模块123456789101112131415161718192021222324252627282930313233343536373839http.js 是一个程序入口文件入口文件作用：监听端口 启动服务1.将文件中配置路由的代码提取出来封装成一个模块模块是具有独立功能的js文件2.提取路由模块 router.js 配置路由 1) 导包 const fs = require(&apos;fs&apos;); const express = require(&apos;express&apos;); 2) 实例化路由router const router = express.Router(); 3) 配置路由 router.get(&apos;/&apos;,(req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;); &#125;); router.get(&apos;/publish&apos;,(req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); &#125;); router.post(&apos;/publish&apos;,(req,res) =&gt; &#123; // console.log(req.body); const body = req.body; fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; data = JSON.parse(data); data.items.unshift(body); data = JSON.stringify(data); fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; res.redirect(&apos;/&apos;); &#125;); &#125;); &#125;); 4) 导出router对象 module.exports = router; 1234567在程序入口文件中导入1.导包const router = require(&apos;./router&apos;);2.配置3.使用路由app.use(router);4.监听端口 注意 12345fs的导入包的位置要修改app.use(router);代码位置放在配置包的后面 (先配置包,再使用包)入口程序模块: 监听端口启动服务配置路由模块：具有独立功能的js文件路由模块文件：监听请求 并且找到对应的处理函数 11.8 提取处理函数模块1把路由router.js模块中处理函数的具体实现的代码提取出来放在一个单独的模块中 router01.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950导出方法，封装在函数中// 1.导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const router = express.Router();// 2.配置路由模块// 封装函数处理的具体代码// 渲染列表页const showList = (req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;); // fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // var strHtmlWithData = template.render(data,&#123; // items: list.items // &#125;); // res.send(strHtmlWithData); // &#125;);&#125;;// 编辑页const edit = (req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); // fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // res.send(data); // &#125;);&#125;;// 从编辑页跳转到列表页const editList = (req,res) =&gt; &#123; // console.log(req.body); const body = req.body; fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; data = JSON.parse(data); data.items.unshift(body); data = JSON.stringify(data); fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; res.redirect(&apos;/&apos;); &#125;); &#125;);&#125;;router.get(&apos;/&apos;,showList);router.get(&apos;/publish&apos;,edit);router.post(&apos;/publish&apos;,editList);// 3.导出模块成员module.exports = router; router02.js 12345678910111213导出方法，将封装的函数放在另一个模块中,并在此模块中引入// 1.导包const fun = require(&apos;./fun&apos;);const express = require(&apos;express&apos;);const router = express.Router();// 2.配置路由模块// 封装函数处理的具体代码// 渲染列表页router.get(&apos;/&apos;,fun.showList);router.get(&apos;/publish&apos;,fun.edit);router.post(&apos;/publish&apos;,fun.editList);// 3.导出模块成员module.exports = router; fun02.js 12345678910111213141516171819202122232425262728293031323334353637383940// 1.导包const fs = require(&apos;fs&apos;);// 2.导出模块成员module.exports.showList = (req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;); // fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // var strHtmlWithData = template.render(data,&#123; // items: list.items // &#125;); // res.send(strHtmlWithData); // &#125;);&#125;;// 编辑页module.exports.edit = (req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); // fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // res.send(data); // &#125;);&#125;;// 从编辑页跳转到列表页module.exports.editList = (req,res) =&gt; &#123; // console.log(req.body); const body = req.body; fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; data = JSON.parse(data); data.items.unshift(body); data = JSON.stringify(data); fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; res.redirect(&apos;/&apos;); &#125;); &#125;);&#125;; 12. 数据持久化-mysql操作数据库12.1 数据持久化-mysql包体验-配置123456789101112131415161718192021222324252627282930在node中操作数据库实现数据持久化使用第三方包 mysql:在node环境下操作mysql数据库文档参考:https://www.npmjs.com/package/mysql1.安装mysql包 npm install mysql2.配置mysql文档 // 1.导包 var mysql = require(&apos;mysql&apos;); // 2.配置mysql var connection = mysql.createConnection(&#123; //主机 host : &apos;localhost&apos;, //用户名 user : &apos;root&apos;, //密码 password : &apos;root&apos;, //数据库名 database : &apos;message&apos; &#125;); // 3.开启链接 connection.connect(); // 4.执行sql语句 connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123; if (error) throw error; console.log(&apos;The solution is: &apos;, results[0].solution); &#125;); fields:可选参数 // 5.关闭数据库连接 connection.end(); 3.必须开启mysql服务 12.2 mysql-查询12345678910111213141516171819202122sql语句: var str = &quot;select * from `posts`&quot;;如果添加了反引号,就算字符串之间紧挨着也能识别是表名。// 4.执行sql语句// 1.返回结果 results是数组，数组里面是对象 每个对象是一条数据// var sqlStr = &quot;select * from `posts`&quot;;// 2.返回结果results 是数组 数组里面是满足条件的数据 对象// var sqlStr = &quot;select * from `posts` where id=1&quot;;// 3.sql语句中的？是一个占位符 ，相当于是形参，在query方法中的第二个参数是？号处的值 ？号是mysql包给我们提供的// const ID = 1;// var sqlStr = &quot;select * from `posts` where id=?&quot;;// connection.query(sqlStr,ID, function (error, results) &#123;// if (error) throw error;// console.log(results);// &#125;);// 4.sql语句中查询的是多个条件 query函数中，第二个参数传入的是数组var name=&apos;abc&apos;;var content = &apos;ss&apos;;var sqlStr = &quot;select * from `posts` where name = ? and content = ?&quot;;connection.query(sqlStr,[name,content], function (error, results) &#123; if (error) throw error; console.log(results);&#125;); 12.3 mysql-插入、增加1234567891011121314mysql中，除了查询返回的是数组，其他都是对象。对象中的key是字段名，不可以乱写添加使用关键字 setresults:返回的是对象const item = &#123; name:&apos;chengsong&apos;, content:&apos;tama&apos;, mail:&apos;ccc@ccc.com&apos;, date: &apos;2014-11-11&apos;&#125;const sqlStr = &apos;insert into `posts` set ?&apos;;connection.query(sqlStr,item,(err,results) =&gt; &#123; consoel.log(results);&#125;); 结果 12345678910OkPacket &#123; fieldCount: 0, affectedRows: 1, insertId: 259, serverStatus: 2, warningCount: 0, message: &apos;&apos;, protocol41: true, changedRows: 0 &#125; 12.4 mysql-修改和删除12345678修改: 修改id为1的数据 把name改为xxx const ID = 1; const name = &apos;xxx&apos;; const sqlStr = &apos;update `posts` set name = ? where id = ?&apos;; connection.query(sqlStr,[name,ID],(error,results) =&gt; &#123; console.log(results); &#125;); 1234567删除: 删除数据id=257的数据 const id = 257; const sqlStr = &apos;delete from `posts` where id = ?&apos;; connection.query(sqlStr,[id],(error,results)=&gt;&#123; console.log(results); &#125;); 123总结： 查询返回的是数组 增删改返回的是对象 13. 全局命令行工具的使用-nodemon1234安装全局的包，每次修改代码后不需要重启服务器，会自动重启。安装全局的包: nodemon npm i nodemon -g使用 nodemon 文件名 的方式自动重启服务器 13.1 全局命令行工具12345678910111213npm git:在任意路径下都可以使用/全局安装/指令操作1.nodemon:自动重新执行文件 全局安装 npm i nodemon -g 运行: nodemon 文件名2.http-server:快速开启本地服务器 把一个文件夹变成服务器的根目录,同时启动该服务 安装: npm i http-server -g 指令: http-server 启动服务器 http-server -o 启动服务器的同时打开浏览器 http-server -o -p 8081 启动服务器的同时打开浏览器并修改端口3.查看全局命令行工具安装的位置 npm root -g 13.2 自定义指令123456789自定义指令：把很长的指令简化为一个简单的指令npm提供的功能1.在package.json文件中: 修改script键中的值： &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node app.js&quot; &#125;2.在npm中运行 npm run build相当于是运行node app.js 14. 留言板数据持久化-mysql14.1 mysql-列表数据fun.js 123456789101112131415161718192021222324252627282930// 1.导包const mysql = require(&apos;mysql&apos;);// 2.配置mysqlconst connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;message&apos;&#125;);// 3.开启链接connection.connect();// 2.导出模块成员module.exports.showList = (req,res) =&gt; &#123; // 从数据库中读取文件 // 4.执行sql语句 const sqlStr = &apos;select * from `posts` order by id desc&apos;; connection.query(sqlStr,(error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); // 将数据通过模板引擎渲染到页面上 res.render(&apos;index.html&apos;,&#123; items: results &#125;); &#125;);&#125;;最后不能关闭数据库 14.2 mysql-编辑数据12345678910111213141516171819202122232425262728293031// 从编辑页跳转到列表页module.exports.editList = (req,res) =&gt; &#123; // console.log(req.body); const body = req.body; body.date = new Date(); //body对象的key必须和数据库字段一样 // mysql增加mysql语句 const sqlStr = &apos;insert into `posts` set ?&apos;; connection.query(sqlStr,body,(error,results) =&gt; &#123; if(error) &#123; throw error; &#125; // console.log(results); res.redirect(&apos;/&apos;); &#125;); // fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; // data = JSON.parse(data); // data.items.unshift(body); // data = JSON.stringify(data); // fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; // res.redirect(&apos;/&apos;); // &#125;); // &#125;);&#125;;最后不能关闭数据库 14.3 mysql使用注意123数据库操作是异步操作：后面的代码不等待前面的代码执行完就继续执行 最后不能关闭数据库常见异步操作: ajax 事件 定时器 数据库操作 15. 文件分析12345app.js 程序入口函数router.js 路由配置(监听请求)handle.js 实现处理函数views/ 视图 html文件public/ 静态资源文件 16. 回调函数16.1 回调函数-基本使用123456789101112131415需求场景:想在函数外部 获取到函数内部异步操作里面的结果解决方法:在异步操作有结果的位置，调用函数，把结果以实参方式进行传递function add(x,y，fn)&#123; console.log(1); setTimeout(function()&#123; var temp = x+y; fn(temp); &#125;,1000); console.log(2);&#125;add(5,7,function(x)&#123; console.log(x);&#125;);结果为: 1 2 12 16.2 回调函数-应用-封装ajax1234567891011function get(url,callback)&#123; var xhr = new XMLHttpRequest(); xhr.onload = function()&#123; callback(responseText); &#125; hr.open(&apos;get&apos;,url); xhr.send();&#125;get(&apos;index.js&apos;,function(data)&#123; console.log(data);&#125;); 扩展思路12345678910先用express搭建服务器： 下载-&gt;导包-&gt;实例化-&gt;配置路由(根据不同请求标识,服务端做不同处理)-&gt;监听端口 渲染列表页：文件模块读取文件，并将返回的结果渲染渲染到页面 模板引擎渲染列表数据 编辑页面搭建 在app.js文件中 根据不同的标识 服务端做不同处理 下载express-art-template包，可以解决： 文件读取、模板引擎渲染、结束服务器响应等问题 编辑页面post请求,安装包body-parser为req增加body属性，获取请求的数据统一处理所有的静态资源： app.use(express.static(&quot;./css&quot;)); 统一暴露css文件夹下所有的静态资源文件 闭包1避免全局变量被污染 改变this的指向的方法1234567891011121314151)通过变量，将this的值指向该变量2）通过bind(),apply(),call()来改变this的指向 var per = &#123; name: &apos;sfdsa&apos;, sayHai: function()&#123; console.log(this.name); &#125; &#125;; per.sayHai.call(null); per.sayHai.call(obj); 将this的指向改变为obj per.sayHai.call(obj,num1,num2); 将this的指向改变为obj per.sayHai.apply(obj,[num1,num2]); setTimeout(function()&#123; console.log(this.name); &#125;.bind(this),1000); 箭头函数this的指向 问题1234567891011var per = &#123; name: &apos;哈哈哈&apos;, sayHi: () =&gt; &#123; console.log(this); &#123;&#125; setTimeout(() =&gt; &#123; console.log(this); &#123;&#125; console.log(this.name); //undefined &#125;,1000); &#125;&#125;per.sayHi(); npm上下载包名12https://www.npmjs.com搜索包名=&gt;下载 文档链接12345678910npm https://www.npmjs.comexpress中文文档 http://www.expressjs.com.cn/en/guide/routing.htmlexpress英文文档 http://expressjs.com/en/guide/routing.htmlnodejs.cn node中文网https://nodejs.org/en 英文网node社区: https://cnodejs.orgnpm网站找包（模块） https://www.npmjs.com/ npmjs官网express官方文档： expressjs.com中文网: www.expressjs.com.cnnpm模板引擎官方文档: http://aui.github.io/art-template/zh-cn/docs/syntax.html 定时器异步加载123456789101112131415161718192021222324251.function add(x,y)&#123; console.log(1); setTimeout(function()&#123; console.log(3); return x+y; &#125;,1000); console.log(2);&#125;var result = add(1,3);console.log(result);12undefined3由于定时器异步加载,定时器还没执行完代码已经执行完毕了,所以result的结果为undefined。2.function add(x,y)&#123; var temp; setTimeout(function()&#123; temp = x+y; &#125;,1000); return temp;&#125;var result = add(1,3);console.log(result);结果为undefined,原因是定时器异步加载]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动web]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2F%E7%A7%BB%E5%8A%A8web%2F</url>
    <content type="text"><![CDATA[移动web1. 视口123456789101112131415161718192021viewport: meta:vp&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;width:设置宽度等于设备宽度user-scalable:设置是否允许用户自行缩放 yes or noinitial-scale:设置缩放比例maximum-scale:设置最大缩放比例minimum-scale:设置最小缩放比例获取屏幕的设备大小 var screenWidth = window.screen.width; var screenHeight = window.screen.height; 像素问题： pc设备下 1pt/dp(独立像素) = 1px(物理像素) iPhone5/6/7/8 1pt/dp(独立像素) = 2px(物理像素) iPhone6/7/8plus/x 1pt/dp(独立像素) = 3px(物理像素) 如果你是一个 android 程序员 在编写代码使用 dp 如果你是一个 ios 程序员 在编写代码使用 pt 如果你是一个 前程 序员 在编写代码使用 px(css长度单位) 1px(css) = 1px(物理) 1px(css) = 2px(物理) 1px(css) = 3px(物理) 2. 京东页面公共样式123456789101112131415161718192021222324252627282930313233343536373839404142434445*,::before,::after&#123; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent;/*去除移动端特有的点击高亮效果，清除点击默认的高亮效果*/ -webkit-box-sizing: border-box;/*以你的border开始计算你的宽度*/&#125;body&#123; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;,sans-serif;/*第二个是手机的一个默认的字体*/ color: #000;&#125;a&#123; text-decoration: none; color: #000;&#125;ul&#123; list-style: none;&#125;input,textarea&#123; border: none; resize: none; outline: none;/*清除选中效果*/ -webkit-appearance: none;/*清楚浏览器默认的样式*/&#125;img &#123; 解决图片底部3像素问题 vertical-align:middle; // display:block;&#125;/*清除浮动*/.clearfix::before,.clearfix::after&#123; content: &quot;.&quot;; display: block; height: 0; line-height: 0; visibility: hidden; clear: both;&#125;[class^=&quot;icon_&quot;]&#123; background: url(&quot;../images/sprites.png&quot;) no-repeat; background-size: 200px 200px;&#125; 3. 固定导航栏布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801)使用伸缩布局2）使用margin：0 auto； logo和登录使用相对定位来布局3）padding: 0px 100px; 双飞翼布局&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .container &#123; width: 1140px; height: 10000px; margin: 0 auto; background: yellowgreen; max-width: 640px; min-width: 320px; &#125; .container .logo &#123; width: 100%; height: 50px; max-width: 640px; min-width: 320px; background: rgba(0, 0, 0, 0.5); position: fixed; &#125; .container .logo .logo-left &#123; width: 100px; height: 50px; position: absolute; top: 0; left: 0; background: green; &#125; .container .logo form &#123; width: 100%; height: 50px; padding: 0 100px; /* background: yellow; */ /* position: absolute; z-index: 99; */ &#125; /* .container .logo form input &#123; width: 300px; height: 60px; &#125; */ .container .logo .logo-right &#123; width: 100px; height: 50px; position: absolute; top: 0; right: 0; background: green; &#125; .bottom &#123; width: 100%; height: 800px; background: red; border: 1px solid #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;logo&quot;&gt; &lt;div class=&quot;logo-left&quot;&gt;sfskaf&lt;/div&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;&quot;&gt; &lt;/form&gt; &lt;div class=&quot;logo-right&quot;&gt;登录&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. 移动端二倍图设置123background:url(../image/sprite.png);background-size:200px 200px; 缩小二倍图background-position: 0 -120px; 5.京东首页搜索块js效果121)设置默认搜索栏的背景色为rgba(0,0,0,0.85);2)判断页面向上滚动的距离与轮播图高度的大小，如果大于，则设置搜索栏的透明度为固定值0.85，否则的话透明度随着高德的变化而变化 6. 京东倒计时效果121)使用定时器2)最后判断倒计时的值是不是小于0，如果小于0，则设置为00：00：00,清理定时器。 7. 京东轮播图7.1 使用js实现轮播图布局效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/*1.设置修改轮播图的页面结构* a.在开始位置添加原始的最后一张图片* b.在结束位置添加原始的第一张图片*//*1.1.获取轮播图结构*/ var banner=document.querySelector(&quot;.jd_banner&quot;);/*1.2.获取图片容器*/ var imgBox=banner.querySelector(&quot;ul:first-of-type&quot;);/*1.3.获取原始的第一张图片*/ var first=imgBox.querySelector(&quot;li:first-of-type&quot;);/*1.4.获取原始的最后一张图片*/ var last=imgBox.querySelector(&quot;li:last-of-type&quot;);/*1.5.在首尾插入两张图片 cloneNode:复制一个dom元素*/ imgBox.appendChild(first.cloneNode(true));/*insertBefore(需要插入的dom元素，位置)*/ imgBox.insertBefore(last.cloneNode(true),imgBox.firstChild);/*2.设置对应的样式*//*2.1获取所有li元素*/ var lis=imgBox.querySelectorAll(&quot;li&quot;);/*2.2 获取li元素的数量*/ var count=lis.length;/*2.3.获取banner的宽度*/ var bannerWidth=banner.offsetWidth;/*2.4 设置图片盒子的宽度*/ imgBox.style.width=count*bannerWidth+&quot;px&quot;;/*2.5 设置每一个li(图片)元素的宽度*/ for(var i=0;i&lt;lis.length;i++)&#123; lis[i].style.width=bannerWidth+&quot;px&quot;; &#125;/*3.设置默认的偏移*/ imgBox.style.left=-bannerWidth+&quot;px&quot;;/*定义图片索引:图片已经有一个宽度的默认偏移*/ var index=1;/*4.当屏幕变化的时候，重新计算宽度*/ window.onresize=function()&#123; /*4.1.获取banner的宽度,覆盖全局的宽度值*/ bannerWidth=banner.offsetWidth; /*4.2 设置图片盒子的宽度*/ imgBox.style.width=count*bannerWidth+&quot;px&quot;; /*4.3设置每一个li(图片)元素的宽度*/ for(var i=0;i&lt;lis.length;i++)&#123; lis[i].style.width=bannerWidth+&quot;px&quot;; &#125; /*4.4重新设置定位值*/ imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; var timerId; /*5.实现自动轮播*/ var startTime=function()&#123; timerId=setInterval(function()&#123; /*5.1 变换索引*/ index++; /*5.2.添加过渡效果*/ imgBox.style.transition=&quot;left 0.5s ease-in-out&quot;; /*5.3 设置偏移*/ imgBox.style.left=(-index*bannerWidth)+&quot;px&quot;; /*5.4 判断是否到最后一张，如果是则*/ setTimeout(function()&#123; if(index==count-1)&#123; console.log(index); index=1; /*如果一个元素的某个属性之前添加过过渡效果，那么过渡属性会一直存在，如果不想要，则需要清除过渡效果*/ /*关闭过渡效果*/ imgBox.style.transition=&quot;none&quot;; /*偏移到指定的位置*/ imgBox.style.left=(-index*bannerWidth)+&quot;px&quot;; &#125; &#125;,500); &#125;,2000); &#125; startTime(); /*6.实现手动轮播*/ var startX,moveX,distanceX; /*为图片添加触摸事件--触摸开始*/ imgBox.addEventListener(&quot;touchstart&quot;,function(e)&#123; /*清除定时器*/ clearInterval(timerId); /*获取当前手指的起始位置*/ startX= e.targetTouches[0].clientX; &#125;); /*为图片添加触摸事件--滑动过程*/ imgBox.addEventListener(&quot;touchmove&quot;,function(e)&#123; /*记录手指在滑动过程中的位置*/ moveX= e.targetTouches[0].clientX; /*计算坐标的差异*/ distanceX=moveX-startX; /*为了保证效果正常，将之前可能添加的过渡样式清除*/ imgBox.style.transition=&quot;none&quot;; /*实现元素的偏移 left参照最原始的坐标 * 重大细节：本次的滑动操作应该基于之前轮播图已经偏移的距离*/ imgBox.style.left=(-index*bannerWidth + distanceX)+&quot;px&quot;; &#125;); /*添加触摸结束事件*/ /*touchend:松开手指触发*/ imgBox.addEventListener(&quot;touchend&quot;,function(e)&#123; /*获取当前滑动的距离，判断距离是否超出指定的范围 100px*/ if(Math.abs(distanceX) &gt; 100)&#123; /*判断滑动的方向*/ if(distanceX &gt; 0)&#123;//上一张 index--; &#125; else&#123; //下一张 index++; &#125; /*翻页*/ imgBox.style.transition=&quot;left 0.5s ease-in-out&quot;; imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; else if(Math.abs(distanceX) &gt; 0)&#123; //得保证用户确实进行过滑动操作 /*回弹*/ imgBox.style.transition=&quot;left 0.5s ease-in-out&quot;; imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; //重新开启定时器 startTime(); &#125;); /*webkitTransitionEnd:可以监听当前元素的过渡效果执行完毕，当一个元素的过渡效果执行完毕的时候，会触发这个事件*/ imgBox.addEventListener(&quot;webkitTransitionEnd&quot;,function()&#123; /*如果到了最后一张(count-1)，回到索引1*/ /*如果到了第一张(0)，回到索引count-2*/ if(index==count-1)&#123; index=1; /*清除过渡*/ imgBox.style.transition=&quot;none&quot;; /*设置偏移*/ imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; else if(index==0)&#123; index=count-2; /*清除过渡*/ imgBox.style.transition=&quot;none&quot;; /*设置偏移*/ imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; &#125;); 8. 京东移动端项目1231)设置项目结构 css font js image index.html2)添加viewport,引入页面样式文件3）写布局 8.1 touch事件1234567891011121314151617181920212223242526272829301.移动端添加事件使用addEventListener来添加： touchstart:手指触摸屏幕时触发 touchmove:手指在屏幕上移动时触发 touchend:手指离开屏幕时触发 touchcancle:触摸意外中断事件 /*添加开始触摸事件：当手指触摸到屏幕时触发*/ div.addEventListener(&quot;touchstart&quot;,function()&#123; console.log(&quot;touchstart&quot;); &#125;); /*添加手指滑动事件，当手指在屏幕上滑动时触发:move事件是持续触发*/ div.addEventListener(&quot;touchmove&quot;,function()&#123; console.log(&quot;touchmove&quot;); &#125;); /*添加触摸结束事件：当手指离开屏幕时触发*/ div.addEventListener(&quot;touchend&quot;,function()&#123; console.log(&quot;touchend&quot;); &#125;); /*添加触摸意外中断事件*/ div.addEventListener(&quot;touchcancel&quot;,function()&#123; &#125;);2.事件源参数对象： touches:当前屏幕上所有的触摸对象 targetTouches:当前元素上的触摸对象 changedTouches:当前屏幕上变换的触摸对象3.触摸对象的坐标值： clientX|clientY:可视区域(相对于当前视口)的横纵坐标 pageX|pageY：相对于文档的坐标 screenX|screenY:相对于屏幕的坐标 e.targetTouches[0].clientX; 9. 媒体查询123456789101112131415161718192021222324252627282930313233343536373839404142434445461.媒体类型 all:用于所有设备 print:用于打印机和打印预览 screen:用于电脑屏幕，平板电脑，智能手机等2.媒体特性 width height max-width min-width max-height min-heightd等等3.关键字 关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件 and:可以将多个媒体特性连接到一起，相当于&quot;且&quot;的意思 not:排除某个媒体类型，相当于&quot;非&quot;,可以省略 only:指定某个特定的媒体类型，可以省略 @meida only screen and (max-width:640px)&#123; .container &#123; width:1170px; &#125; &#125;4.引入方式 1)第一种方式： 使用link方式引入媒体查询 &lt;link rel=&apos;stylesheet&apos; media=&apos;only screen and (max-width:768px)&apos; href=&apos;./blue.css&apos;&gt; 2)第二种方式：css中使用@media min:判断条件一定是从小到大的，css代码从上到下执行 max:判断条件是从大到小 1)第一种 only可省 @media only screen and (min-width:1200px)&#123; .container &#123; width:1170px; &#125; &#125; 2）第二种 @media (mix-width:768px;)&#123; .container &#123; width:750px; &#125;5.媒体特性 width:指的是视口的宽度 @media only screen and (width:375px) &#123; body &#123; background-color:pink; &#125; &#125; width/height:完全等于视口的宽度|高度 max-width|max-height:小于等于视口 min-width|min-height:大于等于视口 device-width|device-height:完全等于屏幕 orientation:portrait|landscape 肖像(竖屏)|全景模式 10. css预处理器介绍12 微金所12 bootstrap1234567891011121314151617181920212223242526272829303132333435类名： .container: .container-fluid:响应式布局 .row : .col-lg-6:占几列 lg: 大屏 md:中屏 sm:小屏 xs:超小屏 导航栏： navbar-nav navbar-default:默认 navbar-right ：导航条右浮动 navbar-inverse:反色 样式工具： hidden-lg:在哪个屏隐藏 visible-lg:在哪个屏显示2）样式覆盖 360浏览器12345678910111213141516171819202122232425262728291.fullpage插件的使用 引入jquery.js文件 引入fullpage.js文件 使用样式： $(&apos;.fullpage&apos;).fullpage(&#123; 配置每一屏的选择器： 默认是.section sectionSelector: &apos;.page&apos;, 设置每屏的颜色 sectionsColor: [&apos;&apos;,&apos;&apos;,&apos;&apos;], 当每一屏滚动完成会执行 参数Index是从1开始的 afterLoad:function(item,index)&#123; $(&apos;.section&apos;).removeClass(&apos;current&apos;); $(&apos;.section&apos;).eq(index-1).addClass(&apos;current&apos;); &#125; &#125;);2.快捷键使用img[src=&quot;./images/text_$.png&quot;]*83.由于网页加载太快，第一屏在出来的时候已经加载完毕，所以需要延迟动画开始执行的时间，可以通过定时器来实现（setTimeout）或者通过动画来实现。4.第二屏使用 通过伸缩盒子来实现页面布局 注意： 1）使用fullpage会给section自动添加一个子元素div,所以在指定伸缩盒子的时候不能给section指定,而是给section&gt;div来指定display:flex; .three&gt;div &#123; display:flex; justify-content:space-between; 水平方向对齐方式 align-items:center; 垂直方向对齐方式居中 &#125; 2）盾牌效果实现时，中间有很大的缝隙，通过指定font-size:0;来修改或者通过将图片转换为块级元素来实现(需要通过浮动来实现); 扩展修改图片底色123456781）将图片拉入ps中2）点击右下角新建图层3）按ctrl+backspace键填充颜色，图片底色改变，原来内容消失4）将上面的图层拉到下面（ps右下角图层面板），内容即可显示快捷键：ctrl+r：显示标尺 百分比12341)如果padding设置的是百分比的话，那么上下左右的值全是改盒子的宽度*百分比得到的值。也就是说百分比参照的是该盒子的宽度，与高度无关。2）设置margin时如果设置的值是百分比的话，百分比也是参照该盒子的宽度3）边框不能使用百分比设置，不支持百分比 清除浮动的4种方式1234567891011121314151617181920212223242526272829301.额外标签法 在最后一个浮动元素的后面添加空标签，设置样式为 &lt;div class=&apos;clearfix&apos;&gt;&lt;/div&gt; .clearfix &#123; clear:both; &#125;2.使用伪元素清除浮动 .clearfix::after &#123; conrtent:&apos;&apos;; display:block; height:0; line-height:0; clear:both; visibility:hidden; &#125; .clearfix &#123; *zoom:1; &#125;3.双伪元素清除浮动(代码待验证) .clearfix::before, .clearfix::after &#123; content:&apos;&apos;; display:table; &#125; .clearfix::after &#123; clear:both; &#125; .clearfix &#123; *zoom:1; &#125;4.触发BFC模式 给父元素添加overflow:hidden;来清除浮动 布局方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051两种布局方式实现效果相似，只是实现方式有点点不一样，都是两侧宽度固定，中间自适应的布局1.圣杯布局&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; width: 1100px; margin: 0 auto; background: red; height: 600px; &#125; .main &#123; float: left; width: 100%; height: 200px; background: green; padding: 0 100px; box-sizing: border-box; &#125; .left &#123; float: left; margin-left: -1100px; width: 100px; height: 200px; background: yellowgreen; &#125; .right &#123; float: left; margin-left: -100px; width: 100px; height: 200px; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt; sadfjaklfjklsajfl;sajfk;lsdjfkaljfkldajf; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;三个盒子都浮动，然后最后两个盒子设置margin值2.双飞翼布局 3个盒子浮动，最后两个margin，给第一个盒子里面添加一个盒子，给盒子设置margin即可。 logo优化123456789101112131415&lt;div class=&apos;logo&apos;&gt; &lt;h1&gt; 提高访问的权重 &lt;a href=&apos;haha.html&apos; title=&apos;嘻嘻&apos;&gt;哈哈&lt;/a&gt; &lt;/h1&gt;&lt;/div&gt;&lt;style&gt; a &#123; width:100px; height:100px; display:block; background:url(logo.png) no-repreat; text-indent: -2000em; &#125;&lt;/style&gt; 网站后台布局123456789101112131415161718192021222324252627左边宽度固定,右边宽度自适应1.第一种左边盒子宽度固定并设置浮动,右边盒子宽度100%,设置margin-left为左边盒子的宽度.left &#123; width: 200px; height: 300px; float: left;&#125;.right &#123; width: 100%; height: 600px; margin-left: 200px;&#125;2.第二种左边盒子宽度固定并设置为固定定位,因为固定定位是参考浏览器的高度的,设置左边盒子的高度为100%,右边盒子设置margin-left为左边盒子的宽度.left &#123; width: 200px; height: 100%; position:fixed; left: 0; top: 0;&#125;.right &#123; width: 100%; height: 600px; margin-left: 200px;&#125; 使用less完成网站后台页面布局1234567891011121.引入less.js文件 在使用link标签引入less文件时 &lt;link rel=&apos;stylesheet/less&apos; href=&apos;./css/index.less&apos;&gt;2.在index.less文件中 引入base.less@import &apos;./base.less&apos;开启服务器3.引入bootstrap基础模板4.布局div.left div.image img+span div.nav]]></content>
  </entry>
  <entry>
    <title><![CDATA[jquery]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fjquery%2F</url>
    <content type="text"><![CDATA[jQueryjQuery对象和DOM对象的区别DOM对象1234用原生JavaScript获取的DOM对象 通过document.getElementById() 反馈的是元素(DOM对象)通过document.getElementsByTagName()获取到的是什么？ 伪数组(集合)，集合中的每一个对象是DOM对象 jQuery对象12jQuery对象用$()的方式获取的对象jQuery对象又可以叫做包装集(包装的DOM对象的集合) 区别jQuery对象不能使用DOM对象的成员，DOM对象不能使用jQuery对象的成员 12345678910111213// DOM对象var box = document.getElementById('box');// 错误box.text('hello');// 正确box.innerText = 'hello';// jQuery对象，jQuery对象加前缀$，用以区分DOM对象var $box = $('#box');// 错误$box.innerText = 'hello';// 正确$box.text('hello'); jQuery对象和DOM对象的相互转换123456jQuery对象转换成DOM对象： jQuery对象.get(索引值); jQuery对象[索引值] jQuery对象是包装集(集合)，从集合中取数据可以使用索引的方式DOM对象转换成jQuery对象： $(DOM对象) 只有这一种方法; 选择器jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。（查看jQuery文档） jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。 jQuery基本选择器 名称 用法 描述 ID选择器 $(‘#id’); 获取指定ID的元素 类选择器 $(‘.class’); 获取同一类class的元素 标签选择器 $(‘div’); 获取同一类标签的所有元素 并集选择器 $(‘div,p,li’); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(‘div.redClass’); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 jQuery层级选择器 名称 用法 描述 子代选择器 $(‘ul &gt; li’); 使用-号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(‘ul li’); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 跟CSS的选择器一模一样。 jQuery过滤选择器 这类选择器都带冒号: 名称 用法 描述 :eq（index） $(‘li:eq(2)’).css(‘color’, ‘red’); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(‘li:odd’).css(‘color’, ‘red’); 获取到的li元素中，选择索引号为奇数的元素 :even $(‘li:even’).css(‘color’, ‘red’); 获取到的li元素中，选择索引号为偶数的元素 jQuery筛选选择器(方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 名称 用法 描述 children(selector) $(‘ul’).children(‘li’) 相当于$(‘ul-li’)，子类选择器 find(selector) $(‘ul’).find(‘li’); 相当于$(‘ul li’),后代选择器 siblings(selector) $(‘#first’).siblings(‘li’); 查找兄弟节点，不包括自己本身。 parent() $(‘#first’).parent(); 查找父亲 eq(index) $(‘li’).eq(2); 相当于$(‘li:eq(2)’),index从0开始 next() $(‘li’).next() 找下一个兄弟 prev() $(‘li’).prev() 找上一次兄弟 案例 鼠标放上突出展示 [02-突出展示.html] 鼠标进入高亮显示 [03-鼠标进入高亮显示.html] 下拉菜单 [04-下拉菜单.html] 手风琴 [05-手风琴.html] 淘宝服饰精品 [06-淘宝服饰精品.html] jQuery操作样式CSS操作 功能：设置或者修改样式，操作的是style属性。 操作单个样式 12345// name：需要设置的样式名称// value：对应的样式值$obj.css(name, value);// 使用案例$('#one').css('background','gray');// 将背景色修改为灰色 设置多个样式 12345678// 参数是一个对象，对象中包含了需要设置的样式名和样式值$obj.css(obj);// 使用案例$('#one').css(&#123; 'background':'gray', 'width':'400px', 'height':'200px'&#125;); 获取样式 1234// name:需要获取的样式名称$obj.css(name);// 案例$('div').css('background-color'); 注意：获取样式操作只会返回第一个元素对应的样式值。 隐式迭代： 设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。 class操作 添加样式类 1234// name：需要添加的样式类名，注意参数不要带点.$obj.addClass(name);// 例子,给所有的div添加one的样式。$('div').addClass('one'); 移除样式类 1234// name:需要移除的样式类名$obj.removeClass('name');// 例子，移除div中one的样式类名$('div').removeClass('one'); 判断是否有某个样式类 1234// name:用于判断的样式类名，返回值为true false$obj.hasClass(name)// 例子，判断第一个div是否有one的样式类$('div').hasClass('one'); 切换样式类 1234// name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。$obj.toggleClass(name);// 例子$('div').toggleClass('one'); 案例 tab栏切换案例 [07-tab栏切换.html] jQuery动画 jQuery提供了三组基本动画，这些动画都是标准的、有规律的效果，jQuery还提供了自定义动画的功能。 演示动画效果 [08-演示jQuery动画（animate）.html] 三组基本动画 显示(show)与隐藏(hide)是一组动画： 滑入(slideUp)与滑出(slideDown)与切换(slideToggle)，效果与卷帘门类似 淡入(fadeIn)与淡出(fadeOut)与切换(fadeToggle) 123456789$obj.show([speed], [callback]);// speed(可选)：动画的执行时间 // 1.如果不传，就没有动画效果。如果是slide和fade系列，会默认为normal // 2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐) // 3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。// callback(可选):执行完动画后执行的回调函数slideDown()/slideUp()/slideToggle();同理fadeIn()/fadeOut();fadeToggle();同理 自定义动画 animate: 自定义动画 12345$(selector).animate(&#123;params&#125;,[speed],[easing],[callback]);// &#123;params&#125;：要执行动画的CSS属性，带数字（必选）// speed：执行动画时长（可选）// easing:执行效果，默认为swing（缓动） 可以是linear（匀速）// callback：动画执行完后立即执行的回调函数（可选） 动画队列与停止动画 在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行（联想：火车进站）。 1234// stop方法：停止动画效果stop(clearQueue, jumpToEnd);// 第一个参数：是否清除队列// 第二个参数：是否跳转到最终效果 案例 开机动画案例 [09-开关机动画.html] 下拉菜单-动画 [10-下拉菜单-动画.html] jQuery节点操作创建节点123// $(htmlStr)// htmlStr：html格式的字符串$('&lt;span-这是一个span元素&lt;/span-'); 添加节点1234append appendTo 在被选元素的结尾插入内容prepend prependTo 在被选元素的开头插入内容before 在被选元素之后插入内容after 在被选元素之前插入内容 清空节点与删除节点 empty：清空指定节点的所有元素，自身保留(清理门户) 12$('div').empty(); // 清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码）$('div').html('');// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。 remove：相比于empty，自身也删除（自杀） 1$('div').remove(); 克隆节点 作用：复制匹配的元素 1234// 复制$(selector)所匹配到的元素（深度复制）// cloneNode(true)// 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。$(selector).clone(); 案例 城市选择 [11-城市选择案例.html] 删除表格 [12 表格删除案例.html] 根据数据生成表格 [13-表格生成案例.html] 添加和删除表格数据 [14-动态数据添加和删除.html] jQuery操作属性attr操作 设置单个属性 123456// 第一个参数：需要设置的属性名// 第二个参数：对应的属性值$obj.attr(name, value);// 用法举例$('img').attr('title','哎哟，不错哦');$('img').attr('alt','哎哟，不错哦'); 设置多个属性 12345678// 参数是一个对象，包含了需要设置的属性名和属性值$obj.attr(obj)// 用法举例$('img').attr(&#123; title:'哎哟，不错哦', alt:'哎哟，不错哦', style:'opacity:.5'&#125;); 获取属性 12345// 传需要获取的属性名称，返回对应的属性值$obj.attr(name)// 用法举例var oTitle = $('img').attr('title');alert(oTitle); 移除属性 1234// 参数：需要移除的属性名，$obj.removeAttr(name);// 用法举例$('img').removeAttr('title'); prop操作 在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。 1234// 设置属性$(':checked').prop('checked',true);// 获取属性$(':checked').prop('checked');// 返回true或者false val()/text/()html()123$obj.val() 获取或者设置表单元素的value属性的值$obj.html() 对应innerHTML$obj.text() 对应innerText/textContent，处理了浏览器的兼容性 案例 表格全选反选 [15-表格全选反选.html] 打字效果 [16-打字效果.html] jQuery尺寸和位置操作width方法与height方法 设置或者获取高度，不包括内边距、边框和外边距 1234// 带参数表示设置高度$('img').height(200);// 不带参数获取高度$('img').height(); 获取网页的可视区宽高 1234// 获取可视区宽度$(window).width();// 获取可视区高度$(window).height(); innerWidth/innerHeight/outerWidth/outerHeight123innerWidth()/innerHeight() 方法返回元素的宽度/高度（包括内边距）。outerWidth()/outerHeight() 方法返回元素的宽度/高度（包括内边距和边框）。outerWidth(true)/outerHeight(true) 方法返回元素的宽度/高度（包括内边距、边框和外边距）。 scrollTop与scrollLeft 设置或者获取垂直滚动条的位置 1234// 获取页面被卷曲的高度$(window).scrollTop();// 获取页面被卷曲的宽度$(window).scrollLeft(); offset方法与position方法 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素(offsetParent)的位置。 1234// 获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();// 获取相对于其最近的有定位的父元素的位置。$(selector).position(); 案例：固定导航栏 [17-固定导航栏.html]案例：电梯导航 [18-电梯导航.html] jQuery事件机制 JavaScript中已经学习过了事件，jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。 jQuery事件发展历程(了解)简单事件绑定–bind事件绑定–delegate事件绑定–on事件绑定(推荐) 简单事件注册 123click(handler) 单击事件mouseenter(handler) 鼠标进入事件mouseleave(handler) 鼠标离开事件 缺点：不能同时注册多个事件 bind方式注册事件 12345// 第一个参数：事件类型// 第二个参数：事件处理程序$('p').bind('click mouseenter', function()&#123; // 事件响应方法&#125;); 缺点：不支持动态事件绑定 delegate注册委托事件 123456// 第一个参数：selector，要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$('.parentBox').delegate('p', 'click', function()&#123; // 为 .parentBox下面的所有的p标签绑定事件&#125;); 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on注册事件 on注册事件(重点) jQuery1.7之后，jQuery用on统一了所有事件的处理方法。 最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。 on注册简单事件 12// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on( 'click', function() &#123;&#125;); on注册事件委托 12// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on( 'click','span', function() &#123;&#125;); 事件委托原理 12345678// 事件委托的原理var ul = document.querySelector('#ul');ul.onclick = function (e) &#123; // console.log(e.target.tagName); if (e.target.tagName.toLowerCase() === 'li') &#123; console.log(e.target); &#125;&#125; on注册事件的语法： 12345// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events[,selector][,data],handler); 通过源码查看 bind click delegate on 注册事件的区别 事件解绑 unbind方式（不用） 12$(selector).unbind(); // 解绑所有的事件$(selector).unbind('click'); // 解绑指定的事件 undelegate方式（不用） 12$( selector ).undelegate(); // 解绑所有的delegate事件$( selector).undelegate( 'click' ); // 解绑所有的click事件 off方式（推荐） 1234// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件$(selector).off('click'); 触发事件12$(selector).click(); // 触发 click事件$(selector).trigger('click'); jQuery事件对象jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。 12345678910// screenX和screenY 对应屏幕最左上角的值// clientX和clientY 距离页面左上角的位置（忽视滚动条）// pageX和pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）// event.keyCode 按下的键盘代码// event.data 存储绑定事件时传递的附加数据// event.stopPropagation() 阻止事件冒泡行为// event.preventDefault() 阻止浏览器默认行为// return false:既能阻止事件冒泡，又能阻止浏览器默认行为。 案例 按键变色 [19-按键变色.html] jQuery补充知识点链式编程 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。 1end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。 each方法 jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。 作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数 123// 参数一表示当前元素在所有匹配元素中的索引号// 参数二表示当前元素（DOM对象）$(selector).each(function(index,element)&#123;&#125;); 多库共存 jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权. 1var c = $.noConflict();// 释放$的控制权,并且把$的能力给了c 案例 五角星评分案例 [20-五角星评分案例.html] 插件常用插件 弹出层插件 layer layer插件 放大镜插件 jQuery.zoom 轮播图插件 http://sorgalla.com/jcarousel/ https://github.com/OwlCarousel2/OwlCarousel2 图片懒加载插件 jQuery.lazyload jQueryUI 常用的2-3个功能演示 查看jQuery插件的源码 自己探索插件 artDialog 图片放大 github上搜索 jQuery插件开发 给jQuery增加方法的两种方式 12$.method = fn 静态方法$.fn.method = fn 实例方法 增加一个静态方法，实现两个数的和，插件 1234567(function ($) &#123; $.add = function (a, b) &#123; return a + b; &#125;&#125;(jQuery))$.add(5, 6); tab栏插件 [21-tab栏插件.html] 1234567891011121314151617181920212223242526272829303132333435(function ($) &#123; // &#123;tabMenu: '#aa'&#125; $.tab = function (options) &#123; // 默认参数 var defaults = &#123; tabMenu: '#tab', activeClass: 'active', tabMain: '#tab-main', tabMainSub: '.main', selectedClass: 'selected' &#125; // 把options中的属性，把对应属性的值赋给defaults对应的属性 // defaults.tabMenu = options.tabMenu || defaults.tabMenu; // for(var key in options) &#123; // defaults[key] = options[key]; // &#125; $.extend(defaults, options); $(defaults.tabMenu).on('click', 'li', function () &#123; $(this) .addClass(defaults.activeClass) .siblings() .removeClass(defaults.activeClass); // var index = $(this).index(); // $(defaults.tabMain + ' ' + defaults.tabMainSub) .eq(index) .addClass(defaults.selectedClass) .siblings() .removeClass(defaults.selectedClass); &#125;) &#125;&#125;(window.jQuery)) 表格插件 [22-表格插件.html] 123456789101112131415161718192021222324252627282930313233343536(function($) &#123; // 内部的变量，外部无法访问，防止变量名冲突 var a = 0; // 给$增加了一个实例方法 $.fn.table = function (header, data) &#123; var array = []; array.push('&lt;table&gt;'); array.push('&lt;tr&gt;'); // 生成表头 $.each(header, function () &#123; array.push('&lt;th&gt;' + this + '&lt;/th&gt;'); &#125;) array.push('&lt;/tr&gt;'); // 生成数据行 $.each(data, function (index) &#123; // this是当前遍历到的数组中的每一个对象 // 拼数据行 array.push('&lt;tr&gt;'); array.push('&lt;td&gt;' + (index + 1) + '&lt;/td&gt;'); // 遍历对象，拼表格 for (var key in this) &#123; array.push('&lt;td&gt;' + this[key] + '&lt;/td&gt;'); &#125; array.push('&lt;/tr&gt;'); &#125;) array.push('&lt;/table&gt;'); this.append(array.join('')); &#125;&#125;(window.jQuery)) 插件开发的原理]]></content>
  </entry>
  <entry>
    <title><![CDATA[js高级]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fjs%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[JavaScript 高级JavaScript 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。 基本类型（值类型） Undefined Null Boolean Number String 复杂类型（引用类型） Object Array Date RegExp Function 基本包装类型 Boolean Number String 单体内置对象 Global Math 类型检测 typeof instanceof Object.prototype.toString.call() 创建对象简单方式我们可以直接通过 new Object() 创建： 1234567var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建： 1234567var person = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 对于上面的写法固然没有问题，但是假如我们要生成两个 person 实例对象呢？ 123456789101112131415var person1 = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125;var person2 = &#123; name: 'Mike', age: 16, sayName: function () &#123; console.log(this.name) &#125;&#125; 通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。 构造函数内容引导： 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 普通函数调用和构造函数调用的区别 构造函数的返回值 构造函数的静态成员和实例成员 函数也是对象 实例成员 静态成员 构造函数的问题 更优雅的工厂函数：构造函数一种更优雅的工厂函数就是下面这样，构造函数： 12345678910111213function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person('Jack', 18)p1.sayName() // =&gt; Jackvar p2 = new Person('Mike', 23)p2.sayName() // =&gt; Mike 使用 new 操作符调用构造函数会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码 返回新对象 下面是具体的伪代码： 12345678910111213141516function Person (name, age) &#123; // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象 // var instance = &#123;&#125; // 然后让内部的 this 指向 instance 对象 // this = instance // 接下来所有针对 this 的操作实际上操作的就是 instance this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125; // 在函数的结尾处会将 this 返回，也就是 instance // return this&#125; 构造函数和实例对象的关系使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。在每一个实例对象中的__proto__中同时有一个 constructor 属性，该属性指向创建该实例的构造函数： 123console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true 对象的 constructor 属性最初是用来标识对象类型的，但是，如果要检测对象的类型，还是使用 instanceof 操作符更可靠一些： 12console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true 总结： 构造函数是根据具体的事物抽象出来的抽象模板 实例对象是根据抽象的构造函数模板得到的具体实例对象 每一个实例对象都具有一个 constructor 属性，指向创建该实例的构造函数 注意： constructor 是实例的属性的说法不严谨，具体后面的原型会讲到 可以通过实例的 constructor 属性判断实例和构造函数之间的关系 注意：这种方式不严谨，推荐使用 instanceof 操作符，后面学原型会解释为什么 构造函数的问题使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： 1234567891011function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = function () &#123; console.log('hello ' + this.name) &#125;&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16) 在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 1console.log(p1.sayHello === p2.sayHello) // =&gt; false 对于这种问题我们可以把需要共享的函数定义到构造函数外部： 123456789101112131415function sayHello = function () &#123; console.log('hello ' + this.name)&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = sayHello&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; true 这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。 你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题： 12345678910111213141516171819202122var fns = &#123; sayHello: function () &#123; console.log('hello ' + this.name) &#125;, sayAge: function () &#123; console.log(this.age) &#125;&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = fns.sayHello this.sayAge = fns.sayAge&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; trueconsole.log(p1.sayAge === p2.sayAge) // =&gt; true 至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。但是代码看起来还是那么的格格不入，那有没有更好的方式呢？ 小结 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 构造函数的问题 原型内容引导： 使用 prototype 原型对象解决构造函数的问题 分析 构造函数、prototype 原型对象、实例对象 三者之间的关系 属性成员搜索原则：原型链 实例对象读写原型对象中的成员 原型对象的简写形式 原生对象的原型 Object Array String … 原型对象的问题 构造的函数和原型对象使用建议 更好的解决方案： prototypeJavascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 1234567891011121314151617function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.type = 'human'Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // =&gt; true 这时所有实例的 type 属性和 sayName() 方法，其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 构造函数、实例、原型三者之间的关系 任何函数都具有一个 prototype 属性，该属性是一个对象。 123456function F () &#123;&#125;console.log(F.prototype) // =&gt; objectF.prototype.sayHi = function () &#123; console.log('hi!')&#125; 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数。 1console.log(F.constructor === F) // =&gt; true 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。 12var instance = new F()console.log(instance.__proto__ === F.prototype) // =&gt; true __proto__ 是非标准属性。 实例对象可以直接访问原型对象成员。 1instance.sayHi() // =&gt; hi! 总结： 任何函数都具有一个 prototype 属性，该属性是一个对象 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__ 所有实例都直接或间接继承了原型对象的成员 属性成员的搜索原则：原型链了解了 构造函数-实例-原型对象 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性 搜索首先从对象实例本身开始 如果在实例中找到了具有给定名字的属性，则返回该属性的值 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性 如果在原型对象中找到了这个属性，则返回该属性的值 也就是说，在我们调用 person1.sayName() 的时候，会先后执行两次搜索： 首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。 ”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。 ”于是，它就读取那个保存在原型对象中的函数。 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。 而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 总结： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 实例对象读写原型对象成员读取： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 值类型成员写入（实例对象.值类型成员 = xx）： 当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上 也就是说该行为实际上会屏蔽掉对原型对象成员的访问 引用类型成员写入（实例对象.引用类型成员 = xx）： 同上 复杂类型修改（实例对象.成员.xx = xx）： 同样会先在自己身上找该成员，如果自己身上找到则直接修改 如果自己身上找不到，则沿着原型链继续查找，如果找到则修改 如果一直到原型链的末端还没有找到该成员，则报错（实例对象.undefined.xx = xx） 更简单的原型语法我们注意到，前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： 1234567891011function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 在该示例中，我们将 Person.prototype 重置到了一个新的对象。这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： 123456789101112function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; constructor: Person, // =&gt; 手动将 constructor 指向正确的构造函数 type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 原生对象的原型 所有函数都有 prototype 属性对象。 Object.prototype Function.prototype Array.prototype String.prototype Number.prototype Date.prototype … 练习：为数组对象和字符串对象扩展原型方法。 原型对象的问题 共享数组 共享对象 如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则就是问题。 一个更好的建议是，最好不要让实例之间互相共享这些数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。 原型对象使用建议 私有成员（一般就是非函数成员）放到构造函数中 共享成员（一般就是函数）放到原型对象中 如果重置了 prototype 记得修正 constructor 的指向 把html中的js代码放到index.js中避免html中出现js代码 自调用函数的参数1234(function (window, undefined) &#123; var document = window.document;&#125;(window, undefined)) 传入window对象 将来代码压缩的时候，可以吧 function (window) 压缩成 function (w) 传入undefined 在将来会看到别人写的代码中会把undefined作为函数的参数(当前案例没有使用)因为在有的老版本的浏览器中 undefined可以被重新赋值，防止undefined 被重新赋值 整理代码现在的代码结构清晰，谁出问题就找到对应的js文件即可。通过自调用函数，已经防止了变量命名污染的问题 但是，由于js文件数较多，需要在页面上引用，会产生文件依赖的问题(先引入那个js，再引入哪个js)将来通过工具把js文件合并并压缩。现在手工合并js文件演示 问题1 1234567891011121314// 如果存在多个自调用函数要用分号分割，否则语法错误// 下面代码会报错(function () &#123;&#125;())(function () &#123;&#125;())// 所以代码规范中会建议在自调用函数之前加上分号// 下面代码没有问题;(function () &#123;&#125;());(function () &#123;&#125;()) 问题2 123456789// 当自调用函数 前面有函数声明时，会把自调用函数作为参数// 所以建议自调用函数前，加上;var a = function () &#123; alert('11');&#125; (function () &#123; alert('22');&#125;()) 继承什么是继承 现实生活中的继承 程序中的继承 构造函数的属性继承：借用构造函数12345678910111213function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;function Student (name, age) &#123; // 借用构造函数继承属性成员 Person.call(this, name, age)&#125;var s1 = Student('张三', 18)console.log(s1.type, s1.name, s1.age) // =&gt; human 张三 18 构造函数的原型方法继承：拷贝继承（for-in）12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 原型对象拷贝继承原型对象成员for(var key in Person.prototype) &#123; Student.prototype[key] = Person.prototype[key]&#125;var s1 = Student('张三', 18)s1.sayName() // =&gt; hello 张三 另一种继承方式：原型继承12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 利用原型的特性实现继承Student.prototype = new Person()var s1 = Student('张三', 18)console.log(s1.type) // =&gt; humans1.sayName() // =&gt; hello 张三 函数进阶函数的定义方式 函数声明 函数表达式 new Function 函数声明123function foo () &#123;&#125; 函数表达式123var foo = function () &#123;&#125; 函数声明与函数表达式的区别 函数声明必须有名字 函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用 函数表达式类似于变量赋值 函数表达式可以没有名字，例如匿名函数 函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用 下面是一个根据条件定义函数的例子： 123456789if (true) &#123; function f () &#123; console.log(1) &#125;&#125; else &#123; function f () &#123; console.log(2) &#125;&#125; 以上代码执行结果在不同浏览器中结果不一致。 不过我们可以使用函数表达式解决上面的问题： 1234567891011var fif (true) &#123; f = function () &#123; console.log(1) &#125;&#125; else &#123; f = function () &#123; console.log(2) &#125;&#125; 函数的调用方式 普通函数 构造函数 对象方法 函数内 this 指向的不同场景函数的调用方式决定了 this 指向的不同： 调用方式 非严格模式 备注 普通函数调用 window 严格模式下是 undefined 构造函数调用 实例对象 原型方法中 this 也是实例对象 对象方法调用 该方法所属对象 紧挨着的对象 事件绑定方法 绑定事件对象 定时器函数 window 这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。 函数也是对象 所有函数都是 Function 的实例 call、apply、bind那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。这就是接下来我们要学习的 call、apply、bind 三个函数方法。 callcall() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 在 fun 函数运行时指定的 this 值 如果指定了 null 或者 undefined 则内部 this 指向 window arg1, arg2, ... 指定的参数列表 applyapply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：该方法的作用和 call() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.apply(thisArg, [argsArray]) 参数： thisArg argsArray apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数列表。例如： 1fun.apply(this, ['eat', 'bananas']) bindbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值： 返回由指定的this值和初始化参数改造的原函数拷贝。 示例1： 123456789101112131415this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 示例2： 12345678910111213141516function LateBloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// Declare bloom after a delay of 1 secondLateBloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 1000);&#125;;LateBloomer.prototype.declare = function() &#123; console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');&#125;;var flower = new LateBloomer();flower.bloom(); // 一秒钟后, 调用'declare'方法 小结 call 和 apply 特性一样 都是用来调用函数，而且是立即调用 但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向 call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可 apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递 如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window bind 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数 它和 call、apply 最大的区别是：bind 不会调用 bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递 在 bind 的同时，以参数列表的形式进行传递 在调用的时候，以参数列表的形式进行传递 那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部 函数的其它成员 arguments 实参集合 caller 函数的调用者 length 形参的个数 name 函数的名称 12345678910111213function fn(x, y, z) &#123; console.log(fn.length) // =&gt; 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // =&gt; 函数的名字&#125;function f() &#123; fn(10, 20, 30)&#125;f() 高阶函数 函数可以作为参数 函数可以作为返回值 作为参数12345678910function eat (callback) &#123; setTimeout(function () &#123; console.log('吃完了') callback() &#125;, 1000)&#125;eat(function () &#123; console.log('去唱歌')&#125;) 作为返回值1234567891011function genFun (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === type &#125;&#125;var isArray = genFun('[object Array]')var isObject = genFun('[object Object]')console.log(isArray([])) // =&gt; trueconsole.log(isArray(&#123;&#125;)) // =&gt; true 函数闭包1234567891011121314151617function fn () &#123; var count = 0 return &#123; getCount: function () &#123; console.log(count) &#125;, setCount: function () &#123; count++ &#125; &#125;&#125;var fns = fn()fns.getCount() // =&gt; 0fns.setCount()fns.getCount() // =&gt; 1 作用域、作用域链、预解析 全局作用域 函数作用域 没有块级作用域 12345678910&#123; var foo = 'bar'&#125;console.log(foo)if (true) &#123; var a = 123&#125;console.log(a) 作用域链示例代码： 123456789101112131415161718var a = 10function fn () &#123; var b = 20 function fn1 () &#123; var c = 30 console.log(a + b + c) &#125; function fn2 () &#123; var d = 40 console.log(c + d) &#125; fn1() fn2()&#125; 内层作用域可以访问外层作用域，反之不行 什么是闭包闭包就是能够读取其他函数内部变量的函数，由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 可以在函数外部读取函数内部成员 让函数内成员始终存活在内存中 一些关于闭包的例子示例1： 123456var arr = [10, 20, 30]for(var i = 0; i &lt; arr.length; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;&#125; 示例2： 12345678console.log(111)for(var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 0)&#125;console.log(222) 示例3：投票 示例4：判断类型 示例5：沙箱模式 闭包的思考题思考题 1： 1234567891011var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 思考题 2： 1234567891011var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function () &#123; var that = this; return function () &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 小结函数递归递归执行模型123456789101112131415161718192021222324function fn1 () &#123; console.log(111) fn2() console.log('fn1')&#125;function fn2 () &#123; console.log(222) fn3() console.log('fn2')&#125;function fn3 () &#123; console.log(333) fn4() console.log('fn3')&#125;function fn4 () &#123; console.log(444) console.log('fn4')&#125;fn1() 举个栗子：计算阶乘的递归函数1234567function factorial (num) &#123; if (num &lt;= 1) &#123; return 1 &#125; else &#123; return num * factorial(num - 1) &#125;&#125; 递归应用场景 深拷贝 菜单树 遍历 DOM 树 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ 验证邮编： 1^\d&#123;6&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn： 1^\w+@\w+\.\w+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;\(.\d&#123;1,3&#125;)&#123;3&#125;$ JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\d', 'i');var reg = new Regex('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); 匹配正则表达式// console.log(/./.test(“除了回车换行以为的任意字符”));//true// console.log(/.*/.test(“0个到多个”));//true// console.log(/.+/.test(“1个到多个”));//true// console.log(/.?/.test(“哈哈”));//true// console.log(/[0-9]/.test(“9527”));//true// console.log(/[a-z]/.test(“what”));//true// console.log(/[A-Z]/.test(“Are”));//true// console.log(/[a-zA-Z]/.test(“干啥子”));//false// console.log(/[0-9a-zA-Z]/.test(“9ebg”));//true// console.log(/b|(ara)/.test(“abra”));//true// console.log(/[a-z]{2,3}/.test(“arfsf”));//true 12345678910console.log(/\d/.test(&quot;998&quot;));//trueconsole.log(/\d*/.test(&quot;998&quot;));//trueconsole.log(/\d+/.test(&quot;998&quot;));//trueconsole.log(/\d&#123;0,&#125;/.test(&quot;998&quot;));//trueconsole.log(/\d&#123;2,3&#125;/.test(&quot;998&quot;));//trueconsole.log(/\D/.test(&quot;eat&quot;));//trueconsole.log(/\s/.test(&quot; &quot;));//trueconsole.log(/\S/.test(&quot;嘎嘎&quot;));//trueconsole.log(/\w/.test(&quot;_&quot;));//trueconsole.log(/\W/.test(&quot;_&quot;));//true 正则表达式案例1.验证密码强弱2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}3.验证中文名字[\u4e00-\u9fa5] 正则提取123456789101112131415161718192021222324252627// 1. 提取工资var str = "张三：1000，李四：5000，王五：8000。";var array = str.match(/\d+/g);console.log(array);// 2. 提取email地址var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;var str = "123123@xx.com";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125; 正则替换123456789// 1. 替换所有空白var str = " 123AD asadf asadfasf adf ";str = str.replace(/\s/g,"xx");console.log(str);// 2. 替换所有,|，var str = "abc,efg,123，abc,123，a";str = str.replace(/,|，/g, ".");console.log(str); 案例：表单验证12345QQ号：&lt;input type="text" id="txtQQ"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type="text" id="txtEMail"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type="text" id="txtPhone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type="text" id="txtBirthday"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type="text" id="txtName"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById("txtQQ");var txtEMail = document.getElementById("txtEMail");var txtPhone = document.getElementById("txtPhone");var txtBirthday = document.getElementById("txtBirthday");var txtName = document.getElementById("txtName");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的QQ号"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\w+@\w+\.\w+(\.\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的EMail地址"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, "请输入正确的出生日期");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id="frm"&gt; QQ号：&lt;input type="text" name="txtQQ" data-rule="qq"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type="text" name="txtEMail" data-rule="email"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type="text" name="txtPhone" data-rule="phone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type="text" name="txtBirthday" data-rule="date"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type="text" name="txtName" data-rule="cn"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\d&#123;5,12&#125;$/, tip: "请输入正确的QQ" &#125;, &#123; name: 'email', reg: /^\w+@\w+\.\w+(\.\w+)?$/, tip: "请输入正确的邮箱地址" &#125;, &#123; name: 'phone', reg: /^\d&#123;11&#125;$/, tip: "请输入正确的手机号码" &#125;, &#123; name: 'date', reg: /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/, tip: "请输入正确的出生日期" &#125;, &#123; name: 'cn', reg: /^[\u4e00-\u9fa5]&#123;2,4&#125;$/, tip: "请输入正确的姓名" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125; 补充伪数组和数组在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。 对象与数组的关系在说区别之前，需要先提到另外一个知识，就是 JavaScript 的原型继承。所有 JavaScript 的内置构造函数都是继承自 Object.prototype 。在这个前提下，可以理解为使用 new Array() 或 [] 创建出来的数组对象，都会拥有 Object.prototype 的属性值。 1234var obj = &#123;&#125;;// 拥有 Object.prototype 的属性值var arr = [];//使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，//那么，它将同时拥有 Array.prototype 和 Object.prototype 的属性值 可以得到对象和数组的第一个区别：对象没有数组 Array.prototype 的属性值。 什么是数组数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码： 12345678910var obj = &#123;&#125;;var arr = []; obj[2] = 'a';arr[2] = 'a'; console.log(obj[2]); // =&gt; aconsole.log(arr[2]); // =&gt; aconsole.log(obj.length); // =&gt; undefinedconsole.log(arr.length); // =&gt; 3 obj[2]输出’a’，是因为对象就是普通的键值对存取数据 而arr[2]输出’a’ 则不同，数组是通过索引来存取数据，arr[2]之所以输出’a’，是因为数组arr索引2的位置已经存储了数据 obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined 而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值 为什么arr.length输出3，而不是1 在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数 什么是伪数组 拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法 伪数组，就是像数组一样有 length 属性，也有 0、1、2、3 等属性的对象，看起来就像数组一样，但不是数组，比如: 123456789101112var fakeArray = &#123; "0": "first", "1": "second", "2": "third", length: 3&#125;; for (var i = 0; i &lt; fakeArray.length; i++) &#123; console.log(fakeArray[i]);&#125; Array.prototype.join.call(fakeArray,'+'); 常见的伪数组有： 函数内部的 arguments DOM 对象列表（比如通过 document.getElementsByTags 得到的列表） jQuery 对象（比如 $(&quot;div&quot;) ） 伪数组是一个 Object，而真实的数组是一个 Array。 伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多方法，比如： 123456789101112var arr = Array.prototype.slice.call(arguments); Array.prototype.forEach.call(arguments, function(v) &#123; // 循环arguments对象&#125;);// push// some// every// filter// map// ... 以上在借用数组的原型方法的时候都可以通过数组直接量来简化使用： 1234567891011121314var obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;;[].push.call(obj, 'd')console.log([].slice.call(obj));[].forEach.call(obj, function (num, index) &#123; console.log(num)&#125;) 小结 对象没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array 数组是基于索引的实现， length 会自动更新，而对象是键值对 使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法 JavaScript 垃圾回收机制JavaScript 运行机制：Event LoopObject静态成员 Object.assign() Object.create() Object.keys() Object.defineProperty() 实例成员 constructor hasOwnProperty() isPrototypeOf propertyIsEnumerable() toString() valueOf() 附录A 代码规范代码风格 JavaScript Standard Style Airbnb JavaScript Style Guide() { 校验工具 JSLint JSHint ESLint B Chrome 开发者工具C 文档相关工具 电子文档制作工具: docute 流程图工具：DiagramDesigner]]></content>
  </entry>
  <entry>
    <title><![CDATA[webAPI]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2FwebAPI%2F</url>
    <content type="text"><![CDATA[Web APIAPI的概念API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) web API：操作浏览器 和 网页的一套==工具库== （ BOM 和 DOM ） 掌握常见的浏览器的API的调用方式MDN-Web API 认识文档树123456+ DOM，文档对象模型，又称为文档树模型。 浏览器在加载页面时， 会把html文档解析成一系列的对象。再由这些对象组成 树状结构。存入内存。+ 这些对象对外都提供了 属性和方法。我们可以 通过调用对象的属性和方法来操作网页。+ 节点对象的分类： ==文档对象==、==元素对象==、属性对象、文本对象 + 小结：文档树：本质就是浏览器把文档、文档中标签、标签属性以及标签文本转换成对象，按照嵌套关系以树状结构 存放这一组对象，并放入内存中。 JavaScript的组成 ECMAScript 核心语法 BOM 浏览器对象模型 DOM 文档对象模型 ECMAScript - JavaScript的核心定义了javascript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 BOMBOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window注意：window下一个特殊的属性 window.name 对话框 window.alert() window.prompt() 有提示信息的对话框 window.confirm( ) 有确认、取消按钮 console.log(); 控制台 页面加载事件 onload 1234window.onload = function () &#123; // 当页面加载完成执行 // 当页面完全加载所有内容（包括内容、标签、属性、图像、脚本文件、CSS 文件等）执行&#125; onunload 1234浏览器关闭才触发的事件 IE8支持window.onunload = function () &#123; // 当用户退出页面时执行&#125; onbeforeunload 关闭页面之前触发 123window.onbeforeunload = function()&#123; alert(&apos;hshd&apos;);&#125; 定时器注意：定时器产生和定时器执行是两会事。定时器中的函数体里的代码一定是在非定时器代码执行完最后执行的 setTimeout(fn,毫秒数)和clearTimeout(定时器id值) :一次性定时器在指定的毫秒数到达之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒后执行，返回定时器的标示var timerId = setTimeout(function () &#123; console.log('Hello World');&#125;, 1000);// 取消定时器的执行clearTimeout(timerId); setInterval(fn,毫秒数)和clearInterval(定时器id值)页面加载完毕后，每过多少时间执行一次，返回值就是定时器的id值 12345678// 创建一个定时器，每隔1秒调用一次var timerId = window.setInterval(function () &#123; var date = new Date(); console.log(date.toLocaleTimeString());&#125;, 1000);// 取消定时器的执行window.clearInterval(timerId); location对象location对象是window对象下的一个属性，时候的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL location对象 123456789101112window.location.hash:地址栏上#号后面的内容window.location.host:主机及端口号window.location.hostname:主机名window.location.port:端口号window.location.protocol:协议window.location.search:搜索的内容window.location.pathname:文件路径// 设置跳转的页面的地址location.href=&quot;http://www.jd.com&quot;;//属性-----------------&gt;必须记住location.assign(&quot;http://www.jd.com&quot;);//方法location.reload();//重新加载--刷新location.replace(&quot;http://www.jd.com&quot;);//没有历史记录 URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 12345678910111213scheme://host:port/path?query#fragmentscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个&apos;/&apos;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用&apos;&amp;&apos;符号隔开，每个参数的名和值用&apos;=&apos;符号隔开。例如：name=zsfragment:信息片断 字符串，锚点. location有哪些成员？ 使用chrome的控制台查看 查MDN MDN 成员 assign()/reload()/replace() hash/host/hostname/search/href…… 案例解析URL中的query，并返回对象的形式 1234567891011121314151617function getQuery(queryStr) &#123; var query = &#123;&#125;; if (queryStr.indexOf('?') &gt; -1) &#123; var index = queryStr.indexOf('?'); queryStr = queryStr.substr(index + 1); var array = queryStr.split('&amp;'); for (var i = 0; i &lt; array.length; i++) &#123; var tmpArr = array[i].split('='); if (tmpArr.length === 2) &#123; query[tmpArr[0]] = tmpArr[1]; &#125; &#125; &#125; return query;&#125;console.log(getQuery(location.search));console.log(getQuery(location.href)); history对象 window.history.back():返回 window.history.forward()：前进 window.history.go(1) 前进 window.history.go(-1) 后退 navigator对象 window.navigation.userAgent 通过userAgent可以判断用户浏览器的类型 window.navigation.platform 通过platform可以判断浏览器所在的系统平台类型. DOMDOM的概念文档对象模型（Document Object Model，简称DOM）， DOM又称为文档树模型 文档：一个网页可以称为文档 节点：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 模拟文档树结构 12345678910111213141516171819202122232425262728293031323334353637383940function Element(option) &#123; this.id = option.id || ''; this.nodeName = option.nodeName || ''; this.nodeValue = option.nodeValue || ''; this.nodeType = 1; this.children = option.children || [];&#125;var doc = new Element(&#123; nodeName: 'html'&#125;);var head = new Element(&#123; nodeName: 'head'&#125;);var body = new Element(&#123; nodeName: 'body'&#125;)doc.children.push(head);doc.children.push(body);var div = new Element(&#123; nodeName: 'div', nodeValue: 'haha',&#125;);var p = new Element(&#123; nodeName: 'p', nodeValue: '段落'&#125;)body.children.push(div);body.children.push(p);function getChildren(ele) &#123; for(var i = 0; i &lt; ele.children.length; i++) &#123; var child = ele.children[i]; console.log(child.nodeName); getChildren(child); &#125;&#125;getChildren(doc); 获取页面元素为什么要获取页面元素例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作 获取元素的方式12345678910111213141516通过id获取:document.getElementById(&apos;id名&apos;); 返回一个对象，没有返回null通过类名获取：document.getElementsByClassName(&apos;cls&apos;) 返回一个数组通过标签名获取：document.getElementsByTagName(&apos;li&apos;) 返回一个数组根据name获取：document.getElementsByName(&apos;li&apos;) 返回一个数组根据选择器获取：document.querySelector(&apos;.cls&apos;) 返回一个对象根据选择器获取：document.querySelectorAll(&apos;li&apos;) 返回一个数组通过选择器获取选中的元素[伪类选择器],获取已经被选中的input元素 input:checkedinput:checked &#123; width: 100px; height: 100px;&#125;获取已经选中的下拉框中的选项 下拉框选中的选项使用option：checked来选择 var options = document.querySelectorAll(&apos;#sel1 option:checked&apos;); 千万不要使用:selected html5标签属性：multiple 作用：让下拉框可以实现多选 12345678910111213141516171819202122232425262728293031323334353637获取已经选中的下拉框中的选项 下拉框选中的选项使用option：checked来选择&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; select &#123; width: 100px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html5标签属性：multiple 作用：让下拉框可以实现多选 --&gt; &lt;select id=&quot;sel1&quot; multiple&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;sh&quot; selected&gt;上海&lt;/option&gt; &lt;option value=&quot;nj&quot; selected&gt;南京&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;script&gt; // 获取所有的option var options = document.querySelectorAll(&apos;#sel1 option&apos;); console.log(options); // 获取已经选中的option var options = document.querySelectorAll(&apos;#sel1 option:checked&apos;); // 注意：千万不要使用:selected console.log(options); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件事件三要素事件源、触发和响应 事件源:触发(被)事件的元素 事件类型:事件的触发方式(例如鼠标点击或键盘点击) 事件处理程序:事件触发后要执行的代码(函数形式) 事件处理程序的本质：其实就是元素中的一个方法而已。 事件的基本使用1234var box = document.getElementById('box');box.onclick = function() &#123; console.log('代码会在box被点击后执行'); &#125;; 案例 点击按钮弹出提示框 123btn.onclick = function()&#123; alert(&apos;哈哈&apos;);&#125; 点击按钮修改元素的样式 123btn.onclick = function()&#123; dv.style.width = &apos;300px&apos;;&#125; 点击按钮修改超链接的地址和热点文字 12345btn.onclick = function()&#123; var link = document.getElementById(&apos;link&apos;); link.href = &apos;1.html&apos;; link.title = &apos;热点文字&apos;;&#125; 点击按钮显示哈哈(排他功能) 点击按钮显示和隐藏div 1234567891011121314151617181920第一种：btn.onclick = function()&#123; if(this.value == &apos;隐藏&apos;)&#123; dv.style.display = &apos;none&apos;; this.value = &apos;显示&apos;; &#125;else&#123; dv.style.display = &apos;block&apos;; this.value = &apos;隐藏&apos;; &#125;&#125;第二种：btn.onclick = function()&#123; if(dv.className != &apos;cls&apos;)&#123; dv.className = &apos;cls&apos;; this.value = &apos;显示&apos;; &#125;else&#123; dv.className= &apos;&apos;; this.value = &apos;隐藏&apos;; &#125;&#125; 显示和隐藏二维码 点击按钮修改所有p标签内容 123456btn.onclick = function()&#123; var plist = document.getElementsByTagName(&apos;p&apos;); for(var i = 0; i &lt; plist.length; i++)&#123; plist[i].innerText = &apos;sdaf &apos;; &#125;&#125; 点击按钮修改所有input文本框内容 12345678btn.onclick = function()&#123; var inputlist = document.getElementsByTagName('input'); for(var i = 0; i &lt; inputlist.length; i++)&#123; if(inputlist[i].type != 'button')&#123; inputlist[i].value = 'hsh'; &#125; &#125;&#125; 点击按钮切换图片 案例的排他功能 12345678for(var i = 0; i &lt; btnlist.length; i++)&#123; btnlist[i].onclick = function()&#123; for(var j= 0; j &lt; btnlist.length; j++)&#123; btnlist[j].value = &apos;无&apos;; &#125; this.value = &apos;有&apos;; &#125;&#125; 点击小图显示大图 美女相册 点击按钮选中性别和兴趣 属性操作非表单元素的属性innerHTML和innerText12345var box = document.getElementById('box');box.innerHTML = '我是文本&lt;p&gt;我会生成为标签&lt;/p&gt;';console.log(box.innerHTML);box.innerText = '我是文本&lt;p&gt;我不会生成为标签&lt;/p&gt;';console.log(box.innerText); 操作非表单元素对象属性 元素对象.calssName 作用：操作元素的类名 元素对象.innerHTML 作用：操作元素的内容 元素对象.innerText 作用：操作元素的内容 兼容性好 元素对象.textContent 标准属性 在IE低版本浏览器中有兼容性问题 数组和伪数组的区别 相同点 数组中的数据都是有序的 都有length属性 不同点 伪数组无法使用数组的方法 script标签位置1因为浏览器加载网页或执行代码时,顺序是从上到下执行的,执行到js代码时,还没有获取到按钮标签，还没有把按钮变成对象放到DOM树上，所以无法获取。所以得到的是null. 表单元素属性 value 用于大部分表单元素的内容获取(option除外) type 可以获取input标签的类型(输入框或复选框等) disabled 禁用属性 checked 复选框选中属性 selected 下拉菜单选中属性 元素.value 获取和设置 元素.checked 是否选中 元素.disabled 是否禁用 元素.readyonly 只读 元素.selected 下拉框选中 自定义属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 与element.属性的区别: 上述三个方法用于获取任意的行内属性。 获取：元素.getAttribute(‘属性名’) 设置： 元素.setAttribute(‘属性名’,’属性值’) 删除：元素.removeAttribute(‘属性名’) 操作元素样式 通过元素的style属性来设置样式 1234var box = document.getElementById('box');box.style.width = '100px';box.style.height = '100px';box.style.backgroundColor = 'red'; 通过类名className属性设置样式 123var box = document.getElementById('box');box.className = 'clearfix';先获取后替换再赋值 案例 开关灯 点击按钮变色 图片切换二维码案例 当前输入的文本框高亮显示 点击按钮改变div的大小和位置 列表隔行变色、高亮显示 京东商品展示 tab选项卡切换 给文本框赋值，获取文本框的值 点击按钮禁用文本框 搜索文本框 检测用户名是否是3-6位，密码是否是6-8位，如果不满足要求高亮显示文本框 设置下拉框中的选中项 全选反选 登录验证 同意协议可以注册 选餐 动态创建表格【数据、删除（事件委托）】 权限案例 百度案例 创建元素的三种方式document.write()12document.write('新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;');如果在页面加载完创建元素，页面中的内容会消失 元素.innerHTML=’内容’1234567var box = document.getElementById('box');box.innerHTML = '新内容&lt;p&gt;新标签&lt;/p&gt;';缺点：会覆盖部分网页元素及事件 通过拼接来解决元素覆盖问题 会覆盖前面的内容,先获取原来的内容，再拼接。 原来的事件也会消失 相当于赋值 document.createElement(‘标签名’)12345678创建元素var div = document.createElement('div');设置内容div.innerText = '啊哈哈';添加到父元素父元素.appendChild(div);优点：不会覆盖原有内容和事件缺点：后添加的事件没有事件【新添加的元素再设置一个事件】:如果后添加的元素没有设置事件，只添加元素，后来的是没有事件的，如果添加事件后再添加，可以有事件。 性能问题 innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。 可以借助字符串或数组的方式进行替换，再设置给innerHTML 优化后与document.createElement性能相近 12345- innerHTML 会产生字符串解析，由于字符串的不可变性，尽量避免大量的拼接，否则消耗内存，影响性能。- document.createElement(&apos;标签&apos;)创建的性能要比innerHTML要高，但是若涉及到多层嵌套内容时，代码操作麻烦。- 所以，一般情况下,两者配合使用较多 - document.createElement用来创建元素 - innerHTML可以设置元素中的内容（元素内部的标签或文本） 1234567总结：innerHTML:往页面中添加元素时，会把页面中原来的元素覆盖掉使用innerHTML添加元素，页面中如果有事件，原来的事件也会消失 ① 重新设置ul的innerHTML时，若不拼接，则会覆盖原有的内容。 ② 会覆盖之前原有的子元素的是事件解决：用第二种创建方式通过document.createElement创建元素，原来的元素的事件存在，后来添加的元素没有事件，除非给新元素添加事件。 案例 动态创建列表，高亮显示 根据数据动态创建表格 模拟百度搜索文本框 点击按钮创建一个li追加到ul中 遍历一组对象 根据一组数据，动态生成表格，并实现删除功能。 把一个下拉列表中所有的option移动的另一个下拉列表中 获取已经选中的option 权限选择 节点操作追加、删除，插入、替换节点123456789++ 追加元素 父节点.appendChild(子元素)++ 删除元素 父节点.removeChild(子元素)++ 插入元素 父元素.insertBefore(新的节点，旧的节点) 将一个新的节点插入到父节点中的某个子节点的前面++ 替换元素 父节点.replaceChild(新的子节点,旧的子节点) 节点层级获取重点讲父子属性，兄弟属性画图讲解 12345678910111213141516box.parentElement 获取当前节点的父级元素box.parentNode 获取一个节点的父节点box.childNodes 获取子节点box.children 获取子元素box.nextSibling 获取下一个兄弟节点box.nextElementSibling 获取下一个兄弟元素box.previousSibling 获取上一个兄弟节点box.previousElementSibling; 获取第一个孩子元素box.firstChild 获取第一个孩子节点box.firstElementChild 获取第一个孩子元素box.lastChild 获取最后一个孩子节点box.lastElementChild 获取最后一个孩子元素在IE8中： 子节点是子元素，子元素是undefined 谷歌、火狐都支持 注意 childNodes和children的区别，childNodes获取的是子节点，children获取的是子元素 nextSibling和previousSibling获取的是节点，获取元素对应的属性是nextElementSibling和previousElementSibling获取的是元素 ​ nextElementSibling和previousElementSibling有兼容性问题，IE9以后才支持 总结 1234567891011节点操作，方法 appendChild() insertBefore() removeChild() replaceChild()节点层次，属性 parentNode childNodes children nextSibling/previousSibling firstChild/lastChild 节点nodeType、nodeName、nodeValue123nodeType：标签→1 属性：2 文本→3nodeValue：标签→null 属性：属性值 文本：文本值-nodeName含义：标签：大写 属性：小写 文本：#text 案例案例1：点击按钮创建一个li追加到ul中 案例2：遍历一组对象。 案例3：根据一组数据，动态生成表格，并实现删除功能。 案例5：把一个下拉列表中所有的option移动的另一个下拉列表中 案例6：获取已经选中的option 案例7：权限选择 事件监听事件监听可以给元素绑定多个事件处理程序。在实际开发中， 便于对事件程序的功能扩展。 事件目标：也被称为 事件源，指的是要注册事件的那个元素节点。 事件类型：指的是什么样的行为，如：鼠标点击、鼠标移入和移出、鼠标移动、键盘按下等等。 onclick 鼠标点击事件 onchange 表单元素内容方式改变时→ 下拉框 onfocus 文本框获取焦点事件 onblur 文本框失去焦点事件 onmouseover 鼠标进入 onmouseout 鼠标离开 onkeyup 键盘抬起 onmousemove鼠标移动 onscroll 滚动事件 onmousedown 鼠标按下事件 onmouseenter 鼠标进入元素事件 onmouseleave 鼠标离开元素事件 oninput 输入框输入事件→ 文本框、文本域 事件处理程序：事件触发后要执行的代码，用 函数表示。函数体中的代码，在事件触发后执行。 注册/移除事件的三种方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var box = document.getElementById('box');第一种注册事件的方式box.onclick = function () &#123; console.log('点击后执行');&#125;;缺点： - 如果使用onclick来注册多个事件，后面的事件会 把原来的事件覆盖掉 - 解决方案：使用时间监听来注册事件第一种移除事件的方式box.onclick = null;第二种注册事件方式：事件监听注册事件/* IE8不支持，谷歌、火狐支持 功能：给元素注册事件 参数： 事件类型 字符串 注意：事件名不加on 如 'click' 事件处理程序 函数 是否捕获：可选，默认为false ， true表示启用捕获 false表示启用冒泡*/事件目标.addEventListener(事件类型【没有on】,事件处理程序,是否捕获);box.addEventListener('click', eventCode, false);addEventListener注册事件不会覆盖，只会在原有事件上添加新的功能，不会覆盖。第二种移除事件的方式：/* 功能：移除元素的指定事件程序 参数： 事件类型 字符串 注意：事件名不加on 如：'click' 事件处理程序：函数 注意：这里要把函数名传入过来*/事件目标.removeEventListener(事件类型【没有on】,事件处理程序名称,false);box.removeEventListener('click', eventCode, false);第三种注册事件的方式：/* 谷歌、火狐不支持，IE8支持 功能：给元素注册事件 参数： 事件类型 字符串 注意：事件名加on 如 'onclick' 事件处理程序 函数*/事件目标.attachEvent(事件类型,事件处理程序);box.attachEvent('onclick', eventCode);第二种移除事件的方式：/* 功能：移除元素的指定事件程序 参数： 事件类型 字符串 注意：事件名加on 如：'click' 事件处理程序：函数 注意：这里要把函数名传入过来*/事件目标.detachEvent(事件类型,事件处理程序名称);box.detachEvent('onclick', eventCode); 为元素绑定事件的兼容代码12345678910111213141516171819function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent)&#123; element.attachEvent('on' + type,fn); &#125; else &#123; element['on'+type] = fn; &#125;&#125;function removeEventListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, fn); &#125; else &#123; element['on'+type] = null; &#125;&#125; 面试绑定事件的区别123456789相同点： 都可以为元素绑定事件不同点： 方法名不同 参数个数不同 浏览器支持不同 事件类型：事件名不同（有on无on） this不同：addEventListener：当前绑定事件的对象 attachEvent：window 事件的三个阶段 事件捕获阶段 从外到里 true 事件目标阶段 事件冒泡阶段 从里到外 false 事件对象.eventPhase属性可以查看事件触发时所处的阶段 面试：事件几个阶段 分别是 绑定事件3种方式 特点 事件对象的属性和方法 event.type 获取事件类型 clientX/clientY 可视区域的横纵坐标 offsetX/offsetY 鼠标在指定的元素的区域中的坐标 pageX/pageY 获取鼠标在整个文档区域中的坐标 pageX/pageY IE8以前不支持，页面位置 event.target || event.srcElement 用于获取触发事件的元素 event.preventDefault() 阻止默认事件 return false 阻止事件冒泡 e.stopPropagation(); window.event.cancelBubble = true; 案例 跟着鼠标飞的天使 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; width: 200px; position: absolute; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;bird.png&quot; alt=&quot;&quot;&gt; &lt;script&gt; var im = document.querySelector(&quot;img&quot;); document.onmousemove = function(e)&#123; im.style.left = e.clientX -100 + &quot;px&quot;; im.style.top = e.clientY -100+ &quot;px&quot;; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 鼠标点哪图片飞到哪里 获取鼠标在div内的坐标 冒泡事件多个元素嵌套，有层次关系，这些元素都注册了相同事件，如果里面的事件触发，外面的事件也会触发 阻止事件传播的方式 标准方式 event.stopPropagation(); 谷歌、火狐支持 IE低版本 window.event.cancelBubble = true; 标准中已废弃 谷歌、IE8支持,火狐不支持 常用的鼠标和键盘事件 onmouseup 鼠标按键放开时触发 onmousedown 鼠标按键按下触发 onmousemove 鼠标移动触发 onkeyup 键盘按键按下触发 onkeydown 键盘按键抬起触发 键盘事件对象的属性 事件对象.altKey 作用：检测是否按下键盘上的 Alt键。 按下返回 true 代码： 123document.onkeydown = function (e) &#123; alert(e.altKey); // 按下alt键，返回true &#125; 事件对象.ctrlKey 作用：检测是否按下键盘上的 Ctrl键。 按下返回 true 代码： 12document.onkeydown = function (e) &#123; alert(e.ctrlKey); // 按下Ctrl键，返回true 事件对象.shiftKey 作用：检测是否按下键盘上的 Shift键。 按下返回 true 代码： 123document.onkeydown = function (e) &#123; alert(e.shiftKey); // 按下shift键，返回true &#125; *事件对象.keyCode** 作用：返回被敲击的键生成的 Unicode 字符码(ascii码) 代码： 123document.onkeydown = function (e) &#123; alert(e.keyCode); // 返回ascii码表对应的十进制的数字 &#125; 兼容问题获取事件对象 标准方式： 事件处理程序函数的第一个参数 e IE低版本方式：window.event 兼容处理： 1234document.onclick = function (e) &#123; // 事件对象的兼容处理 var _event = e || window.event; &#125;; 为同一个元素绑定多个事件执行同一个事件处理函数12345678910111213141516btn.onclick = f1;btn.onmouseover = f1;btn.onmouseout = f1;function f1(e)&#123; switch(e.type)&#123; case &apos;click&apos;: alert(&apos;sdaf&apos;); break; case &apos;mouseenter&apos;: alert(&apos;sdaf&apos;); break; case &apos;mouseout&apos;: alert(&apos;sdaf&apos;); break; &#125;&#125; 案例案例1：鼠标跟着图片走 案例2：拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142按下div onmousedown 在文档中移动 document.onmousemove 在div中弹起 onmouseup document.onmousemove事件解绑 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 80px; line-height: 80px; text-align: center; background: red; border: 1px solid skyblue; position: absolute; user-select: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;webqianduan&lt;/div&gt; &lt;script&gt; var dv = document.querySelector(&quot;div&quot;); dv.onmousedown = function(e)&#123; var spaceX = e.offsetX; var spaceY = e.offsetY; document.onmousemove = function(e)&#123; dv.style.left = e.clientX - spaceX+ &quot;px&quot;; dv.style.top = e.clientY - spaceY + &quot;px&quot;; console.log(e.offsetX); console.log(e.offsetY); &#125; &#125; dv.onmouseup = function(e)&#123; document.onmousemove = null; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 案例3：获取元素样式属性的left和top值 案例4：愤怒的小鸟，键盘控制 特效偏移量 offsetParent用于获取定位的父级元素 offsetParent和parentNode的区别 123456var box = document.getElementById('box');console.log(box.offsetParent);console.log(box.offsetLeft);console.log(box.offsetTop);console.log(box.offsetWidth);console.log(box.offsetHeight); 客户区大小12345var box = document.getElementById('box');console.log(box.clientLeft);console.log(box.clientTop);console.log(box.clientWidth);console.log(box.clientHeight); 滚动偏移12345var box = document.getElementById('box');console.log(box.scrollLeft)console.log(box.scrollTop)console.log(box.scrollWidth)console.log(box.scrollHeight) 案例 匀速动画函数 变速动画函数 回到顶部 无缝轮播图 模拟滚动条 拖拽案例 放大镜案例 附录元素的类型 关于性能1.精灵图2.document.createElement的执行速度比innerHTML快 兄弟选择器1234最终美化的是li,但是条件是li之前必须有一个同级的兄弟也是li.不包括第一个。li + li &#123; margin-top: 10px;&#125; for循环 和 for-in循环的区别 for循环：一般用来遍历数组或伪数组。 for-in循环：用来遍历对象。 注意：对象不能用for循环遍历，因为对象中的数据是无序的。 12345678910111213var obj = &#123; pid: 10001, pName: &apos;自行车&apos;, price: 100, count: 10 &#125;; /* // key表示对象中的某一个属性名→键名→字符串 for(var key in 对象) &#123; // 循环体 // 对象[&apos;键名&apos;] // 对象[key]; 取出属性对应的值 !!!注意：千万不要用 对象.key &#125; */ for(var key in obj) &#123; // console.log(obj.key); // undefined console.log(obj[key]); // 正确方式 输入框输入事件123456789101112oninput事件 ，用户输入时的一个行为会被检测一般设置给文本框或文本域输入框输入事件&lt;input type=&quot;text&quot;&gt;&lt;script&gt; var input =document.querySelector(&apos;input&apos;); // 注册事件 input.oninput = function() &#123; // this → 输入框 console.log(this.value); &#125;;&lt;/script&gt; 属性：用户不能选中文字1user-select:none; 轮播图简单轮播图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261.//封装动画函数----匀速的// 封装动画函数var timeId;function move(element,target)&#123; clearInterval(timeId); timeId = setInterval(function()&#123; // 获取当前的位置 var current = element.offsetLeft; var step = (target - current)/10; step = target - current &gt; 0 ? Math.ceil(step): Math.floor(step); if(Math.abs(current - target) &gt; Math.abs(step) )&#123; element.style.left = (current + step) + &apos;px&apos;; &#125;else &#123; element.style.left = target + &apos;px&apos;; clearInterval(timeId); &#125; &#125;,50);&#125;2.简单轮播图实现&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; text-decoration: none; &#125; #dv &#123; width: 730px; height: 454px; margin: 20px auto; overflow: hidden; position: relative; &#125; .img &#123; width: 600%; position: absolute; &#125; .img li &#123; float: left; list-style: none; &#125; .circle &#123; position: absolute; bottom: 10px; left: 50%; margin-left: -100px; width: 200px; height: 30px; background: rgba(255,255,255, 0.5); &#125; .circle li &#123; width: 20px; height: 20px; background: #000; float: left; margin: 5px 6px 0; border-radius: 50%; &#125; li.current &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&apos;dv&apos;&gt; &lt;ul class=&apos;img&apos;&gt; &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;circle&quot;&gt; &lt;li class=&apos;current&apos;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; 获取移动的ul var ulimg = document.getElementsByClassName(&apos;img&apos;)[0]; 获取div的宽度（一张图片的宽度） var imgWidth = document.getElementById(&apos;dv&apos;).offsetWidth; // 获取小圆点 var list = document.querySelectorAll(&apos;.circle li&apos;); for(var i = 0; i &lt; list.length; i++)&#123; list[i].index = i; list[i].onmouseenter = function()&#123; for(var j = 0; j &lt; list.length; j++)&#123; list[j].className = &apos;&apos;; &#125; this.className = &apos;current&apos;; // 获取对应的索引 var index = this.index; move(ulimg, -index*imgWidth); &#125; &#125; // 封装动画函数 var timeId; function move(element,target)&#123; clearInterval(timeId); timeId = setInterval(function()&#123; // 获取当前的位置 var current = element.offsetLeft; var step = (target - current)/10; step = target - current &gt; 0 ? Math.ceil(step): Math.floor(step); if(Math.abs(current - target) &gt; Math.abs(step) )&#123; element.style.left = (current + step) + &apos;px&apos;; &#125;else &#123; element.style.left = target + &apos;px&apos;; clearInterval(timeId); &#125; &#125;,50); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 左右焦点轮播图1234567891011121314点击右边的按钮var index = 0;right.onclick = function()&#123; if(index &lt; lilist.length - 1)&#123; index++; animation(ulimg,-index.imgWidth); &#125;&#125;left.onclick = function()&#123; if(index &gt; 0)&#123; index--; animation(ulimg,-index.imgWidth); &#125;&#125; 无缝连接的轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; img &#123; vertical-align: top; &#125; /*取消图片底部3像素距离*/ .box &#123; width: 300px; height: 200px; margin: 100px auto; background-color: pink; border: 1px solid red; position: relative; overflow: hidden; &#125; .box ul li &#123; float: left; &#125; .box ul &#123; width: 1500px; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot; id=&quot;screen&quot;&gt; &lt;ul&gt; &lt;li id=&quot;li1&quot;&gt;&lt;img src=&quot;imagess/01.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/02.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/03.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/04.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/01.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function animate(element,target) &#123; clearInterval(element.setId); element.setId=setInterval(function () &#123; //获取元素的当前的位置 var current=element.offsetLeft;//数字类型的 //每次移动的步数 var step=10; step=current&lt;target?step:-step; //设置当前位置的值 current+=step; if(Math.abs(current-target)&gt;Math.abs(step))&#123; element.style.left=current+&quot;px&quot;; &#125;else&#123; element.style.left=target+&quot;px&quot;; //到达目标,清理计时器 clearInterval(element.setId); &#125; &#125;,10); &#125; var ulObj=my$(&quot;screen&quot;).children[0]; function f1() &#123; //当前位置 var current=ulObj.offsetLeft; current-=10;//每次移动后的位置 if(current&lt;-1200)&#123;//判断界限 ulObj.style.left=&quot;0px&quot;; &#125;else&#123; ulObj.style.left=current+&quot;px&quot;; &#125; &#125; var timeId=setInterval(f1,10); my$(&quot;screen&quot;).onmouseover=function () &#123; clearInterval(timeId); &#125;; my$(&quot;screen&quot;).onmouseout=function () &#123; timeId=setInterval(f1,10); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 鸠摩搜索 javascript王者归来Day01JavaScript组成ECMAscript:JS的基础语法 DOM: document oject model 文档对象模型 操作页面元素 BOM:browser object model 浏览器对象模型 操作浏览器元素 节点：页面中所有的内容都是节点，标签、属性和文本 innerText和textContent凡是成对的标签，中间的文本设置的时候都使用innerText这个属性的方式 css属性是多个单词的写法，在js中DOM操作时，去掉-,后面单词大写即可。 background-color: backgroundColor 1234567891011121314151617181920设置任意标签中间的任意内容function setInnerText(ele,text)&#123; if(typeof ele.textContent == &apos;undefined&apos;)&#123; ele.innerText = text; &#125;else&#123; ele.textContent = text; &#125;&#125;获取任意标签中间的任意内容function getInnerText(ele)&#123; if(typeof ele.textContent == &apos;undefined&apos;)&#123; return ele.innerText; &#125;else&#123; return ele.textContent; &#125;&#125;①设置标签中的内容，使用textContent属性，谷歌、火狐支持，IE8不支持②设置标签中的内容，使用innerText属性，谷歌、火狐、IE8都支持③如果这个属性在浏览器中不支持，那么这个属性的类型为undefined innerText和innerHTML1234561)使用innerText主要设置文本，设置标签内容，没有标签效果2）使用innerHTML可以设置标签，可以设置文本，3）innerHTML:都支持4）总结： 设置文本：innerText textContent innerHTML 设置标签：innerHTML 封装节点兼容代码案例模拟搜索框tab栏切换123456789101112131415161718192021222324252627// 1. 获取一组livar lis = document.querySelectorAll(&apos;.tab-control li&apos;);// 2. 获取一组div显示项var divs = document.querySelectorAll(&apos;.tab-content-item&apos;);// 3. for循环遍历给每一个li注册一个点击事件，给每一个li添加一个index属性，表示li的下标for (var i = 0; i &lt; lis.length; i++) &#123; // 3.1 给每一个li添加一个index属性 lis[i].index = i; // 3.2 注册事件 lis[i].onclick = function () &#123; // this 当前触发的li， // alert(this.index); // 4. 在事件处理程序中，① 切换li ② 切换div // 4.1 循环遍历去掉所有li 和 所有div的类名active for (var j = 0; j &lt; lis.length; j++) &#123; lis[j].className = &apos;&apos;; divs[j].className = &apos;tab-content-item&apos;; &#125; // 4.2 给当前点击的li添加类名active this.className = &apos;active&apos;; // 4.3 获取当前点击的li的下标 var num = this.index; // 找到对应的div项，显示 divs[num].className = &apos;tab-content-item active&apos;; &#125;;&#125; 案例全选和全不选123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; id=&quot;j_cbAll&quot; /&gt; &lt;/th&gt; &lt;th&gt;商品&lt;/th&gt; &lt;th&gt;价钱&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;j_tb&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;iPhone8&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;iPad Pro&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;iPad Air&lt;/td&gt; &lt;td&gt;2000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;Apple Watch&lt;/td&gt; &lt;td&gt;2000&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;input type=&quot;button&quot; value=&quot; 反 选 &quot; id=&quot;btn&quot;&gt; &lt;/div&gt; &lt;!-- 引入js --&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;index.css* &#123; padding: 0; margin: 0;&#125;.wrap &#123; width: 300px; margin: 100px auto 0;&#125;table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 300px;&#125;th,td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px;&#125;th &#123; background-color: #09c; font: bold 16px &quot;微软雅黑&quot;; color: #fff;&#125;td &#123; font: 14px &quot;微软雅黑&quot;;&#125;tbody tr &#123; background-color: #f0f0f0;&#125;tbody tr:hover &#123; cursor: pointer; background-color: #fafafa;&#125;index.js// 1. 获取thead中的多选框var ck = document.querySelector(&apos;thead input&apos;);// 2. 获取tbody中的一组多选框var cks = document.querySelectorAll(&apos;tbody input&apos;);// 3. 获取反选按钮var btn = document.querySelector(&apos;#btn&apos;);//【功能1：点击thead中的多选框控制tbody中的一组多选框状态】// 1.1 给ck注册点击事件ck.onclick = function () &#123; // 1.2 在事件处理程序中，获取ck的checked var flag = this.checked; // 1.3 循环遍历cks中的每一个多选框，把ck的checked值覆盖给每一个 for (var i = 0; i &lt; cks.length; i++) &#123; cks[i].checked = flag; &#125;&#125;;//【功能2：点击反选按钮控制tbody中的一组多选框，选中的变为不选中，不选中的变为选中】// 1. 给反选按钮注册事件btn.onclick = function () &#123; // 2. 循环遍历cks中每一个多选框 for (var i = 0; i &lt; cks.length; i++) &#123; // 3. 取出每一个多选框的checked值取反，然后再重新赋值给每一个多选框的checked var flag = cks[i].checked; cks[i].checked = !flag; &#125; // 检测 check();&#125;;//【功能3：点击tbody中的某一个多选框时，检测并控制thead中的多选框是否选中】// 1. 循环遍历给tbody中每一个多选框注册点击事件for (var i = 0; i &lt; cks.length; i++) &#123; cks[i].onclick = function () &#123; // 检测 check(); &#125;;&#125;// 封装检测thead多选框是否选中function check() &#123; // 2. 在事件处理程序中，获取已经选中的多选框的个数 var len1 = document.querySelectorAll(&apos;tbody input:checked&apos;).length; // 3. 获取tbody中所有的多选框的个数 var len2 = cks.length; // 4. 比较是否相等，相等则设置ck的checked为true，否则为false if (len1 == len2) &#123; ck.checked = true; &#125; else &#123; ck.checked = false; &#125;&#125;; 百度大项目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #box &#123; width: 450px; margin: 200px auto; &#125; #txt &#123; width: 350px; &#125; #pop &#123; width: 350px; border: 1px solid red; &#125; #pop ul &#123; margin: 10px; padding: 0px; width: 200px; list-style-type: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot; value=&quot;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索&quot; id=&quot;btn&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var keyWords = [&quot;小杨才是最纯洁的&quot;, &quot;小杨才是最帅的&quot;, &quot;小段是最猥琐的&quot;, &quot;小超是最龌龊的&quot;, &quot;传智播客是一个培训机构&quot;, &quot;传说在传智有个很帅很纯洁的小杨&quot;, &quot;苹果好吃&quot;, &quot;苹果此次召回还是没有中国&quot;]; //获取文本框注册键盘抬起事件 my$(&quot;txt&quot;).onkeyup = function () &#123; //每一次的键盘抬起都判断页面中有没有这个div if(my$(&quot;dv&quot;))&#123; //删除一次 my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;)); &#125; //获取文本框输入的内容 var text = this.value; //临时数组--空数组-------&gt;存放对应上的数据 var tempArr = []; //把文本框输入的内容和数组中的每个数据对比 for (var i = 0; i &lt; keyWords.length; i++) &#123; //是否是最开始出现的 if (keyWords[i].indexOf(text) == 0) &#123; tempArr.push(keyWords[i]);//追加 &#125; &#125; //如果文本框是空的,临时数组是空的,不用创建div if (this.value.length == 0 || tempArr.length == 0) &#123; //如果页面中有这个div,删除这个div if (my$(&quot;dv&quot;)) &#123; my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;)); &#125; return; &#125; //创建div,把div加入id为box的div中 var dvObj = document.createElement(&quot;div&quot;); my$(&quot;box&quot;).appendChild(dvObj); dvObj.id = &quot;dv&quot;; dvObj.style.width = &quot;350px&quot;; //dvObj.style.height=&quot;100px&quot;;//肯定是不需要的------ dvObj.style.border = &quot;1px solid green&quot;; //循环遍历临时数组,创建对应的p标签 for (var i = 0; i &lt; tempArr.length; i++) &#123; //创建p标签 var pObj = document.createElement(&quot;p&quot;); //把p加到div中 dvObj.appendChild(pObj); setInnerText(pObj, tempArr[i]); pObj.style.margin = 0; pObj.style.padding = 0; pObj.style.cursor = &quot;pointer&quot;; pObj.style.marginTop = &quot;5px&quot;; pObj.style.marginLeft = &quot;5px&quot;; //鼠标进入 pObj.onmouseover = function () &#123; this.style.backgroundColor = &quot;yellow&quot;; &#125;; //鼠标离开 pObj.onmouseout = function () &#123; this.style.backgroundColor = &quot;&quot;; &#125;; &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 放大镜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;base.css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;fdj&quot;&gt; &lt;!-- 左侧 --&gt; &lt;div class=&quot;leftBox&quot; id=&quot;_leftBox&quot;&gt; &lt;!-- 小图 --&gt; &lt;img src=&quot;img/m.jpg&quot; alt=&quot;&quot;/&gt; &lt;!-- 小黄盒子 --&gt; &lt;div class=&quot;tool&quot; id=&quot;_tool&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 右侧 --&gt; &lt;div class=&quot;rightBox&quot; id=&quot;_rightBox&quot;&gt; &lt;img id=&quot;_bImg&quot; src=&quot;img/b.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 引入的外部js程序文件 --&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;index.css* &#123; margin:0; padding:0;&#125;.w &#123; width: 1190px; margin: 0 auto;&#125;.fdj &#123; margin-top: 20px;&#125;.fdj .leftBox &#123; width: 400px; height: 400px; border: 1px solid #ccc; float: left; position: relative; overflow: hidden;&#125;.fdj .tool &#123; width: 250px; height: 250px; background:gold; opacity:.5; position: absolute; top:0; left: 0; cursor: move; /* 默认隐藏 */ display: none;&#125;/* 给小黄加上active 就会显示 */.fdj .tool.active &#123; display: block;&#125;.fdj .rightBox &#123; width: 500px; height: 500px; border:1px solid #ccc; float: left; overflow: hidden; /* 隐藏 */ display: none; position: relative;&#125;/* 加上active表示显示 */.fdj .rightBox.active &#123; display: block;&#125;.fdj .rightBox img &#123; position: absolute;&#125;index.js 定时器案例1234567891011121314151617181920212223242526272829function getTime(d1,d2)&#123; var time = d2-d1; var hour = parseInt(time/1000/60/60); var minu = parseInt(time/1000/60%60); var second = parseInt(time/1000%60); hour = hour &lt; 10 ? &quot;0&quot;+hour:hour; minu = minu &lt; 10 ? &quot;0&quot;+minu:minu; second = second &lt; 10 ? &quot;0&quot;+second :second; return &#123; hour:hour, minu:minu, second:second &#125;;&#125; function getDate()&#123; var d1 = new Date(); var d2 = new Date(&quot;2018/9/19 10:30:00&quot;); var time = getTime(d1,d2); span1.innerText = time.hour; span2.innerText = time.minu; span3.innerText = time.second; &#125; getDate(); var num = setInterval(function()&#123; getDate(); if(time.hour==&quot;00&quot;&amp;&amp;time.minu==&quot;00&quot;&amp;&amp;time.second==&quot;00&quot;)&#123; clearInterval(num); &#125; &#125;,1000); 固定导航栏回到顶部轮播图获取样式121)如果样式的代码是在style标签中设置的，外面获取不到。2）如果样式的代码是在style的属性中设置的，外面可以获取到 动画函数：任意一个元素移动到指定位置123456789101112131415function animation (element,target)&#123; clearInterval(element.timeId); element.timeId = setInterval(function()&#123; var current = element.offsetLeft; var step = 10; step = current &lt; target ? step:-step; current += step; if(Math.abs(target-current) &gt; Math.abs(step))&#123; element.style.left = current + &apos;px&apos;; &#125;else&#123; clearInterval(element.timeId); element.style.left = target + &apos;px&apos;; &#125; &#125;,20);&#125; 变速动画函数封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function animation (element,target)&#123; clearInterval(element.timeId); element.timeId = setInterval(function()&#123; var current = element.offsetLeft; var step = (target - current)/10; step = step &gt; 0? Math.ceil(step):Math.floor(step); current += step; if(Math.abs(target-current) &gt; Math.abs(step))&#123; element.style.left = current + &apos;px&apos;; &#125;else&#123; clearInterval(element.timeId); element.style.left = target + &apos;px&apos;; &#125; &#125;,20);&#125;第二种：思想相同function move(element, targetValue, speed) &#123; // 3.1 清除旧的定时器 clearInterval(num); // 4. 时间控制：产生一个定时器 num = setInterval(function () &#123; // 4.1 获取div原有的left值 var v = element.offsetLeft; // 4.1.1 判断是否到达目标 if (v == targetValue) &#123; // 4.1.2 清除定时器 clearInterval(num); // 4.1.2 结束本次函数的执行 return; &#125; // 4.2 在原有基础上+speed或-speed if (Math.abs(targetValue - v) &lt; speed) &#123; // 是最后一步 element.style.left = targetValue + &apos;px&apos;; &#125; else &#123; // 不是最后一步 if (targetValue &gt; v) &#123; v = v + speed; &#125; else &#123; v = v - speed; &#125; // 4.3 重新赋值给div的left样式属性 element.style.left = v + &apos;px&apos;; &#125; &#125;, 10);&#125;; 新版动画函数封装123456789101112131415161718192021222324252627282930313233/* 功能：动画 参数： element 要运动的元素 元素对象 targetValue 目标值 数字 speed 速度（步长） 数字*/function move(element, targetValue) &#123; // 3.1 清除旧的定时器 clearInterval(element.num); // 4. 时间控制：产生一个定时器 element.num = setInterval(function () &#123; // 4.1 获取div原有的left值 var v = element.offsetLeft; // 4.1.1 判断是否到达目标 if (v == targetValue) &#123; // 4.1.2 清除定时器 clearInterval(element.num); // 4.1.2 结束本次函数的执行 return; &#125; // 缓冲的公式 var speed = (targetValue - v) / 10; // 检测方向 if (targetValue &gt; v) &#123; speed = Math.ceil(speed); &#125; else &#123; speed = Math.floor(speed); &#125; //设置物体的位置 element.style.left = v + speed + &apos;px&apos;; &#125;, 10);&#125;; 获取元素计算后的样式属性值12345678910111213获取任意一个元素的任意一个样式属性值的当前值function getStyle(element,attr)&#123; 判断浏览器是否支持这个方法 if(window.getComputedStyle)&#123; return window.getComputedStyle(element,null)[attr]; &#125;else&#123; return element.currentStyle[attr]; &#125;&#125;function getStyle(element,attr)&#123; return window.getComputedStyle?window.ComputedStyle(element,null)[attr]:element.currentStyle[attr]||0;&#125; 封装动画函数增加任意一个属性123456789101112131415161718192021//获取任意的一个属性的当前的属性值: left---&gt;此时的left属性的值,width---当前的元素的宽function getStyle(element,attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr];&#125;function animate(element,attr ,target) &#123; //清理定时器 clearInterval(element.timeId); element.timeId = setInterval(function () &#123; //获取元素的当前位置 var current = parseInt(getStyle(element,attr));//数字类型//== //移动的步数 var step = (target-current)/10; step = step&gt;0?Math.ceil(step):Math.floor(step); current += step; element.style[attr] = current + &quot;px&quot;; if(current==target) &#123; //清理定时器 clearInterval(element.timeId); &#125;&#125; 封装动画函数增加任意多个属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin-top: 30px; width: 200px; height: 100px; background-color: green; position: absolute; left:0; top:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;移动到400px&quot; id=&quot;btn1&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //点击按钮,改变宽度到达一个目标值,高度到达一个目标值 //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值 function getStyle(element,attr) &#123; return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr]||0; &#125; function animate(element,json) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; var flag=true;//默认,假设,全部到达目标 for(var attr in json)&#123; //获取元素这个属性的当前的值 var current=parseInt(getStyle(element,attr)); //当前的属性对应的目标值 var target=json[attr]; //移动的步数 var step=(target-current)/10; step=step&gt;0?Math.ceil(step):Math.floor(step); current+=step;//移动后的值 element.style[attr]=current+&quot;px&quot;; if(current!=target)&#123; flag=false; &#125; &#125; if(flag)&#123; //清理定时器 clearInterval(element.timeId); &#125; //测试代码 console.log(&quot;目标:&quot;+target+&quot;,当前:&quot;+current+&quot;,每次的移动步数:&quot;+step); &#125;,20); &#125; my$(&quot;btn1&quot;).onclick=function () &#123; animate(my$(&quot;dv&quot;),&#123;&quot;width&quot;:400,&quot;height&quot;:500,&quot;left&quot;:500,&quot;top&quot;:80&#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装动画函数增加任意多个属性和回调函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin-top: 30px; width: 200px; height: 100px; background-color: green; position: absolute; left:0; top:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;移动到400px&quot; id=&quot;btn1&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //点击按钮,改变宽度到达一个目标值,高度到达一个目标值 //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值 function getStyle(element,attr) &#123; return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr]||0; &#125; //element---元素 //json---对象---多个属性及多个目标值 //fn---函数 function animate(element,json,fn) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; var flag=true;//默认,假设,全部到达目标 for(var attr in json)&#123; //获取元素这个属性的当前的值 var current=parseInt(getStyle(element,attr)); //当前的属性对应的目标值 var target=json[attr]; //移动的步数 var step=(target-current)/10; step=step&gt;0?Math.ceil(step):Math.floor(step); current+=step;//移动后的值 element.style[attr]=current+&quot;px&quot;; if(current!=target)&#123; flag=false; &#125; &#125; if(flag)&#123; //清理定时器 clearInterval(element.timeId); //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数 if(fn)&#123; fn(); &#125; &#125; //测试代码 console.log(&quot;目标:&quot;+target+&quot;,当前:&quot;+current+&quot;,每次的移动步数:&quot;+step); &#125;,20); &#125; my$(&quot;btn1&quot;).onclick=function () &#123; var json1=&#123;&quot;width&quot;:400,&quot;height&quot;:500,&quot;left&quot;:500,&quot;top&quot;:80&#125;; animate(my$(&quot;dv&quot;),json1,function () &#123; var json2=&#123;&quot;width&quot;:40,&quot;height&quot;:50,&quot;left&quot;:50,&quot;top&quot;:800&#125;; animate(my$(&quot;dv&quot;),json2,function () &#123; var json3=&#123;&quot;width&quot;:450,&quot;height&quot;:550,&quot;left&quot;:550,&quot;top&quot;:600&#125;; animate(my$(&quot;dv&quot;),json3); &#125;); &#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装动画函数增加任意多个属性和回调函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 200px; height: 100px; background-color: green; position: absolute; left: 0; top: 0; &#125; input &#123; z-index: 10; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;移动到400px&quot; id=&quot;btn1&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //点击按钮,改变宽度到达一个目标值,高度到达一个目标值 //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值 function getStyle(element, attr) &#123; return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr] || 0; &#125; function animate(element, json, fn) &#123; clearInterval(element.timeId);//清理定时器 //定时器,返回的是定时器的id element.timeId = setInterval(function () &#123; var flag = true;//默认,假设,全部到达目标 //遍历json对象中的每个属性还有属性对应的目标值 for (var attr in json) &#123; //判断这个属性attr中是不是opacity if (attr == &quot;opacity&quot;) &#123; //获取元素的当前的透明度,当前的透明度放大100倍 var current = getStyle(element, attr) * 100; //目标的透明度放大100倍 var target = json[attr] * 100; var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step;//移动后的值 element.style[attr] = current / 100; &#125; else if (attr == &quot;zIndex&quot;) &#123; //判断这个属性attr中是不是zIndex //层级改变就是直接改变这个属性的值 element.style[attr] = json[attr]; &#125; else &#123; //普通的属性 //获取元素这个属性的当前的值 var current = parseInt(getStyle(element, attr)); //当前的属性对应的目标值 var target = json[attr]; //移动的步数 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step;//移动后的值 element.style[attr] = current + &quot;px&quot;; &#125; //是否到达目标 if (current != target) &#123; flag = false; &#125; &#125; if (flag) &#123; //清理定时器 clearInterval(element.timeId); //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数 if (fn) &#123; fn(); &#125; &#125; //测试代码 console.log(&quot;目标:&quot; + target + &quot;,当前:&quot; + current + &quot;,每次的移动步数:&quot; + step); &#125;, 20); &#125; //zIndex:1000 //透明度: 数字类型----小数---放大100倍 my$(&quot;btn1&quot;).onclick = function () &#123; var json1 = &#123;&quot;width&quot;: 400, &quot;height&quot;: 500, &quot;left&quot;: 500, &quot;top&quot;: 80, &quot;opacity&quot;: 0.2&#125;; animate(my$(&quot;dv&quot;), json1, function () &#123; animate(my$(&quot;dv&quot;), &#123;&quot;width&quot;: 40, &quot;height&quot;: 50, &quot;left&quot;: 0, &quot;top&quot;: 0, &quot;opacity&quot;: 1, &quot;zIndex&quot;: 1000&#125;); &#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动画函数封装注意问题1234567891011121314// 问题1：多次点击按钮时，盒子的运动节奏混乱（加快）。// 原因：每次点击按钮会产生一个定时器操作div,多次点击会产生多个定时器操作div，速度会叠加。// 解决：保证始终只有一个定时器操作元素// 问题2：盒子无休止的运动。// 原因： 因为没有设置目标值// 解决：在+10之前，应该判断是否到达目标，若到达目标，则先清除定时器，而且要结束本次函数的执行。//问题3：盒子反方向运动解决：判断当前值与目标值：当前值&gt;目标值 - ，反之，+//问题4：判断是不是最后一步解决：判断当前值-目标值的绝对值 是不是大于每次增加的步数 三大系列offset系列:返回数字，不含单位1234567offsetWidth:获取元素的宽度(有边框) 内容宽度+padding+borderoffsetHeight:获取元素的高度（有边框）offsetLeft: 不脱标情况下：包括父级元素的margin+padding+border+自己的margin 脱标情况下：与父级元素没有关系（只是相对于父级元素）,只与自己的margin有关系offsetTop:同上offsetParent:获取元素的最近定位的上级元素，如果没有定位的上级元素，获取body scroll系列1234scrollWidth:元素中内容的实际的宽(没有边框),如果没有内容就是元素的宽 内容+padding,返回数字，没有单位scrollHeight:元素中内容的实际的高(没有边框),如果没有内容就是元素的高scrollTop:向上卷曲出去的距离scrollLeft:向左卷曲出去的距离 client系列1234clientWidth:可视区域的宽高（没有边框）:width + padding(左右) ;clientHeight:clientLeft:左边|上边边框的宽度clientTop: 封装getScroll函数12345678910function scroll()&#123; return &#123; left:window.pageXoffset||document.documentElement.scrollLeft||document.body.scrollLeft||0, top:window.pageYoffset||document.documentElement.scrollTop||document.body.scrollTop||0 &#125;;&#125;测试：window.onscroll = function()&#123; console.log(scroll().top);&#125; 通过document获取元素1234获取body：document.body 获取的是元素、标签获取title:document.title 获取的是标签中的值 修改title中的值：document.title = &apos;士大夫&apos;；获取html:document.documentElement 案例图片跟着鼠标飞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; height: 2000px; &#125; img&#123; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;images/bird.png&quot; alt=&quot;&quot; id=&quot;im&quot; /&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //图片跟着鼠标飞,可以在任何的浏览器中实现 //window.event和事件参数对象e的兼容 //clientX和clientY单独的使用的兼容代码 //scrollLeft和scrollTop的兼容代码 //pageX,pageY和clientX+scrollLeft 和clientY+scrollTop //把代码放在一个对象中 var evt=&#123; //window.event和事件参数对象e的兼容 getEvent:function (evt) &#123; return window.event||evt; &#125;, //可视区域的横坐标的兼容代码 getClientX:function (evt) &#123; return this.getEvent(evt).clientX; &#125;, //可视区域的纵坐标的兼容代码 getClientY:function (evt) &#123; return this.getEvent(evt).clientY; &#125;, //页面向左卷曲出去的横坐标 getScrollLeft:function () &#123; return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0; &#125;, //页面向上卷曲出去的纵坐标 getScrollTop:function () &#123; return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0; &#125;, //相对于页面的横坐标(pageX或者是clientX+scrollLeft) getPageX:function (evt) &#123; return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft(); &#125;, //相对于页面的纵坐标(pageY或者是clientY+scrollTop) getPageY:function (evt) &#123; return this.getEvent(evt).pageY?this.getEvent(evt).pageY:this.getClientY(evt)+this.getScrollTop(); &#125; &#125;; //最终的代码 document.onmousemove=function (e) &#123; my$(&quot;im&quot;).style.left=evt.getPageX(e)+&quot;px&quot;; my$(&quot;im&quot;).style.top=evt.getPageY(e)+&quot;px&quot;; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 元素的不同隐藏方式123display:none; 不占位置visibility:hidden; 占位置opacity:0; 不占位置 用户选择 能不能选择文字1user-select:none; onmouseenter和onmouseover的区别 以及onmouseleave和onmouseout的区别12345- 相同点： - 都是鼠标进入或离开事件，功能一致。- 不同点： - onmouseenter和onmouseleave不冒泡 - onmouseover和onmouseout会冒泡 定时器注意事项1注意：定时器产生和定时器执行是两会事。定时器中的函数体里的代码一定是在非定时器代码执行完最后执行的 common.js格式化时间、获取指定标签对象、设置/获取任意元素的任意内容、绑定和解绑事件的兼容代码 面试：12345678910111213141516171819202122232425262728293031321）定时器： id号 = setInterval（fn,时间（毫秒数））； clearInterval(id号); setTimeout(fn,时间（毫秒数）); clearTimeout(id号);2）创建对象的3个方法document.write(); 页面加载完成后添加元素，原来的内容会消失元素.innerHTML(); 会发生覆盖，原来页面内容会消失对象.createElement(&apos;li);3)innerText\textContent和innerHTMLinnerText:非标准属性，都支持，没有标签效果textContent:标准属性，低版本IE不支持，不支持标签效果innerHTML:都支持，支持标签效果innerText和textContent兼容代码4）封装节点兼容代码firstChild firstElementChild5)绑定事件和解绑事件元素.onclick = fn;元素.addEventLiatener(&apos;无on的事件类型&apos;，fn,false);元素.attachEvent(&apos;有on的事件类型&apos;，fn);元素.onclick = null;,false元素.removeEventListener(&apos;无on的事件类型&apos;,fn,false);元素.detachEvent(&apos;有on的事件类型&apos;,fn);6)事件3个阶段7）事件冒泡阻止事件冒泡： e.stopPropagation(); 谷歌、火狐 window.event.cancelBubble = true; 谷歌、IE88）动画函数封装9)轮播图10）三大系列11）封装getScroll函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Javascript基础1. JavaScript和HTML、CSS的区别1231. HTML：提供网页的结构，提供网页中的内容2. CSS: 用来美化网页3. JavaScript: 可以用来控制网页内容，给网页增加动态的效果 2. js组成123456 ☞ ECMASCRIPT 定义了javascript的语法规范,描述了语言的基本语法和数据类型 ☞ BOM （Browser Object Model） 即浏览器对象模型。浏览器对象模型,一套操作浏览器功能的API,通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 ☞ DOM (Document Object Model) 文档对象模型,一套操作页面元素的API,DOM可以把HTML看做是文档树，通过 DOM提供的API可以对树上的节点进行操作 【js+HTMl+css】 2.1 ECMAScript - JavaScript的核心1JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 2.2 BOM - 浏览器对象模型12一套操作浏览器功能的API通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 2.3 DOM - 文档对象模型12一套操作页面元素的APIDOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 3.变量3.1 什么是变量 什么是变量 变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量 使用变量可以方便的获取或者修改内存中的数据 3.2 如何使用变量12声明变量用var，可以同时声明多个变量var age; 3.3 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，例如：for、while。 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 4. 数据类型4.1 简单数据类型12345Number、String、Boolean、Undefined、NullNaN与任何值都不相等，包括它本身1. undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined2. null表示一个空，变量的值如果想为null，必须手动设置获取变量的类型： typeof str 4.2 转换成字符串类型1231. str.toString(); undefined和null没有这个2. String(num);3.拼接字符串 str +&apos;&apos; 4.3 转换成数值类型12341) Number(str)2) parseInt(str)3) parseFloat(str)4) 隐式转换 + -0 4.4 转换成布尔类型12Boolean()取反 4.5 运算符的优先级12345678优先级从高到底 1. () 优先级最高 2. 一元运算符 ++ -- ! 3. 算数运算符 先* / % 后 + - 4. 关系运算符 &gt; &gt;= &lt; &lt;= 5. 相等运算符 == != === !== 6. 逻辑运算符 先&amp;&amp; 后|| 7. 赋值运算符 5. 对象创建方式 对象字面量 12345678var o = &#123; name: 'zs', age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; new Object()创建对象 1234567var person = new Object(); person.name = 'lisi'; person.age = 35; person.job = 'actor'; person.sayHi = function()&#123; console.log('Hello,everyBody');&#125; 工厂函数创建对象 1234567891011function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log('Hello,everyBody'); &#125; return person;&#125;var p1 = createPerson('张三', 22, 'actor'); 自定义构造函数 123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayHi = function()&#123; console.log('Hello,everyBody'); &#125;&#125;var p1 = new Person('张三', 22, 'actor'); 5.1 new在执行时会做四件事情1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 5.2 遍历对象的属性 通过for..in语法可以遍历一个对象 1234567var obj = &#123;&#125;;for (var i = 0; i &lt; 10; i++) &#123; obj[i] = i * 2;&#125;for(var key in obj) &#123; console.log(key + "==" + obj[key]);&#125; 5.3 删除对象的属性1234567function fun() &#123; this.name = 'mm';&#125;var obj = new fun(); console.log(obj.name); // mm delete obj.name;console.log(obj.name); // undefined 6. 内置对象6.1 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 演示：Math.PI、Math.random()、Math.floor()/Math.ceil()、Math.round()、Math.abs() 、Math.max() 123456789Math.PI // 圆周率Math.random() // 生成随机数Math.floor()/Math.ceil() // 向下取整/向上取整Math.round() // 取整，四舍五入Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值Math.sin()/Math.cos() // 正弦/余弦Math.power()/Math.sqrt() // 求指数次幂/求平方根 案例123- 求10-20之间的随机数- 随机生成颜色RGB- 模拟实现max()/min() 6.2 Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 12345678// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数Date构造函数的参数1. 毫秒数 1498099000356 new Date(1498099000356)2. 日期格式字符串 '2015-5-1' new Date('2015-5-1')3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 123456789var now = new Date();// valueOf用于获取对象的原始值console.log(date.valueOf()) // HTML5中提供的方法，有兼容性问题var now = Date.now(); // 不支持HTML5的浏览器，可以用下面这种方式var now = + new Date(); // 调用 Date对象的valueOf() 日期格式化方法 1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分 123456789getTime() // 返回毫秒数和valueOf()结果一样，valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718function formatDate(d) &#123; //如果date不是日期对象，返回 if (!date instanceof Date) &#123; return; &#125; var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? '0' + month : month; date = date &lt; 10 ? '0' + date : date; hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute:minute; second = second &lt; 10 ? '0' + second:second; return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125; 计算时间差，返回相差的天/时/分/秒 123456789101112131415function getInterval(start, end) &#123; var day, hour, minute, second, interval; interval = end - start; interval /= 1000; day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125; 6.3 Array对象 创建数组对象的两种方式 字面量方式 new Array() 1234567891011121314// 1. 使用构造函数创建数组对象// 创建了一个空数组var arr = new Array();// 创建了一个数组，里面存放了3个字符串var arr = new Array('zs', 'ls', 'ww');// 创建了一个数组，里面存放了4个数字var arr = new Array(1, 2, 3, 4);// 2. 使用字面量创建数组对象var arr = [1, 2, 3];// 获取数组中元素的个数console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()/valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组对象本身 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() 123456789101112131415161718192021// 1 栈操作(先进后出)push()pop() //取出数组中的最后一项，修改length属性// 2 队列操作(先进先出)push()shift() //取出数组中的第一个元素，修改length属性unshift() //在数组最前面插入项，返回数组的长度// 3 排序方法reverse() //翻转数组sort(); //即使是数组sort也是根据字符，从小到大排序// 带参数的sort是如何实现的？// 4 操作方法concat() //把参数拼接到当前数组slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目)// 5 位置方法indexOf()、lastIndexOf() //如果没找到返回-1// 6 迭代方法 不会修改原数组(可选)every()、filter()、forEach()、map()、some()// 7 方法将数组的所有元素连接到一个字符串中。join() 清空数组 123456// 方式1 推荐 arr = [];// 方式2 arr.length = 0;// 方式3arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 12345678910111213141516function myJoin(array, seperator) &#123; seperator = seperator || ','; array = array || []; if (array.length == 0)&#123; return ''; &#125; var str = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; str += seperator + array[i]; &#125; return str;&#125;var array = [6, 3, 5, 6, 7, 8, 0];console.log(myJoin(array, '-'));console.log(array.join('-')) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 123456789101112131415161718// 方式1var array = [1500,1200,2000,2100,1800];var tmpArray = [];for (var i = 0; i &lt; array.length; i++) &#123; if(array[i] &lt; 2000) &#123; tmpArray.push(array[i]); &#125;&#125;console.log(tmpArray);// 方式2var array = [1500, 1200, 2000, 2100, 1800];array = array.filter(function (item, index) &#123; if (item &lt; 2000) &#123; return true; &#125; return false;&#125;);console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 1234567var array = ['c', 'a', 'z', 'a', 'x', 'a'];do &#123; var index = array.indexOf('a',index + 1); if (index != -1)&#123; console.log(index); &#125;&#125; while (index &gt; 0); 编写一个方法去掉一个数组的重复元素 12345678910111213141516171819202122232425var array = ['c', 'a', 'z', 'a', 'x', 'a'];function clear() &#123; var o = &#123;&#125;; for (var i = 0; i &lt; array.length; i++) &#123; var item = array[i]; if (o[item]) &#123; o[item]++; &#125;else&#123; o[item] = 1; &#125; &#125; var tmpArray = []; for(var key in o) &#123; if (o[key] == 1) &#123; tmpArray.push(key); &#125;else&#123; if(tmpArray.indexOf(key) == -1)&#123; tmpArray.push(key); &#125; &#125; &#125; returm tmpArray;&#125;console.log(clear(array)); 7. 基本包装类型为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean 123456789// 下面代码的问题？// s1是基本类型，基本类型是没有方法的var s1 = 'zhangsan';var s2 = s1.substring(5);// 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于：var s1 = new String('zhangsan');var s2 = s1.substring(5);s1 = null; 1234567// 创建基本包装类型的对象var num = 18; //数值，基本类型var num = Number('18'); //类型转换var num = new Number(18); //基本包装类型，对象// Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如：var b1 = new Boolean(false);var b2 = b1 &amp;&amp; true; // 结果是什么 8. String对象 字符串的不可变 12345var str = 'abc';str = 'hello';// 当重新给str赋值的时候，常量'abc'不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 1234var str = new String('Hello World');// 获取字符串中字符的个数console.log(str.length); 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 1234567891011121314151617181920212223// 1 字符方法charAt() //获取指定位置处字符charCodeAt() //获取指定位置处字符的ASCII码str[0] //HTML5，IE8+支持 和charAt()等效// 2 字符串操作方法concat() //拼接字符串，等效于+，+更常用slice() //从start位置开始，截取到end位置，end取不到substring() //从start位置开始，截取到end位置，end取不到substr() //从start位置开始，截取length个字符// 3 位置方法indexOf() //返回指定内容在元字符串中的位置lastIndexOf() //从后往前找，只找第一个匹配的// 4 去除空白 trim() //只能去除字符串前后的空白// 5 大小写转换方法to(Locale)UpperCase() //转换大写to(Locale)LowerCase() //转换小写// 6 其它search()replace()split()fromCharCode()// String.fromCharCode(101, 102, 103); //把ASCII码转换成字符串 案例 截取字符串”我爱中华人民共和国”，中的”中华” 123var s = "我爱中华人民共和国";s = s.substr(2,2);console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 123456789var s = 'abcoefoxyozzopp';var array = [];do &#123; var index = s.indexOf('o', index + 1); if (index != -1) &#123; array.push(index); &#125;&#125; while (index &gt; -1);console.log(array); 把字符串中所有的o替换成! 1234567var s = 'abcoefoxyozzopp';do &#123; s = s.replace('o', '');&#125; while (s.indexOf('o') &gt; -1);console.log(s);console.log(s.replace(/o/ig, '')); 判断一个字符串中出现次数最多的字符，统计这个次数 1234567891011121314151617181920212223var s = 'abcoefoxyozzopp';var o = &#123;&#125;;for (var i = 0; i &lt; s.length; i++) &#123; var item = s.charAt(i); if (o[item]) &#123; o[item] ++; &#125;else&#123; o[item] = 1; &#125;&#125;var max = 0;var char ;for(var key in o) &#123; if (max &lt; o[key]) &#123; max = o[key]; char = key; &#125;&#125;console.log(max);console.log(char); 作业12345678给定一个字符串如：“abaasdffggghhjjkkgfddsssss3444343”问题如下： 1、 字符串的长度 2、 取出指定位置的字符，如：0,3,5,9等 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法 5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数 7、 遍历字符串，并将遍历出的字符两头添加符号“@”输出至当前的文档页面。 9.Math对象1234567891011121314151617181920☞ 提供了一系列与数学相关的方法或属性 ( 静态 | 实例)☞ Math.PI 获取圆周率【属性】 ☞ Math.random() 返回大于等于0小于1之间的随机数☞ Math.floor() 向下取整，返回一个小于当前数字的整数☞ Math.ceil() 向上取整，返回一个大于当前数字的整数☞ Math.round() 四舍五入（小数如果小于0.5,返回小于当前数字的整数，如果小数部分大于0.5返回大于当前数字的一个整数）☞ Math.abs() 取绝对值（返回当前数字的绝对值，正整数）☞ Math.max() 返回一组数中的最大值 （可以设置多个参数，返回其中最大值，参数不可以是数组）☞ Math.min() 返回一组数中的最小值 （可以同时设置多个参数，与最大值效果一样）☞ Math.sin(x) 返回一个正弦的三角函数 ( 注意： x 是一个以弧度为单位的角度)☞ Math.cos(x) 返回一个余弦的三角函数 （注意： x 参数是一个以弧度为单位的角度）☞ Math.pow(x,y) 返回x的y次幂 10. Date对象123456789101112131415161718192021☞ Date是一个构造函数，必须通过 new Date() 创建一个实例成员才能使用☞ 用法一：空构造函数 var d = new Date(); ☞GMT 格林威治时间（0时区）☞ 用法二：在构造函数中传入毫秒值 var d = new Date(d.valueOf());☞ 用法三： 传入日期格式的字符串 var d = new Date("1988-8-8")☞ 用法四： 传入数字 var d = new Date(year, month[,day,time,second]); //必须设置年和月 备注： 月份从0 开始， 0 代表1月☞ 获取当前时间的毫秒值： d.valueOf() d.getTime() // 推荐使用 Date.now() //H5 新方法 有兼容信息 11. Date中的方法1234567891011121314151617☞ 日期格式化方法var d = new Date(); d.toString(); //转化成字符串 d.toDateString(); //转换成日期字符串 d.toTimeString(); //转换成时间字符串 d.toLocaleDateString(); //返回本地的日期格式 （不同浏览器不同效果） d.toLocaleTimeString(); //返回本地的时间格式 （不同浏览器不同效果）☞ 获取日期其他部分 d.getSeconds() //获取秒 d.getMinutes() //获取分钟 d.getHours() //获取小时 d.getDay() //返回周几 （0表示周日） d.getDate() //返回当前月的第几天 d.getMonth() //返回月份 （从0开始） d.getFullYear() //返回年份 12. Date案例123☞ 写一个函数，格式化日期对象，返回 yyyy-mm-dd HH:mm：ss 形式☞ 写一个函数计算时间差，返回相差的天/时/分/秒 【求 2008年8月8日到今天】 13. 数组中常用的方法1234567891011121314151617181920212223☞ toString() // 把数组转换为字符串，使用逗号分隔☞ valueOf() // 返回数组对象本身var ary = []; ary.toString() ary.valueOf();☞ 栈方法（先进后出） ary.push() // 该方法有一个返回值，表示数组最新的长度，该方法中可以设置多个参数 ary.pop() //返回数组中最后一个字，且会修改数组的长度☞ 队列（先进先出） ary.push() ary.shift() //取出数组中的第一个元素，修改数组的长度 ary.unshift(number) //在数组中最开始位置添加一个值☞ 排序方法 ary.reverse() // 翻转数组 ary.sort() //数组排序 默认是从字符编码排序的☞ 数组的sort方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[一面总结]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2F%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[###易芯 12345678910111.H5新特性2.用C3实现轮播图效果3.router钩子函数4.实现下拉框效果 手动5.文件上传6.缓存 页面不刷新 不缓存 页面 刷新 要想让页面刷新怎么办7.vuex8.tab栏 要想实现点击一个出现一个9.vue请求10.拦截器 请求拦截器 和 响应拦截器11.手动实现上拉刷新下拉加载 知识点总结一12345678910111213141516171819202122232425262728293031Axios如何解决跨域问题移动端手机键盘弹出时遮盖了输入框如何优化解决如何更改标题UI图高度超出屏幕范围如何优化下拉框怎么解决页面出现&#123;&#123;msg&#125;&#125; v-clock [v-clock]&#123;display: none;&#125;css垂直居中px、em、rem有什么区别position几种取值 相对谁进行定位js数据类型new运算符创建实例时，经过了哪些步骤用什么方法可以获取对象的类?call()、apply()、bind()方法的作用是什么? 什么时候会使用到这些方法?他们之间的区别是什么?利用正则表达式,写一个字符串转换成驼峰命名的方法例如: border-bottom-color borderBottomColorcommonJS AMD CMD的区别MVC、MVP、MVVM的差异简述v-if和v-show的区别不同组件之间如何传递数据(父子组件、兄弟组件)组件的生命周期由哪些什么情况下会用到computed？什么情况下会用到watch?项目构建过程中,如何提取公共资源？js的存储方式实现一个深拷贝描述一下浏览器从加载到渲染的过程,比如输入一个网址到显示页面的过程实现一个继承方法调用请用js实现sort函数,要求 sort([5,100,6,3,-12]) 返回[-12,3,5,6,100]事件对象中target对象 和 currentTarget对象的区别 target在事件流目标阶段 currentTarget在时间流捕获阶段 currentTarget指向事件所绑定的元素 target始终指向事件发生时的元素写出判断一个变量名是否为数组的方法用ES5实现数组去重的方法 知识点总结二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889200：成功 302:重定向 304：未修改 403：禁止访问 404：未找到页面 500：服务器错误垂直居中： 定位 弹性布局 :justify-content align-items什么是vue生命周期?DOM渲染在哪个周期中就已经完成？列举块元素、行内元素和空元素数组去重什么是闭包判断一个变量或者对象是不是为undefined定义一个filter,将时间戳1512023760转化成&quot;2017-11-30&quot;格式var str = 1554515432948; function getDate(str)&#123; var date = new Date(str); // console.log(date); var year = date.getFullYear() &gt; 10 ? date.getFullYear() : &quot;0&quot; + date.getFullYear(); var month = (date.getMonth()+1)&gt; 10 ? (date.getMonth()+1) : &quot;0&quot; + (date.getMonth()+1); var day = date.getDate() &gt; 10 ? date.getDate() : &quot;0&quot; + date.getDate(); return year +&apos;-&apos;+ month +&apos;-&apos;+ day; &#125; console.log(getDate(str));简述vuexjs哪个方法用于匹配字符串?var a=&quot;20180528&quot;，如何从a中截取字符&quot;05“ str.indexOf(&apos;asf&apos;) var a=&quot;20180528&quot;; var num = a.indexOf(&apos;05&apos;); console.log(num); console.log(a.substr(num,2));var data=&#123;a:1,b:2,c:3&#125;;将data对象变成数组 var data=&#123;a:1,b:2,c:3&#125;; var arr = []; for(var key in data)&#123; arr[arr.length] = key; &#125; console.log(arr);split()和join的区别 split()是把一串字符串(根据某个分隔符)分成若干个元素放在一个数组里,即切割成数组的形式 join()是把数组中的字符串根据符号拼成字符串px、em、rem的取用选择依据 px像素,绝对单位,不能做适配 em:继承父元素的字体尺寸. rem:相对于body的字体大小性能优化： 减少http请求、http缓存、资源合并与压缩、css精灵图、懒加载js数据类型： 内存存储：简单数据类型(string、number、boolean、null、undefined)、复杂数据类型(array、date、function)匹配一段由数字和大小写字母组成的字符串的正则表达式: /\w/.test(str)web前端适配多端的模式有什么解决方案position包括几种属性?absolute和relative的区别?IE6 bug的解决方法标签上title和alt属性有什么区别display和visibility有何异同？ 隐藏后占不占位置div+css布局较table布局有什么优点?sessionStorage和localStorage的区别rgba()和opacity的透明效果有什么不同px、em、rem的区别如何阻止事件冒泡和默认事件事件委托是什么如何实现浏览器内多个标签之间的通信call和apply的区别 function().call(this,num1,num2) function().apply(this,[num1,num2])html兼容性问题hasClass()、addClass()、removeClass()用法用js判断一个字符串中出现次数最多的字符,统计这个次数 var str = &quot;safsafsafsdfafdafsdfsafsdfsafd&quot;; var arr = str.split(&quot;&quot;); // console.log(arr); var obj = &#123;&#125;; for(var i = 0; i &lt; arr.length; i++)&#123; if(!obj[arr[i]])&#123; obj[arr[i]] = 1; &#125;else&#123; obj[arr[i]] ++; &#125; &#125; console.log(obj); var maxcount = 0; for(var key in obj)&#123; if(obj[key] &gt; maxcount)&#123; maxcount = obj[key]; &#125; &#125; console.log(maxcount);js字符串操作数及使用方法怎样添加 移除 移动 复制和查找节点 insertBefore removeChild cloneChild appendChild去除字符串空格? /^\s|/s$/gjquery中如何将数组转化为json字符串,然后再转化回来?截取字符串abcdefg的efgeval是做什么的,性能安全如何Node.js优缺点,适用场景 知识点总结三123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230// 1.运行结果// const p1 = new Promise((resolve,reject)=&gt;&#123;// setTimeout(()=&gt;&#123;// resolve(&apos;success&apos;)// &#125;,1000);// &#125;);// const p2 = p1.then(()=&gt;&#123;// throw new Error(&apos;error----&apos;);// &#125;);// console.log(&apos;p1&apos;,p1);// console.log(&apos;p2&apos;,p2);// setTimeout(() =&gt; &#123;// console.log(&apos;p1&apos;,p1);// console.log(&apos;p2&apos;,p2);// &#125;,2000);p1 Promise__proto__: Promisecatch: ƒ catch()constructor: ƒ Promise()finally: ƒ finally()then: ƒ then()Symbol(Symbol.toStringTag): &quot;Promise&quot;__proto__: Object[[PromiseStatus]]: &quot;resolved&quot;[[PromiseValue]]: &quot;success&quot; p2 Promise__proto__: Promise[[PromiseStatus]]: &quot;rejected&quot;[[PromiseValue]]: Error: error---- at p1.then (file:///E:/index.html:17:19)Uncaught (in promise) Error: error---- at p1.then (index.html:17)index.html:22 p1 Promiseindex.html:23 p2 Promise// 2.运行结果// var str = function()&#123;// console.log(2);// &#125;// function str()&#123;// console.log(1);// &#125;// str(); //2// 3.运行结果// let p1 = new Promise((resolve,reject)=&gt;&#123;// console.log(&apos;Promise&apos;);// resolve();// &#125;);// p1.then(function()&#123;// console.log(&apos;resolved&apos;);// &#125;);// console.log(&quot;Hi!&quot;); // Promise Hi! resolved// 4.运行结果// setTimeout(function()&#123;// console.log(1);// &#125;);// new Promise(function(resolve,reject)&#123;// console.log(2);// resolve(3);// &#125;).then(function(val)&#123;// console.log(val);// &#125;);// console.log(4);// 2 4 3 1// 5.运行结果// function trans(obj,value)&#123;// obj.name = &apos;hello world&apos;;// value = value +10;// return value;// &#125;// var o = &#123;name: &apos;hello&apos;,age: 20&#125;;// var count = 10;// var ret = trans(o,count);// console.log(o,ret,count);// &#123;name: &quot;hello world&quot;,age: 20&#125; 20 10// 6.运行结果// var test = (function(i)&#123;// console.log(i);// &#125;)(5);// test(1);// 5// 111.html:71 Uncaught TypeError: test is not a function// 7.运行结果// var scope = &apos;global&apos;;// function f()&#123;// console.log(scope);// var scope = &apos;local&apos;;// console.log(scope);// &#125;// f();// undefined &apos;local// 8. 运行结果// for(var i = 0; i&lt; 5;i++)&#123; // console.log(i); // &#125; // console.log(i); //0 1 2 3 4 5 // 9.运行结果 // for(var i = 0; i&lt;=4;i++)&#123; // setTimeout(function timer()&#123; // console.log(i); // &#125;,1000); // &#125; // 5 5 5 5 5 // for(let i = 0; i &lt;=4;i++)&#123; // setTimeout(function timer()&#123; // console.log(i); // &#125;,1000); // &#125; //0 1 2 3 4 // for(var i = 0; i &lt;= 4;i++)&#123; // (function(i)&#123; // setTimeout(function timer()&#123; // console.log(i); // &#125;,1000); // &#125;)(i); // &#125; //0 1 2 3 4 // 10.运行结果 // var F = function()&#123;&#125;; // Object.prototype.a = function()&#123; // console.log(&apos;a()&apos;); // &#125; // Function.prototype.b = function()&#123; // console.log(&apos;b()&apos;); // &#125; // f.a(); //111.html:118 Uncaught ReferenceError: f is not defined // f.b(); //111.html:119 Uncaught ReferenceError: f is not defined // F.a(); a() // F.b(); b() // 11.运行结果 // var test = &#123; // name:&apos;test&apos;, // fun: function()&#123; // console.log(this.name); // function getname()&#123; // console.log(this.name); // &#125; // getname(); // &#125; // &#125; // test(); // Uncaught TypeError: test is not a function // 12.写出代码对下列数组去重并从小到大排列 // var arr = [5,2,3,6,8,6,5,4,7,1,9]; // function sort(arr)&#123; // for(var i =0; i&lt;arr.length-1;i++)&#123; // for(var j = 0; j &lt; arr.length; j++)&#123; // if(arr[j]&gt;arr[j+1])&#123; // temp = arr[j]; // arr[j] = arr[j+1]; // arr[j+1] = temp; // &#125; // &#125; // &#125; // return arr; // &#125; // 去重？ // // 13.运行 // const p1 = new Promise((resolve,reject)=&gt;&#123; // console.log(1); // resolve(); // console.log(2); // &#125;); // p1.then(()=&gt;&#123; // console.log(3); // &#125;); // console.log(4); 1 2 4 3 // 14. // const first = () =&gt; new Promise((resolve,reject)=&gt;&#123; // console.log(3); // let p1 = new Promise((resolve,reject)=&gt;&#123; // console.log(7); // setTimeout(() =&gt; &#123; // console.log(5); // resolve(6); // &#125;,0); // resolve(1); // &#125;); // resolve(2); // p1.then((arg)=&gt;&#123; // console.log(arg); // &#125;); // &#125;); // first().then((arg)=&gt;&#123; // console.log(arg); // &#125;); // console.log(4); 3 7 4 1 2 5 1.页面在那些浏览器测试过,浏览器的内核分别是什么?浏览器对老系统的支持力度 2. var foo = &apos;10&apos; + 2/&quot;2&quot;; console.log(foo); //101 console.log(typeof foo); //string 3.var foo =&apos;aaa&apos;; var bar = &#123; foo: &apos;bbb&apos;, get: function()&#123; var foo = &apos;ccc&apos;; var that = this; return function()&#123; return that.foo; &#125; &#125; &#125; console.log(bar.get()()); //bbb var baz = bar.get; alert(baz()()); //aaa 4.MVVM框架是什么?他和其他jquery的区别是什么?适用于那些场景 5.用js实现一个冒泡排序算法 var arr = [5,5,6,5,8,9,4,6,5,3,2]; for(var i = 0; i &lt; arr.length - 1 ; i ++)&#123; for(var j = 0 ; j &lt; arr.length-1; j ++)&#123; if(arr[j] &gt; arr[j+1] )&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; &#125; &#125; &#125; console.log(arr) 数组去重： var arr = [5,5,6,5,8,9,4,6,5,3,2]; var newArr = new Set(arr); console.log(newArr); 6.输入框，没有焦点的时候，显示默认提示文字;用户输入时,隐藏提示文字,且恢复为默认色,失去焦点时,如果输入内容为空,还原提示信息 &lt;input type=&quot;text&quot; class=&quot;cls&quot; value=&quot;请输入搜索内容&quot;&gt; &lt;script&gt; // 输入框，没有焦点的时候，显示默认提示文字;用户输入时,隐藏提示文字,且恢复为默认色,失去焦点时,如果输入内容为空,还原提示信息 var input = document.querySelector(&apos;.cls&apos;); input.onblur = function()&#123; var val = this.value; console.log(val); if(val == &apos;&apos;)&#123; this.value = &apos;请输入搜索内容&apos; &#125; &#125; input.onfocus = function()&#123; this.value = &apos;&apos;; &#125; &lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[知识点总结]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F17%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[知识一12345678910111213141516171819202122232425262728293031js中typeof和instanceof函数作用及区别请问什么叫闭包?简述src和href区别简述同步和异步的区别简述ajax的工作原理和优缺点简述sessionStorage、localStorage和cookie的区别请问什么事跨域?跨域请求资源的方法有哪些?document.load和document.ready有什么区别如何减低页面加载时间常见的web攻击技术有哪些?前端需要如何处理清除浮动有哪几种方法如何使一个元素垂直水平居中,如果是一个不定宽的元素如何实现呢?ES6中箭头函数于普通函数有哪些异同?删除字符串中&quot;aabbccdd&quot;中所有的&quot;b&quot;实现一个将字符串反转的函数,如&quot;ABCD&quot;得出&quot;DCBA&quot;用js从cookie中读取一个键为userid的cookie值实现一个log函数,与console.log具有相同的特性,但每条输出都带有前缀,使用工厂模式创建出带有不同前缀的log函数列举js中几种变量类型,如何判断一个数组实现一个事件代理排序 [1,5,8,0,-2]js实现继承实现3列布局,中间一列自适应宽度 双飞翼、圣杯布局行内元素有哪些?块级元素有哪些?CSS的盒模型标签上title和alt属性的区别是什么?ajax请求时,如何解释json数据计算一个数组arr所有元素的和 var arr = [1,2,3,4,5,6,7,8,9]js去除字符串空格浏览器缓存有哪些? 通常缓存有哪几种以及他们的区别是什么jquery的事件委托bind、live、delegate、on之间有什么区别$(document).ready()方法和window.onload有什么区别 知识点二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297代码： 1.for(var i =0; i &lt; 5; i++)&#123; var a = 1; setTimeout(function()&#123; console.log(i); // 5 个5 &#125;,0); &#125; (function()&#123; console.log(a); //1 console.log(b); //undefined b = &quot;b&quot;; console.log(b); // b a = 2; console.log(a); // 2 var b; &#125;)(); console.log(a); // 2 2.var arr = [0,1,2,3,4,5,6,7,8,9]; for(var i = 0; i &lt; arr.length; i++)&#123; if(i%2 == 0)&#123; arr.splice(i,1); &#125; &#125; alert(arr); //1 2 4 5 7 8 3.function fun()&#123; for(var i = 0; 4&gt;i;i++)&#123; var k = 100; str += &apos;,&apos;+(k+i); &#125; &#125; var k = 1, str = k; fun(); str += k; console.log(str); //1,100,101,102,1031 4.str = &quot;b ook ,de sk, pag,bag,a ni moa,food, pag, page,desk,bag,animoa&quot; 转化为数组的形式输出,要求: 去除重复单词 去除单词两端空格 单词排序 var arr = str.split(&apos;,&apos;); 5.[1,2,3,4,5].changes(); [1,2,3,4,5,1,2,3,4,5] 6.使用js如何检测变量 a=[1,3,4,5]为Array类型 7.函数声明和函数表达式的区别 8.在事件中e.target和e.currentTarget有什么区别 9.什么是闭包,闭包的特性,闭包的优点与缺点 10.如何准确的判断一个变量是数组类型 11.写一个原型链的例子 12.同步与异步的区别是什么? 13.如何实现一个promise,promise的原理,以及他的两个参数是什么 14.vue中父子组件如何通信的 15.vue如何实现数据的双向绑定 16.Vuerouter跳转和location.href有什么区别 17.数组去重 18.写一个简单的$.ajax()的请求方式 19.viewport、rem、媒体查询、使用百分比 1.写出sessionStorage和localStorage的区别 2.function foo()&#123; try &#123; return 0; console.log(&quot;b&quot;); &#125;catch(err)&#123; &#125;finally&#123; console.log(&quot;a&quot;); &#125; &#125; console.log(foo()); // a 0 3.var r = new Promise(function(resolve,reject)&#123; console.log(&quot;a&quot;); resolve(); &#125;) setTimeout( () =&gt; console.log(&apos;d&apos;),0); r.then(() =&gt; console.log(&quot;c&quot;)); console.log(&quot;b&quot;); // a b c d 4.var a = 5; var b = 10; if(a == 5.0)&#123; let a = 4; var b = 1; console.log(a); // 4 console.log(b); // 1 &#125; console.log(a); // 5 console.log(b); // 1 5.写出http状态码200 301 302 304 404 500 的含义 6.js继承有哪些实现方式?你用过其中的那些? 7.使用flex实现一个div中的元素垂直居中 8.var num = [3,6,2,4,1,5],实现对该数组的排序,输出[1,2,3,4,5,6] 9.vue生命周期 10.h5新增语义标签有哪些? 如何处理h5新标签的浏览器兼容问题 11.cookie、sessionStorage和localStorage的区别 12.如何理解vue中的MVVM 13.前端如何优化网站性能 如何对网站资源进行优化: 文件合并、文件最小化、文件压缩、使用CDN托管、缓存的使用 14.浏览器的内核分别是什么 15.css精灵图 css引入方式 优先级如何计算 css3新增伪类 16.&quot;I&apos;m a Iasagna hog&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;) &quot;goh angasaI a m&apos;I&quot; 17.var foo = &#123;n:1&#125;; var bar = foo; foo.x = foo = &#123;n:2&#125;; console.log(foo.x); undefined 18.cors访问控制原理 19.采用何种工具发现代码的性能问题 改善网页滚动性能的几种方法 Layout、paint、Composite的不同之处 20.深拷贝 21.new操作符调用构造函数会经历哪些过程 22.var length = 10; function fn()&#123; console.log(this.length); &#125; var obj = &#123; length: 5, methods(fn)&#123; fn(); console.log(arguments[0]); arguments0; &#125; &#125; obj.methods(fn); 10 1 23.问题=========================================== function Foo()&#123; getName = function()&#123;console.log(1)&#125;; return this; &#125; Foo.getName = function()&#123; console.log(2); &#125; Foo.prototype.getName = function () &#123; console.log(3) &#125; var getName = function()&#123;console.log(4)&#125; function getName()&#123;console.log(5)&#125; Foo.getName(); getName(); Foo().getName(); getName(); new Foo.getName(); new Foo().getName(); 什么事构造函数,与普通函数有什么区别 有哪些节点类型,如何判断当前节点类型 如何合并两个数组,数组删除一个元素 jquery中如何实现多库并存 jq中get和eq有什么区别 [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt) 答案是什么 创建对象有几种方法 简述常见的web攻击XSS和CSRF的原理 &lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么 active-class是哪个组件的属性 什么事MVVM vue的生命周期 知识点三12345678910111213141516171819202122232425262728293031323334353637383940411.var a = 1; function test()&#123; console.log(a); //undefined var a = 2; console.log(this.a); //1 setTimeout(function()&#123; console.log(a); // 3 &#125;,0); return function()&#123; console.log(a); //2 a = 3; console.log(this.a); // 1 &#125; &#125; test()(); 2.Object.assign()函数的作用及用法 3.什么情况是跨域?如何解决跨域问题 4.什么是MVVM?MVVM和MVC区别 5.组件之间的传值 6.vuex是什么?怎么使用?文档总结 知识点四 1234567891011121314151617181920212223242526272829条件与循环： v-if bool值：插入/移除元素 v-for:循环 事件处理函数： v-on:事件名.属性 = &apos;&apos; v-on: 可以简写为@ v-model:实现表单输入与应用状态之间的双向绑定 组件: component(&apos;组件名&apos;,&#123;选项&#125;) 侦听器 watch watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.debouncedGetAnswer() &#125; &#125; v-once:v-once:一次性的插值 计算属性 computed:&#123;名：函数&#125; 计算属性是基于它们的依赖进行缓存的 v-bind:class: 数组/对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331reverse():数组翻转 join(); 数组用什么拼接成字符串 一、什么是MVVM？ MVVM是Model-View-ViewModel的缩写。 MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑； View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互， Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中， 而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层 连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉， 因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题， 复杂的数据状态维护完全由 MVVM 来统一管理。 二、mvvm和mvc区别？ 它和其它框架（jquery）的区别是什么？哪些场景适合？ mvc和mvvm其实区别并不大。 都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。 mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷 三、vue的优点是什么？ 低耦合。 视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上， 当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 四、 组件之间的传值？ 父组件与子组件传值父组件通过标签上面定义传值子组件通过props方法接受数据 子组件向父组件传递数据 子组件通过$emit方法传递参数 五、路由之间跳转 声明式（标签跳转） 编程式（ js跳转） 六、vue.cli中怎样使用自定义的组件？ 有遇到过哪些问题吗？ 第一步：在components目录新建你的组件文件（indexPage.vue），script一定要export default &#123;&#125; 第二步：在需要用的页面（组件）中导入：import indexPage from &apos;@/components/indexPage.vue&apos; 第三步：注入到vue的子组件的components属性上面,components:&#123;indexPage&#125; 第四步：在template视图view中使用，例如有indexPage命名，使用的时候则index-page 七、vue如何实现按需加载配合webpack设置 -webpack中提供了require.ensure()来实现按需加载。 以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。 不进行页面按需加载引入方式：import home from &apos;../../common/home.vue&apos; 进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(&apos;../../common/home.vue&apos;))) 八、vuex面试相关 （1）vuex是什么？怎么使用？哪种功能场景使用它？ vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。 场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车（2）vuex有哪几种属性？ 有五种， 分别是 State、 Getter、Mutation 、Action、 Module vuex的State特性A、Vuex就是一个仓库， 仓库里面放了很多对象。其中state就是数据源存放地， 对应于一般Vue对象里面的dataB、state里面存放的数据是响应式的， Vue组件从store中读取数据，若是store中的数据发生改变， 依赖这个数据的组件也会发生更新C、它通过mapState把全局的 state 和 getters 映射 到当前组件的 computed 计算属性中 vuex的Getter特性A、getters 可以对State进行计算操作， 它就是Store的计算属性B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用C、 如果一个状态只在一个组件内使用，是可以不用getters vuex的Mutation特性Action 类似于 mutation， 不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。（3）不用Vuex会带来什么问题？ 可维护性会下降，想修改数据要维护三个地方； 可读性会下降， 因为一个组件里的数据，根本就看不出来是从哪来的； 增加耦合，大量的上传派发， 会让耦合性大大增加， 本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。 九、 v-show和v-if指令的共同点和不同点 v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏 v-if指令是直接销毁和 重建DOM达到让元素显示和隐藏的效果 十、 如何让CSS只在当前组件中起作用 将当前组件的&lt;style&gt;修改为&lt;style scoped&gt; 十一、的作用是什么? 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。 十二、Vue中引入组件的步骤? 1） 采用ES6的import … from …语法或CommonJS的require()方法引入组件2） 对组件进行注册, 代码如下 // 注册Vue.component(&apos;my-component&apos;, &#123;template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;) 3）使用组件&lt;my-component&gt;&lt;/my-component&gt; 十三、指令v-el的作用是什么? 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标. 可以是 CSS 选择器，也可以是一个 HTMLElement 实例十四、在Vue中使用插件的步骤 采用ES6的import … from …语法或CommonJSd的require()方法引入插件 使用 全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, &#123; someOption: true &#125;) 十五、请列举出3个Vue中常用的生命周期钩子函数 created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始,el 替换， 并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素， 当 mounted 被调用时 vm.$el 也在文档内。 activated: keep-alive组件激活时调用 十六、active-class是哪个组件的属性？ vue-router模块的router-link组件。 十七、怎么定义vue-router的动态路由以及如何获取传过来的动态参数？ 在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id。 十八、vue-router有哪几种导航钩子？ 一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。 第二种：组件内的钩子； 第三种：单独路由独享组件十九、生命周期相关面试题 总共分为8个阶段 创建前/后，载入前/后， 更新前/后，销毁前/后。 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined 还未初始化。在created阶段，vue实例的数据对象data有了，el还没有 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了， 但还是挂载之前为虚拟的dom节点，data.message还未替换。 在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数， 说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 （1）、什么是vue生命周期 答： Vue 实例从创建到销毁的过程，就是生命周期。 也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、 更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。（2）、vue生命周期的作用是什么 答：它的生命周期中有多个事件钩子， 让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 （3）、vue生命周期总共有几个阶段 答： 可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后（4）、第一次页面加载会触发哪几个钩子 答： 第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子（5）、DOM 渲染在 哪个周期中就已经完成 答：DOM 渲染在 mounted 中就已经完成了。 （6）、简单描述每个周期具体适合哪些场景 答： 生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件， 在加载实例时触发 created : 初始化完成时的事件写在这里， 如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素， 获取到DOM节点 updated : 如果对数据统一处理， 在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom二十、说出至少4种vue当中的指令和它的用法？v-if：判断是否隐藏； v-for：数据循环； v-bind:class：绑定一个属性； v-model：实现双向绑定 二十一、 vue-loader是什么？使用它的用途有哪些？ 解析.vue文件的一个加载器。 用途：js可以写es6、style样式可以scss或less、template可以加jade等二十二、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？答：css的预编译。 使用步骤：第一步：先装css-loader、node-loader、sass-loader等加载器模块 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss 第三步：在同一个文件，配置一个module属性 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss” 特性: 可以用变量，例如（$变量名称=值）； 可以用混合器，例如（） 可以嵌套二十三、为什么使用key？ 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们 ，否则 Vue 为了效率只会替换相同标签内部的内容。 二十四、为什么避免 v-if 和 v-for 用在一起 当 Vue 处理指令时， v-for 比 v-if 具有更高的优先级，通过v-if 移动到容器元素， 不会再重复遍历列表中的每个值。取而代之的是， 我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。 二十五、VNode是什么？虚拟 DOM是什么？ Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”， 简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。26.拖拽事件 12345678910111213141516171819202122231.盒子模型（box-sizing）2.弹性布局(flex 主轴侧轴)3.bom和dom, bom中的对象4.前后端跨域，怎么设置5.Jsonp原理，怎么设置6.Webstorage(localstorage中存储的内容例如昵称修改了，怎么做到的pc端会修改)7.Vue父子组件传值怎么设置的8.计算属性和侦听器用法区别9.截取url中参数以对象形式保存(手写代码)10.平时项目有多少个js文件11.Js中模块化（commonjs,requirejs）12.requirejs中define与require详解13.requirejs中的配置项，怎么用的14.Es6中使用了哪些15.let和const 的区别16.箭头函数与普通函数区别17.异步请求用的ajax还是async await18.Promise函数的状态19.P2=p1.then(return )此时p2的状态20.怎么让一大堆promise函数每5个一批执行21.jquery中的选择器22.git的指令（git log git reset）23.把数组中出现的元素统计出每一个次数（手写代码） 知识点五123456789101112131415161718192021222324252627284.学过什么新的主流框架5.介绍一下vue，有什么特性，优点6.Vue本身具备什么能力，框架怎么分层的7.vue是怎么高效的运行的，有性能瓶颈吗，怎么性能优化8.分析加载慢的原因，怎么解决9.怎么发现问题所在的10.性能优化11.讲一下从网络发起到上屏浏览器经过了哪些处理12.Js怎么执行13.js一般怎么工作的，怎么解析的js脚本14.js内存环境怎么做的15.H5有哪些新特性16.js怎么实现异步17.vue框架的异步策略18.为什么要用异步19.异步底层怎么实现的20.跨域的安全问题21.在实现过程中怎么做终端的适配的（安卓和ios,以及各种浏览器屏幕）22.做适配要遵循什么样的原则（手机端适配）23.Zepto本身是怎么实现的，一种轻量化的24.谈谈jquery内存中怎么管理25.Jquery有模板吗26.平时使用jquery过程中有什么问题27.模板渲染引擎有用过哪些28.为什么用art-template,有其他类似的模板吗29.之前工作最大收获是什么30.有一段字符串，统计一下联系三个字符后面的要比前面的大（例如abc,acd）的时间复杂度和空间复杂度31.操作系统有了解过吗 知识点六1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162vue的作用 什么是vue vue的钩子函数 vue的生命周期 vuex是什么 腾讯面试题： 1.介绍项目 2.XMLHttpRequest 3.Http状态码 4.Cache-control 5.CSS动画原理 面试： 1.圣杯布局 2.ie的某些兼容性 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或者margin-right，margin值会加倍。这种情况下IE会产生20px的距离，解决方案是在float的标签样式控制中加入display：inline;将其转化为行内属性，，只有IE会识别） 项目： 1.跨域 2.javascript数据类型 3.页面加载 4.字符串转化 5.jsonp原理 6.css合并方法 7.盒子模型 8.定位4，可以使用localStroage 5.function unique2(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i])==i)&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 8.父子通讯中最常见的数据传递方式就是通过props传递数据，就好像方法的传参一样，父组件调用子组件并传入数据， 9，默认时间是浏览器关闭就过期 1.re.exec(str) 2.分别是jsonp callback handler」 3.如何解决cookie安全性问题 1)设置cookie有效期不要过长,合适即可 2)设置HttpOnly属性为true:可以防止js脚本读取cookie信息,有效的防止XSS攻击 3)设置复杂的cookie，加密cookie ①cookie的key使用uuid，随机生成 ②cookie的value可以使用复杂组合，比如:用户名+当前时间+cookie有效时间+随机数 4)对保存到cookie里面的敏感信息必须加密 5)用户第一次登录时,保存IP+cookie加密后的token 每次请求,都去将当前cookie和ip组合起来加密后的tokenn与保存的token作对比,只有全对应才能验证成功。 4.vue和react的区别 相同点:①都支持服务器渲染②都有虚拟DOM,组件化开发，通过props参数进行父子组件数据的传递,都实现webComponent规范③数据驱动试图④都支持native的方案,React的React native，Vue的weex⑤都有管理状态,React有redux,Vue有自己的Vuex(自适应vue)⑥提供了响应式Reactive和组件化Composable的视图组件⑦将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。 5.如何实现浏览器内多个标签页之间的通信？ 6.编写一个方法,去掉一个var datas=[1,3,4,4,5,3,2,1]的重复元素 7.怎么理解MVVM模式这些框架 8.vue中父子组件如何通信并阐述以下vue的生命周期 9.cookie不设置过期时间，默认过期时间是多少？如何保证cookie的安全？ 10.描述对MVVM、MVC设计模式的认识 11.JS哪些操作会造成内存泄漏 12.浏览器缓存有哪些，通常缓存有哪几种 13.http和https有何区别?如何灵活使用? 14.react和vue有哪些相同点和不同点，说说你对这两个框架的看法 15.xml和json的区别,请用四个词语来形容 16.解释css sprites,如何使用 17.一个200*200的div在不同分辨率屏幕上下左右居中，用css实现 12ng-show/ng-hide与ng-if的区别 解释下什么是rootScrope以及scope的区别]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue后台管理项目出现的问题]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F15%2Fvue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vue后台管理项目问题1在渲染展开行表格时,以前直接写数据,渲染是没有问题的,但是今天写完之后总是提示一个问题 以前的写法 12345678910111213141516171819202122232425&lt;el-table :data=&quot;roles&quot; height=&apos;480px&apos; style=&quot;width: 100%&quot;&gt; &lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;right&apos;&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项一&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项二&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt;&lt;span&gt;选项三&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;#&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleName&quot; label=&quot;角色名称&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleDesc&quot; label=&quot;角色描述&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; error 123456789101112vue.runtime.esm.js?2b0e:619 [Vue warn]: Error in callback for watcher &quot;data&quot;: &quot;Error: if there&apos;s nested data, rowKey is required.&quot;found in---&gt; &lt;ElTable&gt; at packages/table/src/table.vue &lt;ElCard&gt; at packages/card/src/main.vue &lt;Roles&gt; at src/components/roles.vue &lt;ElMain&gt; at packages/main/src/main.vue &lt;ElContainer&gt; at packages/container/src/main.vue... (1 recursive calls) &lt;Home&gt; at src/components/home.vue &lt;App&gt; at src/App.vue &lt;Root&gt; 123456789101112131415161718分析文档之后加看控制台错误需要添加row-key属性,给表格添加属性&lt;el-table :data=&quot;roles&quot; row-key=&apos;id&apos; height=&apos;480px&apos; style=&quot;width: 100%&quot;&gt;&lt;/el-table&gt;才能正确渲染,否则无法显示表格数据,但是添加row-key之后,又会报错,[Vue warn]: Duplicate keys detected: &apos;137&apos;. This may cause an update error.found in---&gt; &lt;ElTableBody&gt; &lt;ElTable&gt; at packages/table/src/table.vue &lt;ElCard&gt; at packages/card/src/main.vue &lt;Roles&gt; at src/components/roles.vue &lt;ElMain&gt; at packages/main/src/main.vue &lt;ElContainer&gt; at packages/container/src/main.vue... (1 recursive calls) &lt;Home&gt; at src/components/home.vue &lt;App&gt; at src/App.vue &lt;Root&gt;这个错误无法解决,虽然不影响表格正常渲染]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack配置]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack配置1. webpack安装12webpack全局安装: npm i webpack -gwebpack局部安装: 在项目依赖中运行 npm i webpack --save-dev安装到项目依赖中 2. webpack的引入123Gulp:webpack: 是基于项目进行构建的webpack 要打包的文件的路径 打包好的输出文件的路径 2.1 webpack安装123456789安装webpack，首先需要安装最新版本的Node.js1.安装特定版本 npm install --save-dev webpack npm install --save-dev webpack@&lt;version&gt;2.安装webpack4+以上需要安装webpack cli npm install --save-dev webpack-cli3.对于大多数项目，我们建议本地安装4.全局安装 npm install --global webpack 2.2 隔行变色-使用webpack解析main.js123456789101112131415161718192021222324252627282930313233mian.jsimport $ from &apos;jQuery&apos;;$(function()&#123; $(&apos;li:odd&apos;).css(&apos;background&apos;,&apos;red&apos;); $(&apos;li:even&apos;).css(&apos;background&apos;,function()&#123; return &apos;#D97634&apos;; &#125;);&#125;);index.html&lt;script src=&quot;../src/main.js&quot;&gt;&lt;/script&gt;&lt;ul&gt; &lt;li&gt;这是第1个元素&lt;/li&gt; &lt;li&gt;这是第2个元素&lt;/li&gt; &lt;li&gt;这是第3个元素&lt;/li&gt; &lt;li&gt;这是第4个元素&lt;/li&gt; &lt;li&gt;这是第5个元素&lt;/li&gt; &lt;li&gt;这是第6个元素&lt;/li&gt; &lt;li&gt;这是第7个元素&lt;/li&gt; &lt;li&gt;这是第8个元素&lt;/li&gt; &lt;li&gt;这是第9个元素&lt;/li&gt; &lt;li&gt;这是第10个元素&lt;/li&gt;&lt;/ul&gt;使用npm run serve运行之后,页面中的元素出现后又闪退,控制台报错: Uncaught SyntaxError: Unexpected token import旧版本的浏览器不能识别ES6,可以首先将main.js文件解析之后,再在index.html文件中引入解析之后的文件使用wqebpack解析main.js文件解析为dist/list.js,在index.html文件中引入在index文件中引入main.js文件之后,浏览器不能识别ES6语法,控制台报错,此时需要通过webpack将main.js文件解析为浏览器可以识别的语法命令一:webpack ./main.js ./dist/bundle.js然后在index.html文件中引入bundle.js即可 2.3 webpack基本的文件配置123456789101112131415webpack.config.js配置文件const path = require(&apos;path);module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;&#125;配置文件之后,运行webpack,修改main.js文件中的代码即可实时在页面上显示出来，否则需要重新 运行 webpack ./main.js ./dist/bundle.js 2.4 webpack-dev-server的基本使用123456789101112131415161718191.配置webpack.config.js文件并配置入口、出口之后,每次修改main.js文件的的内容都需要重新运行webpack指令,所以需要优化2.使用webpack-dev-server这个工具来实现自动打包(实时打包)编译的功能 2.1运行npm i webpack-dev-serve -D把这个工具安装到项目的本地开发依赖 2.2安装完毕后,这个工具的用法和webpack命令的用法完全和webpack一样 node nodemon webpack webpack-dev-serve 2.3webpack-dev-serve是在本地安装的不能再终端直接运行 在package.json文件中,配置scripts &quot;scripts&quot;: &#123; 配置一些需要运行的命令 &quot;test&quot;:&quot;echo \&quot;Error:no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot; &#125; 2.4webpack-dev-serve这个工具,如果想要正常运行,要求,在本地项目中，必须安装webpack 2.5运行npm run dev3.在main.js文件中引入的bundle.js不是dist/bundle.js,而是npm run dev之后运行并托管在网站根目录的/bundle.js4.webpack output is served from / webpack输出文件被托管于项目根目录5.webpack-dev-server帮我们打包生成的bundle.js文件，并没有存放到实际的物理磁盘上,而是直接托管到了电脑的内存中,所以,我们在项目根目录中根本找不到这个打包好的bundle.js文件6.webpack把打包好的文件以一种虚拟的形式托管到了项目的根目录,虽然我们看不到它,但是可以认为和dist src node_modules平级,有一个看不见的文件,叫做bundle.js 2.5 webpack-dev-server的常用命令参数123456789101112131415在package.json文件中,配置scripts&quot;scripts&quot;: &#123; 配置一些需要运行的命令 &quot;test&quot;:&quot;echo \&quot;Error:no test specified\&quot; &amp;&amp; exit 1&quot;, 1)配置webpack-dev-server命令 &quot;dev&quot;:&quot;webpack-dev-server&quot;, 2)配置打包完成后自动打开浏览器 &quot;dev&quot;:&quot;webpack-dev-server --open&quot;, 3)配置打包完成后自动打开浏览器 并修改默认8080端口 &quot;dev&quot;:&quot;webpack-dev-server --open --port 3000&quot;, 4)配置打包完成后自动打开浏览器 并修改默认8080端口 打开浏览器默认显示跟路径下的文件列表,修改为显示网站首页 打开src下的index.html文件 &quot;dev&quot;:&quot;webpack-dev-server --open --port 3000 --contentBase src&quot;, 5)--hot 页面样式局部刷新 &quot;dev&quot;:&quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot;,&#125; 2.6 webpack-dev-server配置命令的第2种方法123456789101112131415161718192021222324252627282930313233第一步:package.json文件中配置&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125;第二步:在webpack.config.js文件中const path = require(&apos;path);启用热更新的第二步const webpack = require(&apos;webpack&apos;);module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;, 配置dev-server命令参数第二种方式 devServer: &#123; open: true, //自动打开浏览器 port: 3000, //设置启动时候的运行端口,默认是8080 contentBase: &apos;src&apos;, //指定托管的根目录 hot: true //启用热更新 启用热更新的第一步 &#125;, 启用热更新的第三步 plugins: [ 配置插件节点 new webpack.HotModuleReplacementPlugin() //new一个热更新的模块对象 ]&#125;第三步: 此时运行npm run server控制台会报错, Hot Module Replacement id disabled。 热更新被禁用第四步:配置热更新需要的步骤第五步:npm run dev 2.7 html-webpack-plugin的两个基本作用12345678910111213141516171819202122232425262728293031323334353637383940414243我们在浏览器打开的页面是属于物理磁盘的,而bundle.js文件是属于内存的。而我们需要把页面也放到内存中去,通过插件来实现配置启动页面:html-webpack-plugin1.安装: npm i html-webpack-plugin -D2.配置:webpack.config.js const path = require(&apos;path); 启用热更新的第二步 const webpack = require(&apos;webpack&apos;); 引入配置启动页面的插件 只要是插件,都一定要放到 plugins 节点中去 const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;, 配置dev-server命令参数第二种方式 devServer: &#123; open: true, //自动打开浏览器 port: 3000, //设置启动时候的运行端口,默认是8080 contentBase: &apos;src&apos;, //指定托管的根目录 hot: true //启用热更新 启用热更新的第一步 &#125;, 启用热更新的第三步 plugins: [ 配置插件节点 new webpack.HotModuleReplacementPlugin(), //new一个热更新的模块对象 配置启动页面的插件 new htmlWebpackPlugin(&#123; 创建一个在内存中生成html页面的插件 template: path.join(__dirname, &apos;./src/index.html&apos;) //指定模板页面,将来会根据指定的页面路径,去生成内存中的页面 filename: &apos;index.html&apos; //指定生成的页面的名称 &#125;) ] &#125;3.运行: npm run dev4.生成内存中的index.html文件,当我们使用html-webpack-plugin之后，我们不再需要手动处理bundle.js的路径,因为这个插件帮我们自动创建了一个合适的script,并且引用了正确的了路径5.html-webpack-plugin插件作用 自动在内存中根据指定页面生成一个内存中的页面 自动打包好bundle.jd追加到页面中去 2.8 loader-配置处理css样式表的第三方loader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521.如果在index.html文件中直接引入样式文件，会发起二次请求,不建议使用&lt;link rel=&apos;stylesheet&apos; href=&apos;./css/index.css&apos;&gt;2.使用import &apos;./src/index.css&apos;运行会出现错误,需要一个合适的loader来处理这种类型的文件 you can need an appropriate loader to handle this file type. li &#123; list-style: none; &#125;3.注意: webpack默认只能打包处理js类型的文件,无法处理其他非js类型的文件,如果非要处理非js类型的文件,我们需要手动安装一些合适的第三方loader加载器4.处理样式loader4.1安装 如果想要打包处理css文件,需要安装npm i style-loader css-loader -D4.2配置 webpack.config.js 在里面新增一个配置节点 module 是一个对象,在这个module对象身上,有一个rules属性,这个rules属性是个数组,这个数组中，存放了所有第三方文件的匹配和处理规则const path = require(&apos;path); 启用热更新的第二步 const webpack = require(&apos;webpack&apos;); 引入配置启动页面的插件 只要是插件,都一定要放到 plugins 节点中去 const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;, 配置dev-server命令参数第二种方式 devServer: &#123; open: true, //自动打开浏览器 port: 3000, //设置启动时候的运行端口,默认是8080 contentBase: &apos;src&apos;, //指定托管的根目录 hot: true //启用热更新 启用热更新的第一步 &#125;, 启用热更新的第三步 plugins: [ 配置插件节点 new webpack.HotModuleReplacementPlugin(), //new一个热更新的模块对象 配置启动页面的插件 new htmlWebpackPlugin(&#123; 创建一个在内存中生成html页面的插件 template: path.join(__dirname, &apos;./src/index.html&apos;) //指定模板页面,将来会根据指定的页面路径,去生成内存中的页面 filename: &apos;index.html&apos; //指定生成的页面的名称 &#125;) ], module: &#123; //这个节点配置所有的第三方模块的加载器 rules: [ 所有第三方模块的匹配规则 &#123;test: /\.css$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;&#125;&#125; //匹配所有以css结尾的文件,用后面的加载器来处理,先调用后面的loader，将处理的结果交给前面的loader处理 ] &#125; &#125;5.运行 npm run dev 2.9 webpack处理第三方文件类型loader的过程12341.发现这个要处理的文件不是js文件,然后就去配置文件中,查找有没有对应的第三方loader规则2.如果能找到对应的规则,就会调用对应的loader处理这种文件类型3.在调用loader的时候，是从后往前调用的4.当最后loader调用完毕后，会把处理的结果直接交给webpack进行合并,最终输出到bundle.js文件中去 2.10 配置处理less文件的loader1234567891011121314import &apos;./css/index.less&apos;报错:没有处理这种类型文件的loader1.安装 安装loader加载器 npm i less-loader -D 安装依赖项 npm i less -D 不需要显示引入,是less-loader加载器内部依赖的2.在配置文件 webpack.config.js文件中配置module: &#123; //这个节点配置所有的第三方模块的加载器 rules: [ 所有第三方模块的匹配规则 &#123;test: /\.css$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;&#125;&#125;, //匹配所有以css结尾的文件,用后面的加载器来处理,先调用后面的loader，将处理的结果交给前面的loader处理 &#123;test: /\.less$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;&#125;&#125; //配置处理.less文件的第三方loader规则 ]&#125; 2.11 配置处理scss文件的loader123456789101112131415import &apos;./css/index.scss&apos;报错:没有处理这种类型文件的loader1.安装 安装loader加载器 npm i sass-loader -D 安装依赖项 一般安装node-sass是下载不下来,需要使用cnpm来安装 cnpm i node-sass -D 不需要显示引入,是less-loader加载器内部依赖的2.在配置文件 webpack.config.js文件中配置module: &#123; //这个节点配置所有的第三方模块的加载器 rules: [ 所有第三方模块的匹配规则 &#123;test: /\.css$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;&#125;&#125;, //匹配所有以css结尾的文件,用后面的加载器来处理,先调用后面的loader，将处理的结果交给前面的loader处理 &#123;test: /\.less$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;&#125;&#125;, //配置处理.less文件的第三方loader规则 &#123;test: /\.scss$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;&#125;&#125; //配置处理.scss文件的第三方loader规则 ]&#125; 2.12 复习webpack基本配置12345678910111213141516171819202122232425262728293031323334353637381. webpack ./src/main.js ./dist/bundle.js2.由于每次都需要配置 打包哪个文件 打包到哪个文件，所以配置webpack.config.js文件,配置入口和出口，输入webpack命令即可打包3.由于每次修改完之后，必须输入webpack命令才能打包,所以安装webpack-dev-server实时监测文件的变化,进行打包 实时打包 安装: npm i webpack-dev-server -D 安装webpack-dev-server提示需要安装 npm i webpack 配置: package.json 中配置 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot; &#125; 配置webpack.config.js 配置入口和出口 运行: npm run dev 报错: bundle.js文件报错 如果不想手动引入bundle.js,需要在内存中自动生成一个index.html文件来自动引入bundle.js4.安装 html-webpack-plugin 在内存中根据指定的模板页面，生成一份内存中的首页,同时自动把打包好的bundle.js文件注入到首页底部 安装: npm i html-webpack-plugin -D 在webpack.config.js文件中引入插件,并在plugins中配置插件 引入插件 var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); 配置插件 plugins: [ new htmlWebpackPlugin(&#123; template: path.join(__dirname,&apos;./src/index.html&apos;), 指定模板文件路径 filename: &apos;index.html&apos; 设置生成的内存页面的名称 &#125;) ]5.配置css样式文件、less文件、scss文件如果直接在main.js文件中直接引入样式文件,需要 import &apos;./src/index.css&apos;,运行命令npm run dev时,不能处理这种类型的文件，需要安装合适的加载器 安装对应的loader加载器 npm i style-loader css-loader 在webpack.config.js文件中配置 module: &#123; 配置所有第三方模块的规则 rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125;, 处理css文件的loader npm i less-loader less -D 依赖于less &#123;test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;, 处理css文件的loader npm i sass-loader node-sass -D 依赖于sass &#123;test: /\.scss$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;, 处理css文件的loader ] &#125; 2.13 webpack中url-loader的使用12345678910111213141516171819202122232425index.less html,body &#123; width: 200px; height: 200px; background: url(&apos;../images/11.png&apos;); background-size: cover; &#125;运行命令: npm run dev,控制台报错,不能处理这种类型的文件,默认情况下,webpack无法处理css文件中的url地址,不管是图片还是字体库,只要是url地址，都无法处理解决方法: 安装: npm i url-loader file-loader -D url-loader内部依赖于file-loader 配置: webpack.config.js module: &#123; 配置所有第三方模块的规则 rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125;, 处理css文件的loader npm i less-loader less -D 依赖于less &#123;test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;, 处理css文件的loader npm i sass-loader node-sass -D 依赖于sass &#123;test: /\.scss$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;, 处理css文件的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader&apos;&#125;, 处理图片路径的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&apos;&#125;, 处理图片路径的loader,当图片的字节数大于限制的大小时，不会编码 limit给定的值,是图片的大小,单位是byte,如果我们引用的图片大于或者等于给定的limit值,则不会被转为base64格式的字符串,如果图片小于给定的limit值,则会被转为base64的字符串 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[hash:8]-[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突,对于命名冲突的文件,使用[hash:8]-来解决,哈希截取8位 ] &#125; 2.14 webpack中使用url-loader处理字体文件123456789101112131415161718import &apos;Bootstrap/bootstrap.css&apos; 安装: npm i url-loader file-loader -D url-loader内部依赖于file-loader 配置: webpack.config.js module: &#123; 配置所有第三方模块的规则 rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125;, 处理css文件的loader npm i less-loader less -D 依赖于less &#123;test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;, 处理css文件的loader npm i sass-loader node-sass -D 依赖于sass &#123;test: /\.scss$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;, 处理css文件的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader&apos;&#125;, 处理图片路径的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&apos;&#125;, 处理图片路径的loader,当图片的字节数大于限制的大小时，不会编码 limit给定的值,是图片的大小,单位是byte,如果我们引用的图片大于或者等于给定的limit值,则不会被转为base64格式的字符串,如果图片小于给定的limit值,则会被转为base64的字符串 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[hash:8]-[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突,对于命名冲突的文件,使用[hash:8]-来解决,哈希截取8位 &#123;test: /\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos;&#125;, ] &#125; 2.15 webpack中babel的配置12345678910class是ES6中提供的新语法,用来实现ES6中面向对象编程的方式class Person &#123; 使用static关键字，可以定义静态属性 所谓静态属性就是可以直接通过类名,直接访问的属性 实例属性:只能通过类的实例来访问的属性 static info = &#123;name: &apos;zs&apos;,age: 20&#125;&#125;console.log(Person.info);1.在控制台运行以上代码时会报错,在webpack中,默认只能处理一部分ES6的新语法,一些跟高级的ES6语法或者ES7语法,webpack是处理不了的,这时候，就需要借助于第三方的loader来帮助webpack处理一些高级的语法,当第三方loader把高级语法转化为低级的语法之后,会把结果交给webpack去打包到bundle.js中2.通过Babel,可以帮我们把高级语法转换为低级语法 Babel配置12345678910111213141.在webpack中,可以运行如下两套命令，安装包,去安装Babel相关的loader功能 两套全部安装 第一套包: cnpm i babel-core babel-loader babel-plugin-transform-runtime -D 第二套包: cnpm i babel-preset-env babel-preset-stage-0 -D2.配置 在webpack.config.js文件中,在module节点下的rules数组中,添加一个新的匹配规则 2.1 &#123;test: /\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/&#125; 排除node_modules中的文件 2.2 注意: 在配置babel的loader规则的时候,必须把node_modules目录,通过exclude选项排除掉 2.2.1如果不排除node_modules,则Babel会把node_modules中所有的第三方js文件都打包编译,这样会非常消耗CPU,同时，打包速度非常慢 2.2.2 如果把node_modules中的js转换完毕了,但是项目也无法正常运行3.在项目的根目录中，新建一个.babelrc 的Babel的配置文件,这个配置文件属于JSON格式,必须符合JSON规范4.在.babelrc下写如下的配置&#123; &quot;presets&quot;: [&quot;env&quot;,&quot;stage-0&quot;], 预设 语法 &quot;plugins&quot;: [&quot;transform-runtime&quot;] 插件&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue知识总结]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fvue%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[vue知识总结扩展链接12345vuejs:vuejs.orgvuejs中文网: cn.vuejs.orgvue开源项目汇总: https://github.com/opendigg/awesome-github-vueNode中文社区: https://cnodejs.orgVue中文社区: https://www.vue-js.com 优化SEO1231.meta设置2.友情链接3.减少IFrame使用 优化网站14条123451.减少DOM2.减少HTTP请求：精灵图 打包css和js库3.压缩5.CDN加载6.语义标签的使用 vue总结123456789101112131415161718192021222324mint-ui- 移动端组件库,- https://mint-ui.github.io/#!/zh-cnmui- 前端UI框架 -&gt; user interface- 栅格系统- http://www.dcloud.io/hellomui/examples/grid-default.html- 代码: mui-master\examples\hello-mui\examplesi18n- internationalization- 国际化- index.html -&gt; 中国人- index.html -&gt; 美国人- vue-i18n资源-https://mint-ui.github.io/#!/zh-cnwappalyzer- 获取到当前网站的使用的技术- https://wappalyzer.com/download 使用代理跨域12345678devServer: &#123; proxy: &#123; &apos;/v2/*&apos;: &#123; target: &apos;https://api.douban.com/&apos;, changeOrigin: true, &#125; &#125;&#125; vue生命周期参考listentime.github.io https://listentime.github.io/list/asset/lifecycle.png]]></content>
  </entry>
  <entry>
    <title><![CDATA[内置对象]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Math的常用方法1234567891011121314151617181920212223//绝对值Math.abs(num)//向上取整Math.ceil(num)//向下取整Math.floor(num)//返回多个数字的最大值Math.max(num)//返回多个数字的最小值Math.min(num)//返回一个0-1的随机数Math.random()//四舍五入Math.round(num)//返回一个数的整数部分Math.trunc(num) Date的常用方法1234567891011121314151617181920//创建当前时间 var dt = new Date()//获取年 var year = dt.getFullYear()//获取月 var month = dt.getMonth()+1//获取日 var day = dt.getDate()//获取时 var h = dt.getHours()//获取分 var m = dt.getMinutes()//获取秒 var s = dt.getSeconds() Array的常用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//返回数组的长度arr.length//返回一个截取的数组arr.slice(2,4)//对数组进行排序arr.sort()// 数组反转arr.reverse()//判断数组类型Array.isArray(arr)//等效于arr instanceof Array//判断数组中是否包含这个值arr.includes(5)//如果存在,则返回第一个元素的下标,否则返回-1arr.indexOf(5)//如果存在,则返回最后一个元素的下标,否则返回-1lastIndexOf(5)//数组遍历//循环遍历arr.forEach( x =&gt; console.log(x) )//对数组进行遍历测试,通过返回true,否则falsearr.every( x =&gt; x&gt;0 )//对数组进行遍历测试,通过返回false,否则truearr.some( x =&gt; x&gt;0 )//过滤数组,通过则返回当前元素arr.filter( x =&gt; x&gt;5 )//找到数组中满足条件,的第一个元素的值arr.find( x =&gt; x&gt;5 )//满足条件,则返回第一个元素的下标,否则返回0arr.findIndex( x =&gt; x&gt;5 )//对每一个元素调用函数并返回新数组arr.map( x =&gt; x+1 )//对所有元素求和arr.reduce( (x,y) =&gt; x+y )//也可以拼接字符串arr.reduce( (x,y) =&gt; x+&quot;,&quot;+y )数组操作//删除数组中最后一个元素,并返回该元素arr.pop()//删除数组中第一个元素,并返回该元素arr.shift()//将指定元素添加到数组的开头arr.unshift()//将元素追加到数组的最后arr.push()// 从索引为2的位置删除一项arr.splice(2, 1)// 在索引为2的位置插入10arr.splice(2, 0, 10)// 从索引为2的位置删除一项再插入10arr.splice(2, 1, 10)//把若干参数合并为数组Array.of(1,2,3)//合并两个数组并返回arr1.concat(arr2)//把字符串拆分成伪数组Array.from(&quot;string&quot;)//让数组以指定字符拼接arr.join(&quot;-&quot;)//把数组转换成字符串arr.toString()//可以转换时间,数字,字符串arr.toLocaleString() String1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 获取字符串的长度&apos;hello&apos;.length// 获取指定索引的字符&apos;hello&apos;.charAt(3)// 获取指定字符首次出现的索引&apos;hello&apos;.indexOf(&apos;l&apos;)// 获取指定字符最后出现的索引&apos;hello&apos;.lastIndexOf(&apos;l&apos;)// 查找指定字符出现的位置&apos;hello&apos;.search(&apos;l&apos;)// 对指定字符串进行替换&apos;hello&apos;.replace(&apos;l&apos;, &apos;o&apos;)// 把字符串分割成数组&apos;hello word&apos;.split(&apos; &apos;)// 大写转换小写&apos;HELLO&apos;.toLowerCase()// 小写转换大写&apos;hello&apos;.toUpperCase()// 大写转换小写(根据地区)&apos;HELLO&apos;.toLocaleLowerCase()// 小写转换大写(根据地区)&apos;hello&apos;.toLocaleUpperCase()// 把指定索引的字母转换成编码&apos;hello&apos;.codePointAt(0)// 把编码转换成字母String.fromCodePoint(65)// 截取指定索引字符串&apos;hello&apos;.slice(0, -3)// 截取指定长度的字符串&apos;hello&apos;.substr(1, 3)// 截取指定索引字符串&apos;hello&apos;.substring(1, 3)// 拼接字符串&apos;hello&apos;.concat(&apos;wo&apos;, &apos;rd&apos;)// 以指定长度在后面进行重复填充&apos;hello&apos;.padEnd(10, &apos;-&apos;)// 以指定长度在前面进行重复填充&apos;hello&apos;.padStart(10, &apos;-&apos;)// 将字符串重复整数次&apos;hello&apos;.repeat(2) // 判断是否包含指定字符&apos;hello&apos;.includes(&apos;ll&apos;)// 判断是否已指定字符开头&apos;hello&apos;.startsWith(&apos;he&apos;)// 判断是否以指定字符结尾&apos;hello&apos;.endsWith(&apos;lo&apos;)// 去除两边空格&apos;hello&apos;.trim()// 去除左边空格&apos;hello&apos;.trimLeft()// 去除右边空格&apos;hello&apos;.trimRight()]]></content>
  </entry>
  <entry>
    <title><![CDATA[H5C3]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2FH5C3%2F</url>
    <content type="text"><![CDATA[H5C3 API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861.存储数据1.1 sessionStorage 特点: 1.存储数据到本地，存储的容量5MB左右 2.这个数据本质是存储在当前页面的内存中 3.关闭页面数据会自动清除 window.sessionStorage.setItem(key,value); setItem(key,value);存储数据，以键值对的方式存储 getItem(key);获取数据，通过指定名称的key获取对应的value值 removeItem(key);删除数据,通过指定名称key删除对应的值 clear();清空所有存储的内容 如果没有存储就获取sessionStorage,那么获取的是null. 如果在删除数据的时候，key值错误,不会报错，但是也不会删除数据1.2 localStorage 特点: 1.存储的内容大概20MB 2.不同浏览器不能共享数据,但是在同一个浏览器的不同窗口中可以共享数据 3.永久生效，它的数据是存储在硬盘上，并不会随着页面或者浏览器的关闭而清除1.3 网络状态 // 通过window.navigator.onLine可以返回当前的网络状态 alert(window.navigator.onLine); window.addEventListener(&apos;online&apos;, function () &#123; //alert(&apos;online&apos;); $(&apos;.tips&apos;).text(&apos;网络已连接&apos;).fadeIn(500).delay(1000).fadeOut(); &#125;); window.addEventListener(&apos;offline&apos;, function () &#123; //alert(&apos;offline&apos;); $(&apos;.tips&apos;).text(&apos;网络已断开&apos;).fadeIn(500).delay(1000).fadeOut(); &#125;);1.4 文件读取 &lt;input type=&quot;file&quot; class=&quot;file&quot; multiple&gt; &lt;script&gt; /*获取到了文件表单元素*/ var file = document.querySelector(&apos;.file&apos;); /*选择文件后触发*/ file.onchange = function () &#123; /*初始化了一个文件读取对象*/ var reader = new FileReader(); /*读取文件数据 this.files[0] 文件表单元素选择的第一个文件 */ reader.readAsDataURL(this.files[0]); /*读取的过程就相当于 加载过程 */ /*读取完毕 预览 */ reader.onload = function () &#123; /*读取完毕 base64位数据 表示图片*/ console.log(this.result); document.querySelector(&apos;#img&apos;).src = this.result; &#125; &#125; &lt;/script&gt;1.5 拖拽 // 整个拖拽都会执行 box.addEventListener(&apos;drag&apos;, function (e) &#123; console.log(&apos;drag&apos;); &#125;); // 拖拽的点离开当前盒子 box.addEventListener(&apos;dragleave&apos;, function () &#123; console.log(&apos;dragleave&apos;); &#125;); // 拖拽开始 box.addEventListener(&apos;dragstart&apos;, function () &#123; this.style.backgroundColor = &apos;red&apos;; console.log(&apos;dragstart&apos;) &#125;); // 拖拽结束 box.addEventListener(&apos;dragend&apos;, function (ev) &#123; this.style.backgroundColor = &apos;&apos;; console.log(&apos;dragend&apos;); &#125;); //在目标元素上移动 container.addEventListener(&apos;dragover&apos;, function (e) &#123; this.style.backgroundColor = &apos;yellow&apos;; console.log(&apos;目标dragover&apos;); e.preventDefault(); &#125;); //在目标元素离开 container.addEventListener(&apos;dragleave&apos;, function (e) &#123; this.style.backgroundColor = &apos;&apos;; console.log(&apos;目标dragleave&apos;); e.preventDefault(); &#125;); //在目标元素松开 container.addEventListener(&apos;drop&apos;, function (e) &#123; this.style.backgroundColor = &apos;black&apos;; console.log(&apos;目标drop&apos;); e.preventDefault(); &#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[双飞翼布局]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[双飞翼布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .container &#123; height: 300px; &#125; .column &#123; float: left; height: 300px; &#125; .left &#123; width: 200px; background-color: pink; margin-left: -100%; &#125; .right &#123; width: 250px; background-color: purple; margin-left: -250px; &#125; .main &#123; width: 100%; background-color: orange; &#125; .inner &#123; margin: 0 250px 0 200px; word-break: break-all; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column main&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;!--双飞翼布局 内部添加了一个盒子--&gt; what&apos;s your name ? &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[###圣杯布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; min-width: 700px; &#125; .container &#123; height: 300px; padding: 0 250px 0 200px; &#125; .column &#123; float: left; height: 300px; &#125; .left &#123; width: 200px; background-color: pink; margin-left : -100%; position: relative; left: -200px; &#125; .right &#123; width: 250px; background-color: purple; margin-left: -250px; position: relative; right: -250px; &#125; .main &#123; width: 100%; background-color: orange; word-break: break-all; /*自动换行*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column main&quot;&gt; my name is andy &lt;/div&gt; &lt;div class=&quot;column left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuex状态管理流程]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fvuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vuex-状态管理流程1234组件中的数据:写在state中state:组件的数据声明 数据(组件之间需要共享/传值)声明Actions:发请求 和后台交互 异步操作 和后台交互的异步操作 =ajaxMutations:改数据 改变state的方法 1.1 vuex-state和mapState123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761.新建项目 vue init webpack-simple democd xx npm i npm run dev2.下载插件 npm i vuex3.导入main.jsimport Vuex from &apos;vuex&apos;配置Vue.use(Vuex);实例化 store仓库、存储const store = new Vuex.Store(&#123; state:&#123; num: 0; 可以在项目的任意一个组件中去使用 &#125;&#125;);4.挂载new Vue(&#123; el:&apos;&apos;, store: store, ......&#125;);5.App.vue&lt;template&gt; &lt;div&gt; 1.使用仓库中的数据 vuex中的store中的state中的数据num &#123;&#123;$store.state.num&#125;&#125; 2.把状态中的数据变成组件中的计算属性 &#123;&#123;abc&#125;&#125; 3.辅助函数mapState &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export defalut &#123; data()&#123; return&#123; msg: &apos;abc&apos; &#125; &#125;, 2.计算属性 computed: &#123; 计算属性名字：带有返回值的函数 abc()&#123; return this.$store.state.num; &#125; &#125; 3.辅助函数 mapState 1)导入 import &#123;mapState&#125; from &quot;vuex&quot;; 2)computed: mapState([]/&#123;&#125;); mapState()里面的参数可以是对象可以是数组 3.1.传对象 computed: mapState(&#123; 1. 计算属性的名字:仓库中的数据 带有返回值的函数 mapState的计算属性，内置一个参数,state count(state)&#123; return state.num; &#125; 2.简化 count: state =&gt;&#123; return state.num; &#125; 3. 简化 count: &quot;num&quot; &#125;) 3.2.传数组 computed: mapState([&quot;count&quot;]) 4.辅助函数 computed: &#123; ...mapState(&#123; num: &quot;num&quot; &#125;); mapState()方法有返回值,会返回一个对象，如果想使用对象里面的数据，需要通过解构赋值来使用 &#123;count: &quot;count&quot;&#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456789data和state中的数据都是响应式数据 数据声明state作用：写数据的声明state中的数据是响应式的state中的数据可以在任意组件使用配合计算属性和mapState一起使用computed: &#123; ...mapState(&#123;count: &quot;count&quot;&#125;); 对象 ...mapState([&quot;msg&quot;]); 数组&#125; 1.2 vuex-getters和mapGetters1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253当状态state中的数据比较复杂时,这个复杂数据写在状态中可以，但是不合理，此时，需要把状态中的复杂数据改写到getters中。main.jsimport Vuex from &apos;vuex&apos;Vue.use(Vuex);const store = new Vuex.Store(&#123; state:&#123; num: 0; msg: &apos;abc&apos; a是个复杂数据,依赖了其他state的数据,需要写在getters中，类似于计算属性 &#125;, getters: &#123; a是一个函数，而且带有返回值 a(state)&#123; return state.msg + &quot;xyz&quot;; &#125; &#125;&#125;);new Vue(&#123; el:&apos;&apos;, store: store, ......&#125;);App.vue1.通过插值表达式渲染&#123;&#123;$store.getters.a&#125;&#125;2.&#123;&#123;A&#125;&#125;import &#123;mapState,mapGetters&#125; form &quot;vuex&quot;export default &#123; 2.计算属性的用法 computed: &#123; A()&#123; return this.$store.getters.a; &#125; &#125; 3.getters辅助函数 computed: mapGetters(&#123; 3.1 A: &quot;a&quot; 3.2 3.3 不可行 3.2 A(getters)&#123; return getters.a; &#125; 3.3 A: (getters) =&gt; &#123; return getters.a; &#125; &#125;); 4. 传数组 computed: mapGetters([&quot;a&quot;]); 5.computed: &#123; ...mapGetters(&#123; a: &quot;a&quot; &#125;); &#125;&#125; 1234567891011getter中数据的用法和状态中数据的用法完全一样getters使用场景： 如果state中的数据很复杂,依赖了state中其他数据，此时需要把复杂数据写在getters中getters: &#123; A(state)&#123; return state.数据 + &apos;sfsaf&apos; return state.msg +&apos;sdsfsf&apos;; &#125;&#125;在组件中使用computed: mapGetters([&apos;A&apos;]); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 计算属性 // 第二种使用state状态中数据的方法 // computed: &#123; // num()&#123; // return this.$store.state.num; // &#125; // &#125;, // // 第三种使用计算属性的方法 辅助函数 // computed: mapState(&#123; // // 3.1 // // count(state)&#123; // // return state.num; // // &#125; // // 3.2 // // count: (state) =&gt; &#123; // // return state.num; // // &#125; // // 3.3 // // count: &quot;num&quot; // &#125;) // 第四种: 辅助函数中可以传入数组 // computed: mapState([ // &quot;num&quot; // ]) // 第五种 // computed: &#123; // ...mapState(&#123; // num: &apos;num&apos; // &#125;) // &#125; // getters使用 // 第一种使用方法 // computed: &#123; // count()&#123; // return this.$store.getters.count; // &#125; // &#125; // 第二种使用方法 // computed: mapGetters(&#123; // // count: &quot;count&quot; // &#125;) // 第三种方法 // computed: mapGetters([&quot;count&quot;]) // 第四种方法 // computed: &#123; // ...mapGetters(&#123; // count: &quot;count&quot; // &#125;) // &#125; 1.3 vue-mutations和mapMutations123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354mutations: 利用actions中返回的数据 修改state中的数据 写方法在vuex仓库中的mutations对象中定义函数在main.js文件中mutations: &#123; 因为是修改status中的数据，所以函数会自动传入参数status 方法一： fn(state)&#123; state.num ++; &#125; 方法二： count是形参 fn(state,count)&#123; state.num = state.num + count; &#125; 方法三： count 是一个对象 fn(state,count)&#123; state.num = state.num + count.age; &#125; 方法四： fn(state,count)&#123; state.num = state.num + count.age; &#125; 方法二、三、四： 调用方法时传实参,叫提交载荷 (payload)&#125;在组件中created()&#123; 方法一：通过仓库提交函数名 this.$store.commit(&apos;函数名&apos;); 方法二： commit参数可以传实参 this.$store.commit(&apos;函数名&apos;,100); 方法三： commit参数可以传实参 this.$store.commit(&apos;函数名&apos;,&#123; name: &apos;xxx&apos;, age: 20 &#125;); 方法四： fn1()&#123; this.$store.commit(&#123; type: &apos;fn&apos;, type:&apos;&apos; 函数名 age: 20 &#125;) &#125; 方法五： 导入 import &#123;mapState,mapGetters,mapMutations&#125; from &quot;vuex&quot;; ...mapMutations([&quot;fn&quot;]); 组件和vuex中的方法同名 这种方法如果要传参数，需要在组件中调用方法时传递参数 created()&#123; this.fn(&apos;mn); &#125; 相当于： fn()&#123; this.$store.commit(&apos;fn&apos;); &#125;&#125; main.js 12345678910111213141516171819202122232425262728293031323334import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;// 导入import vuex from &apos;vuex&apos;// 配置Vue.use(vuex);// 实例化 store 仓库const store = new vuex.Store(&#123; state: &#123; num: 100 &#125;, getters: &#123; count(state)&#123; return state.num + &apos;xyz&apos; &#125; &#125;, 调用方法修改state中的数据 mutations: &#123; fn(state)&#123; state.num ++; &#125; &#125;&#125;);new Vue(&#123; el: &apos;#app&apos;, data()&#123; return &#123; msg: &apos;abx&apos; &#125; &#125;, // 挂载 store, render: h =&gt; h(App)&#125;) app.vue 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;num&#125;&#125; &lt;button @click=&apos;fn1&apos;&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 通过辅助函数来使用state状态中的数据import &#123;mapState,mapGetters&#125; from &apos;vuex&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, // mutations使用 created()&#123; this.$store.commit(&apos;fn&apos;); &#125;, computed:&#123; ...mapState([&apos;num&apos;]) &#125;, methods:&#123; fn1()&#123; // 调用mutations中的方法,提交要执行的函数名字 this.$store.commit(&apos;fn&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 1.4 vuex-actions和maoActions12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061复习：main.jsimport Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;// 导入import vuex from &apos;vuex&apos;// 配置Vue.use(vuex);// 实例化 store 仓库const store = new vuex.Store(&#123; state: &#123; num: 100 &#125;, mutations: &#123; fn(state,payload)&#123; state.num = payload; &#125; &#125;&#125;);new Vue(&#123; el: &apos;#app&apos;, data()&#123; return &#123; msg: &apos;abx&apos; &#125; &#125;, // 挂载 store, render: h =&gt; h(App)&#125;)app.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;num&#125;&#125; &lt;button @click=&apos;fn&apos;&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 通过辅助函数来使用state状态中的数据import &#123;mapState,mapGetters, mapMutations&#125; from &apos;vuex&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; &#125; &#125;, created()&#123; this.fn(&quot;mn&quot;); &#125;, computed:&#123; ...mapState([&apos;num&apos;]) &#125;, methods:&#123; ...mapMutations([&apos;fn&apos;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657actions: 作用： 写方法/方法内部应该写的代码 是 异步操作 定时器 /ajax在异步操作有结果的位置调用mutations中的方法main.jsconst store = new vuex.Store(&#123; state: &#123; num: 100 &#125;, mutations: &#123; fn1(state,payload)&#123; state.num = payload; &#125; &#125;, // 作用：写方法／方法内部应该写的是 异步操作的代码 定时器／ajax // 在异步操作有结果的位置 调用mutations中的方法 actions: &#123; fn(context)&#123; // fn方法自带 context参数对象 contex t是仓库对象 ＝＝＝ this.$store setInterval(()=&gt; &#123; const temp = 2; // 调用mutations中的方法，同时传递temp context.commit(&apos;fn1&apos;,temp); &#125;); &#125; &#125;&#125;);app.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;num&#125;&#125; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 通过辅助函数来使用state状态中的数据import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; &#125; &#125;, created()&#123; this.fn1(&quot;mnmnm&quot;); this.fn(); &#125;, computed:&#123; ...mapState([&apos;num&apos;]) &#125;, methods:&#123; ...mapMutations([&apos;fn1&apos;]), ...mapActions([&quot;fn&quot;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 12345678910mutations: 中的方法是真正该数据的方法actions： 中的方法是从后台获取数据/定时器的方法 在异步操作有结果的位置 提交mutations中的方法，并且传递数据调用actions中的方法 组件 created()&#123; this.fn();&#125;,methods&#123; ...mapActions([&quot;fn&quot;])&#125; 1.5 vuex 总结123mutations: 必须是同步函数 修改state的数据state： 数据的声明actions: 异步获取数据的方法 在异步操作有结果的位置调用 mutations的方法 context.commit(&apos;函数名&apos;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件通信]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信1.1 父子组件通信-子传父1234567891011121.vuex=&gt;解决vue项目的状态管理问题=&gt;数据管理=&gt;组件数据通信=&gt;组件传值2.父传子 组件通信 在子组件中使用父组件传来的数据（props）1)在子组件props:[&apos;&apos;,&apos;&apos;] 字符串数组2)使用组件时 &lt;child-a :mag=&apos;父组件data中的值&apos;&gt; &lt;/child-a&gt;3)在子组件的template &#123;&#123;msg&#125;&#125;3.子传父子组件中自定义事件 : this.$emit(&apos;事件名&apos;,数据);自己组件中定义的自定义事件，可以在父组件中调用组件时，使用该事件this.$emit(&apos;xxx&apos;); xxx是事件名this.$emit(&apos;xxx&apos;,数据); 可以传两个参数 &lt;child-a @xxx=&apos;add()&apos;&gt;&lt;/child-a&gt; add()函数是写在父组件中的 父传子组件通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344parent.vue&lt;template&gt; &lt;div&gt; &lt;button @click=&apos;add()&apos;&gt;点我有惊喜哟&lt;/button&gt; &lt;child-a AAA=&apos;aaa&apos; BBB=&apos;bbb&apos;&gt;&lt;/child-a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import childA from &apos;./childA&apos;export default &#123; data()&#123; num: 100 &#125;, components:&#123; &apos;child-a&apos;: childA &#125;, methods: &#123; add()&#123; // this.$emit(&apos;事件名&apos;,数据); 定义自定义事件 this.$emit(&apos;xxx&apos;,this.num); console.log(&apos;子组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;child.vue&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;AAA&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;BBB&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;childA&apos;, props: [&apos;AAA&apos;,&apos;BBB&apos;]&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子传父组件通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253parent.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; 子组件中定义的自定义事件可以传数据 &lt;child @xxx=&apos;fn&apos;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;引入子组件import child from &apos;./child&apos;export default &#123; name: &apos;app&apos;, components: &#123; child &#125;, methods:&#123; fn(num)&#123; console.log(num); console.log(&apos;父组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;child.vue&lt;template&gt; &lt;div&gt; &lt;button @click=&apos;add()&apos;&gt;点我有惊喜哟&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import childA from &apos;./childA&apos;export default &#123; data()&#123; return&#123; num: 100 &#125; &#125;, methods: &#123; add()&#123; // this.$emit(&apos;事件名&apos;,数据); 定义自定义事件 this.$emit(&apos;xxx&apos;,this.num); console.log(&apos;子组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 1.2 兄弟组件通信1234567891011中央事件总线: 多个事件共享一个vmvue绑定事件:1)标签中绑定事件&lt;button @xxx=&apos;fn&apos;&gt;&lt;/button&gt;2)在methods:&#123; this.$on(&apos;事件名&apos;,fn); 绑定事件 第一个：事件名 第二个:函数 this.$on(&apos;xxx&apos;,()=&gt;&#123;&#125;); this.$emit(&apos;事件名&apos;,数据); 触发事件&#125;3)绑定和触发自定义事件必须是一个vm实例对象4)数据A传给数据B 组件A触发事件 组件B绑定事件 vm.vue 123import Vue from &apos;./vue&apos;;const vm = new Vue(&#123;&#125;);export default vm; childA.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;button @click=&apos;add()&apos;&gt;点我有惊喜哟&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import vm from &apos;./vm.js&apos;export default &#123; data()&#123; return&#123; num: 100 &#125; &#125;, methods: &#123; add()&#123; 触发 传数据 vm.$emit(&apos;com&apos;,this.num); console.log(&apos;sadfffafs&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; childB.vue 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import vm from &apos;./vm.js&apos;export default &#123; created()&#123; 绑定事件 vm.$on(&apos;com&apos;,(num) =&gt; &#123; console.log(num); console.log(&apos;数据传过来了&apos;); &#125;); &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; app.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;child @xxx=&apos;fn&apos;&gt;&lt;/child&gt; &lt;childA&gt;&lt;/childA&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./child&apos;import childA from &apos;./childA&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, components: &#123; child, childA &#125;, methods:&#123; fn(num)&#123; console.log(num); console.log(&apos;父组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[知识点汇总1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331.什么是盒模型,W3C盒模型与IE盒模型的区别有哪些？ box-sizing: border-box|content-box;2.js的函数参数是值传递还是地址传递？请阐述原因 值传递3.清除浮动的方法 ①父元素添加 overflow:hidden; 原理是BFC ②最后浮动元素后面添加 &lt;div style=&apos;clear:both&apos;&gt;&lt;/div&gt; ③双伪元素清除浮动 .clearfix::after&#123; content: &apos;&apos;, height: 0; line-height: 0; display: block; visibility: hidden; clear: both; &#125; .clearfix &#123; *zoom: 1; &#125;4.vue如何实现父子组件通信，以及非父子组件通信以及vue生命周期父子组件: 子组件 props: []子父组件: this.$emit(&apos;自定义函数&apos;,data);兄弟组件: 中央事件总线 共用一个vue实例 A：Vue.$emit(&apos;自定义函数&apos;,data); B：Vue.$on(&apos;自定义函数名&apos;,函数); vm.$emit(&apos;com&apos;,this.num); vm.$on(&apos;com&apos;,(num) =&gt; &#123; console.log(num); &#125;);5.前端跨域的解决方式 jsonp：script属性 服务器代理 反向代理 cors:6.闭包及优缺点 闭包: 能够读取其他函数内部的变量 优缺点: 避免全局变量被污染，不能及时释放变量的作用域5.对数组[46,54,2,67,62,43,47,58,17,33]进行冒泡的升序排序 function(arr)&#123; for(var i = 0; i &lt; arr.length-1; i++)&#123; for(var j = 0; j &lt; arr.length-1; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;6.写出以下代码在控制台的打印 new Promise(function executor(resolve)&#123; console.log(1); for(var i = 0; i &lt; 1000; i++)&#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2); &#125;).then(function()&#123; setTimeout(function()&#123; cnsole.log(3); &#125;,10); console.log(4); &#125;); setTimeout(function()&#123; console.log(5); &#125;,0); console.log(6); 1 2 6 5 7.cookieStorage和sessionStorage的区别 cookie: 保存在客户端，大小4k 设置过期时间保存在硬盘，没设置过期时间保存在内存中，没设置过期时间关闭浏览器就失效 存储类型是字符串 session: 保存在服务器，大小没有限制,安全性比cookie高 存储类型是对象 sessionStorage:关闭浏览器就失效，保存在客户端，仅在同一个标签页中有效 localStorage: 保存在本地,永久存储，永不失效，除非自己删除，保存在客户端，作用在同源窗口8.如何用原生js给一个按钮注册两个onclick事件 addEventListener attachEvent 元素.addEventListener(&apos;不带on的事件名&apos;,fn,false); 谷歌、火狐支持 元素.attachEvent(&apos;带on的事件名&apos;,fn); IE8支持9.有哪些性能优化的方法 减少http请求、精灵图、css代码压缩、减少DOM操作、少用全局变量、异步加载、浏览器缓存、图片懒加载 （1）减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamicproperties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。10.js原型、原型链的认识 获取当前对象的属性或者方法,先在当前属性下面找,如果找不到去原型对象上面找,一直往上找，直到null，如果到null一直找不到,属性返回undefined,方法报错。11.ES6常用新特性 模板字符串 let const 解构赋值 数组方法: new Set()去重 map findIndex() 箭头函数(this问题) Promise12.编写一个function将location.search转化为对象的形式&#123;&#125; location.search是url中?号及?号之后的内容 ?q=for%E5&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=for%E5%BED%A5de%27ma&amp;sc=0-13&amp;sk=&amp;cvid=043448F 先截取?号,之后将后面的内容根据&amp;符号分割为数组,将数组中每一项根据=号,分割为数组13.js引入的方式有哪些?link和@import的区别是?14.module.exports和exports区别 module.exports: 可导出一个/多个参数 exports:只能导出多个参数,不能导出对象15.为什么利用多个域名来存储网络资源会更有效？16.设立&quot;严格模式&quot;的优点： 1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 2. 消除代码运行的一些不安全之处，保证代码运行的安全； 3. 提高编译器效率，增加运行速度； 4. 为未来新版本的Javascript做好铺垫。 注：经过测试 IE6,7,8,9 均不支持严格模式。 缺点： 现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节17.在css中如何处理ie,firefox,safari,chrome的兼容性问题 浏览器样式初始化： 浏览器私有属性 cssHack语法 自动化插件18.FOUC是什么意思 FOUC:浏览器样式闪烁或者叫做无样式内存闪烁 使用Import方法对css进行导入,会导致某些页面在window下的浏览器出现一些奇怪的想象，以无样式显示内容的瞬间出现瞬间闪烁，这种现象称之为文档样式短暂失效, 原因大致为： 1)使用import方法导入样式表 2）将样式表放在页面底部 解决办法： 使用link标签引入样式表放在文档head中19.如何解决cookie安全性问题 1)设置cookie有效期不要过长,合适即可 2)设置HttpOnly属性为true:可以防止js脚本读取cookie信息,有效的防止XSS攻击 3)设置复杂的cookie，加密cookie ①cookie的key使用uuid，随机生成 ②cookie的value可以使用复杂组合，比如:用户名+当前时间+cookie有效时间+随机数 4)对保存到cookie里面的敏感信息必须加密 5)用户第一次登录时,保存IP+cookie加密后的token 每次请求,都去将当前cookie和ip组合起来加密后的tokenn与保存的token作对比,只有全对应才能验证成功。 20.vue-router钩子函数: beforeEach afterEach 21.ajax实现过程 22.如何使一个元素垂直水平居中,如果是一个不定宽的元素如何实现呢? 23.js继承 24.简述src和href区别 25.document.load和document.ready有什么区别 有问题的知识点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621.用js实现千位分隔符，要求如下： 判断输入的都必须是数字或者数字组成的字符串 例如:输入的是10000,输出则是10,0002.用js实现对集合处理的过程,其要求如下输入可以是1个2个或者3个参数,需要判断用户输入给出相应的方案,例如:输入是fun([1,3,2],[5,2,1,4],[2,1]),则输出是[1,3,2,5,4]3.BFC实现原理4.html文档中 Doctype作用: 有哪几种类型5.如何深度克隆 至少3种方法6.已知圆心为(x,y),求圆上任意一点的坐标 假设半径和角度为变量=======求解答7.event loop 事件循环8.jquery和vue的区别9.浏览器缓存有哪些，通常缓存有哪几种 浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。 浏览器在第一次请求发生后，再次请求时： 浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信； 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 强缓存 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。 协商缓存 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段10.使用递归实现对数组的快速排序11.new Promise(function executor(resolve)&#123; console.log(1); for(var i = 0; i &lt; 1000; i++)&#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2); &#125;).then(function()&#123; setTimeout(function()&#123; cnsole.log(3); &#125;,10); console.log(4); &#125;); setTimeout(function()&#123; console.log(5); &#125;,0); console.log(6); for循环是异步的,为什么不执行for循环中的代码12.编写一个function将location.search转化为对象的形式&#123;&#125; location.search是url中?号及?号之后的内容 ?q=for%E5&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=for%E5%BED%A5de%27ma&amp;sc=0-13&amp;sk=&amp;cvid=043448F 先截取?号,之后将后面的内容根据&amp;符号分割为数组,将数组中每一项根据=号,分割为数组13.js引入的方式有哪些?link和@import的区别是? 1)HTML 文件被加载时，link 引用的文件会同时被加载，而 @import 引用的文件则会等页面全部下载完毕再被加载 2)link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持14.为什么利用多个域名来存储网络资源会更有效？ 1)CDN缓存更方便。 2)突破浏览器并发限制。 3)Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢15.js是单线程还是多线程16.怎么理解MVVM模式这些框架17.JS哪些操作会造成内存泄漏18.http和https有何区别?如何灵活使用?19.jsonp原理20.css合并方法21.ie的某些兼容性 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或者margin-right，margin值会加倍。这种情况下IE会产生20px的距离，解决方案是在float的标签样式控制中加入display：inline;将其转化为行内属性，，只有IE会识别）22.url从请求道页面渲染执行了哪些过程23.js中typeof和instanceof函数作用及区别 扩展1234567891.vue和react的区别 相同点:①都支持服务器渲染②都有虚拟DOM,组件化开发，通过props参数进行父子组件数据的传递,都实现webComponent规范③数据驱动试图④都支持native的方案,React的React native，Vue的weex⑤都有管理状态,React有redux,Vue有自己的Vuex(自适应vue)⑥提供了响应式Reactive和组件化Composable的视图组件⑦将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。2.ng-show/ng-hide与ng-if的区别3.解释下什么是$rootScrope以及$scope的区别4.如何实现浏览器内多个标签页之间的通信？5.react和vue有哪些相同点和不同点，说说你对这两个框架的看法6.Cache-control7.常见的web攻击技术有哪些?前端需要如何处理8.实现一个log函数,与console.log具有相同的特性,但每条输出都带有前缀,使用工厂模式创建出带有不同前缀的log函数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071.for(var i =0; i &lt; 5; i++)&#123; var a = 1; setTimeout(function()&#123; console.log(i); // 5 个5 &#125;,0); &#125; (function()&#123; console.log(a); //1 console.log(b); //undefined b = &quot;b&quot;; console.log(b); // b a = 2; console.log(a); // 2 var b; &#125;)(); console.log(a); // 22.var arr = [0,1,2,3,4,5,6,7,8,9]; for(var i = 0; i &lt; arr.length; i++)&#123; if(i%2 == 0)&#123; arr.splice(i,1); &#125; &#125; alert(arr); //1 2 4 5 7 83.function fun()&#123; for(var i = 0; 4&gt;i;i++)&#123; var k = 100; str += &apos;,&apos;+(k+i); &#125; &#125; var k = 1, str = k; fun(); str += k; console.log(str); //1,100,101,102,10314.function foo()&#123; try &#123; return 0; console.log(&quot;b&quot;); &#125;catch(err)&#123; ​ &#125;finally&#123; console.log(&quot;a&quot;); &#125; &#125; console.log(foo()); // a 05.var r = new Promise(function(resolve,reject)&#123; console.log(&quot;a&quot;); resolve(); &#125;) setTimeout( () =&gt; console.log(&apos;d&apos;),0); r.then(() =&gt; console.log(&quot;c&quot;)); console.log(&quot;b&quot;); // a b c d6.var a = 5; var b = 10; if(a == 5.0)&#123; let a = 4; var b = 1; console.log(a); // 4 console.log(b); // 1 &#125; console.log(a); // 5 console.log(b); // 17.var length = 10; function fn()&#123; console.log(this.length); &#125; var obj = &#123; length: 5, methods(fn)&#123; fn(); console.log(arguments[0]); arguments[0](); &#125; &#125; obj.methods(fn); 10 18.问题=========================================== function Foo()&#123; getName = function()&#123;console.log(1)&#125;; return this; &#125; Foo.getName = function()&#123; console.log(2); &#125; Foo.prototype.getName = function () &#123; console.log(3) &#125; var getName = function()&#123;console.log(4)&#125; function getName()&#123;console.log(5)&#125; Foo.getName(); getName(); Foo().getName(); getName(); new Foo.getName(); new Foo().getName();9.var a = 1; function test()&#123; console.log(a); //undefined var a = 2; console.log(this.a); //1 setTimeout(function()&#123; console.log(a); // 3 &#125;,0); return function()&#123; console.log(a); //2 a = 3; console.log(this.a); // 1 &#125; &#125; test()();]]></content>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273## Git常用命令 &gt; 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。 ~~~ $ git config --list // 查看配置信息 $ git config [--global] user.name &quot;&quot; // 配置用户名 $ git config [--global] user.email &quot;&quot; // 配置邮箱 $ git init [project-name] // 在工作目录中初始化新仓库 $ git init --bare [project-name] // 在工作目录中初始化新仓库 只记录版本没有工作区 $ git clone [url] [project-name] // 从现有仓库克隆 $ git fetch [remote-name] [branch-name] // 从远程仓库抓取数据 // 注意：fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支 $ git fetch --all // 获取所有 $ git log FETCH_HEAD // 查看获取的最新远程HEAD $ git pull [remote-name] [branch-name] // 从远端仓库中抓取数据后，合并到工作目录中的当前分支 git fetch 和 git merge // 注意：由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。 $ git push [remote-name] [branch-name] // 推送数据到远程仓库 $ git push origin --delete serverfix // 删除远程分支 // 远程分支以 (remote)/(branch) 形式命名 $ git remote [-v] // 查看当前的远程库 $ git remote add [shortname] [url] // 添加远程仓库 $ git remote show [remote-name] // 查看远程仓库信息 $ git ls-remote [remote-name] // 显式获得远程引用的完整列表 $ git checkout -b serverfix origin/serverfix // 创建分支并跟踪远程 $ git checkout --track origin/serverfix // 创建和远程一样的分支并跟踪 $ git branch -u origin/serverfix // 设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支 $ git branch -vv // 所有跟踪分支 $ git add [. *.*] // 跟踪新文件，已跟踪的文件放到暂存区，把有冲突的文件标记为已解决状态等 $ git status // 检查当前文件状态 $ git commit [-m &apos;&apos;] // 提交更新 $ git commit -a -m &apos;&apos; // 跳过使用暂存区域 提交更新 $ git diff // 比较工作目录中当前文件和暂存区域快照之间的差异 $ git diff --cached // 已经暂存起来的文件和上次提交时的快照之间的差异 $ git diff --staged // 已经暂存起来的文件和上次提交时的快照之间的差异 $ git rm // 移除已跟踪文件(暂存区域移除) 并从工作目录中删除指定的文件 $ git rm --cached // 移除已跟踪文件(暂存区域移除) 保留在当前工作目录 $ git mv // 移动文件 (相当于 mv file1 file2 , git rm file1 ,git add file2) $ git log // 查看提交历史 $ git log [-p] [-2] // -p显示每次提交的内容差异 -2仅显示最近的两次更新 $ git log --oneline --decorate --graph --all // 查看分叉历史 $ git commit --amend // 修改最后一次提交 $ git reset HEAD &lt;file&gt;... // 取消已经暂存的文件 $ git checkout -- &lt;file&gt;... // 取消对文件的修改 $ git branch [branch] // 创建分支 $ git checkout [branch] // 切换分支 $ git checkout -b [branch] // 创建并切换分支 $ git branch -d [branch] // 删除分支 $ git branch // 当前所有分支列表 $ git branch -v // 当前所有分支列表和最后一次提交 $ git branch --merged // 已经合并到当前分支的分支列表 $ git branch --no-merged // 尚未合并到当前分支的分支列表 // 在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 // merage 分为 快进合并 和 整合合并 $ git merge [branch] // 合并分支 $ git merge origin/master // 合并 $ git rebase origin/master // 变基 $ git rebase --abort // 来取消目前的rebase进程 $ git rebase --cqontinue // 继续目前的rebase进程 $ git rebase --onto master server client // m&gt;s&gt;c 从一个特性分支里再分出一个特性分支的提交历史 git reset --hard 版本号 //回滚版本 $ git diff // 不加参数即默认比较工作区与暂存区 $ git diff --cached [&lt;path&gt;...] // 较暂存区与最新本地版本库（本地库中最近一次commit的内容） $ git diff HEAD [&lt;path&gt;...] // 比较工作区与最新本地版本库 HEAD是master分支可以换成master $ git diff commit-id [&lt;path&gt;...] // 比较工作区与指定commit-id的差异 $ git diff --cached [&lt;commit-id&gt;] [&lt;path&gt;...] // 比较暂存区与指定commit-id的差异 $ git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;] // 比较两个commit-id之间的差异 $ $ git help &lt;verb&gt; //帮助命令 $ git &lt;verb&gt; --help //帮助命令 $ man git-&lt;verb&gt; //帮助命令 ~~~ ![1c5be00301acbe5334ce5eceb8f5088f.png](evernotecid://8329B9A2-63B9-46FA-BDF0-A91CD1917B8C/appyinxiangcom/11049585/ENResource/p13) ![1ce791a6bab444cc113010199b656a04.png](evernotecid://8329B9A2-63B9-46FA-BDF0-A91CD1917B8C/appyinxiangcom/11049585/ENResource/p14) &gt; 只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324251.注册github 搭建github pages2.安装nodejs3.安装hexo hexo init 文件夹名 cd 文件夹 npm i 4.配置_config.yml # Site title: web前端总结 subtitle: 前端知识点 description: 面试及项目 keywords: author: Fang Ren language: timezone: 配置服务器 github: # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: github生成的github pages网址 5.新建页面 hexo new &quot;文件名&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue项目后台管理系统]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fvue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1.项目介绍12完成用户管理、权限管理、商品管理、分类参数、订单管理、数据统计功能技术栈:vue+vue-cli+webpack+vue-router+axios+element-ui第三方主流UI库 2. 环境搭建1234561.运行sql文件2.启动服务器 把项目跑起来 后端使用的是node.js 安装node_modules npm i 在config文件夹中打开default.json文件中配置数据库连接信息 到后台根目录下启动服务器 node app.js3.接口文件 api-server-&gt;vue后台-&gt;docs/index.html 3. vue-cli创建项目结构12345678910111213141.vue init webpack shop2.回车 项目名字 描述 编译方式 for most users 安装vue-router y 使用ESLint检测你的代码 y 选择要使用的代码规范 standard:代码末尾不能有分号 set up unit tests? 是否设置单元测试 n Setup e2e tests no3.npm run dev 默认不会打开浏览器4.不会自动打开浏览器 1）在文件package.json中 配置 scripts: dev 后面添加--open 重新运行npm run dev打开浏览器 2）在config文件夹中的index.js文件中设置autoOpenBrowser:true即可 4. element-ui4.1 文档分析4.2 安装-引入123456789101112131415161.安装 npm i element-ui -S2.如果需要与webpack配合使用，在main.js文件中引入 1)完整引入 import Vue from &apos;vue&apos;; import ElementUI from &apos;element-ui&apos;; import &apos;element-ui/lib/theme-chalk/index.css&apos;; import App from &apos;./App.vue&apos;; Vue.use(ElementUI); new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App) &#125;); 2)按需引入完整引入可以在任意组件的template中使用element-ui里面的组件 5. 项目模板简化-调整1删除模板中不用的图片、样式、js文件 6. git-版本控制123456789git init git statusgit add .git commit -m &quot;&quot;新建远程仓库关联仓库 git remote add origin 链接推送 git push -u origin mastergit branch 查看分支 git checkout -b 分支名 新建某个分支并且切换到该分支 7. 登录7.1 新建分支-login组件-配置路由index.js==&gt;router.js 12345678910111213141516171819202122import Vue from &apos;vue&apos;import vueRouter from &apos;vue-router&apos;Vue.use(vueRouter);import Login from &quot;../components/login.vue&quot;;在webpack模板中提供新功能 @自动锁定srcimport Login from &quot;@/components/login.vue&quot;;export default new Router(&#123; routes: [ &#123; name: &apos;home&apos;, path: &apos;/&apos;, redirect: &#123; name: &apos;login&apos; &#125; &#125;, &#123; name: &apos;login&apos;, path: &apos;/login&apos;, component: Login &#125; ]&#125;); login.vue 12345678910&lt;template&gt; &lt;div&gt;登录&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 7.2 引入表单组件12341.找组件2.引入标签3.提供该组件的属性值和数据/方法web前端助手-&gt;FEHelper 7.3 样式调整-水平垂直居中123456789101112131415161718192021222324252627281.form水平垂直居中2.背景色3.圆角4.按钮宽度.wrap &#123; height: 100%; background-color: #324152; 让里面的元素水平垂直居中 display: flex; justify-content: center; align-items: center;&#125;.wrap form &#123; background-color: #fff; border-radius: 10px; width: 400px; padding: 300px;&#125;.wrap .form &#123; width: 100%;&#125;公共样式：html,body&#123; height: 100%; margin: 0; padding: 0;&#125; 7.4 axios插件1234567891011121314151617181920212223241.安装axios npm i axios 2.使用axios第一种写法 import axios from &apos;axios&apos;; Vue.prototype.$http = axios;3.导入1)http.jsimport axios from &apos;axios&apos;; 将axios变成vue的插件const Http = &#123;&#125;;Http.install = function (Vue, options) &#123; Vue.prototype.$http = axios;&#125;2)导出export default Http;3)在main.js文件中导入import Http from &apos;@plugins/http.js&apos;;使用vue的插件Vue.use(Http);4)在login.vue文件中export default &#123; mounted()&#123; console.log(this.$http); &#125;&#125; 7.5 发送登录请求1234567891011121314151617181920212223接口: 登录验证接口 login post 点击按钮发送请求1.配置基准url http.jsaxios.defaults.baseURL = &apos;...&apos;;2.login.vue&lt;button @click=&apos;handleLogin()&apos;&gt;登录&lt;/button&gt;export default &#123; methods: &#123; handleLogin()&#123; this.$http.post(&apos;login&apos;,this.formdata) .then(res =&gt; &#123; const &#123;data:&#123;meta:&#123;mag,status&#125;&#125;&#125; = res; if(status === 200)&#123; alert(msg); &#125;else&#123; alert(msg); &#125; &#125;); &#125; &#125;&#125;存在的用户: admin 123456 7.6 引入提示框组件123456789101112http://element-cn.eleme.io/#/zh-CN/component/messageif(status === 200)&#123; this.$message(&#123; message: msg, type: &apos;success&apos; &#125;);&#125;else&#123; this.$message(&#123; message: msg, type: &apos;warning&apos; &#125;);&#125; 7.7 登录成功-进入home组件12345678910if(status === 200)&#123; this.$message(&#123; message: msg, type: &apos;success&apos; &#125;); 第一步:成功后跳转到首页:改标识 修改页面 this.$router.push(&#123; name: &apos;home&apos; &#125;);&#125; router.js 123456789101112导入home.vue 文件import Home from &apos;@/components/home.vue&apos;; export default new Router(&#123; routes: [ 渲染首页 &#123; name: &apos;home&apos;, path: &apos;／&apos;, component: Home &#125; ]&#125;) home.vue 12345678910&lt;template&gt; &lt;div&gt;首页内容&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 7.8 简化登录请求代码-async和await121.找到异步操作 在前面加await2.找到距离异步操作最近的函数 前面加async 异步操作 12345678910111213export default &#123; methods: &#123; async handleLogin()&#123; const res = await this.$http.post(&apos;login&apos;,this.formdata); const &#123;data:&#123;meta:&#123;mag,status&#125;&#125;&#125; = res; if(status === 200)&#123; ... &#125;else&#123; ... &#125; &#125; &#125;&#125; 7.9 保存token值123456789101112登录成功后 后台会返回用户信息 token发送axios之后的响应,res,打印console.log(res);里面的data数据中data中有token,是唯一标识if(status === 200)&#123; 保存用户token 值 localStorage.setItem(&apos;token&apos;,data.data.token); this.$message.success(msg); this.$router.push(&#123; name: &apos;home&apos; &#125;);&#125;else&#123; ...&#125; 8. 首页8.1 侧边栏－导航组件－文档1234567891011121314http://element-cn.eleme.io/#/zh-CN/component/menu 导航栏default-active 当前激活菜单的 index unique-opened 是否只保持一个子菜单的展开router 是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转&lt;el-aside width=&quot;200px&quot; class=&apos;aside&apos;&gt; &lt;el-menu default-active=&quot;2&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;el-menu-item-group title=&quot;分组2&quot;&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;&lt;/el-aside&gt; 8.2 侧边栏－引入导航组件－调整123456unique-opened 是否只保持一个子菜单的展开default-active 当前激活菜单的 index调整列表：显示几级 控制点击哪个哪个下拉列表展开一级导航 el-submenu二级导航 el-menu-item注意:每个Index值不一样 8.3 头部-退出功能1234567891011121314151617181920点击退出: 1.清除token session 2.回到登录页 3.给出提示1)&lt;a href=&apos;#&apos; @click.prevent = &quot;handleLoginout()&quot;&gt;&lt;/a&gt;2)export default &#123; methods: &#123; 退出 handleLoginout()&#123; 1.清除token localStorage localStorage.clear(); 2.退出到登录页 this.$router.push(&#123; name: &apos;login&apos; &#125;); 3.提示 this.$message.success(&apos;退出成功&apos;); &#125; &#125;&#125; 8.4 进入首页的权限验证home.vue 12345678910beforeCreate()&#123; 如果没有token，则跳转到登录页 if(!localStorage.getItem(&apos;token&apos;))&#123; this.$message.warining(&apos;请先登录&apos;); 重定向 this.$router.push(&#123; name: &apos;login&apos; &#125;); &#125;&#125; 9. 用户管理9.1 用户列表9.1.1 新建组件-路由配置12341.el-menu开启路由模式 router2.home.vue el-main里面是router-view 3.新建users.vue4.配置路由(在home的路由配置里面children) 123456789101112home.vuedefault-active 当前激活菜单的 indexunique-opened 是否只保持一个子菜单的展开router 是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转&lt;el-menu default-active=&quot;2&quot; unique-opened router&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;el-menu-item-group&gt; &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt; &lt;el-menu-item index=&quot;users&quot;&gt;用户列表&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt;&lt;/el-menu&gt; router.js 123456789101112131415161718192021导入组件&lt;el-main class=&apos;main&apos;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/el-main&gt;import Users from &apos;users&apos;;export default new Router&#123; routes: [ &#123; name: &apos;home&apos;, path: &apos;/home&apos;, component: Home, children: [ &#123; name: &apos;users&apos;, path: &apos;/users&apos;, component: Users &#125; ] &#125; ]&#125; users.vue 123&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 9.1.2 面包屑和搜索框123456789101112131415161718192021222324252627282930313233343536373839整体:卡片面包屑+搜索框+按钮users.vue卡片&lt;el-card class=&quot;card&quot;&gt; 面包屑 &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;用户管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;用户列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; 搜索框 &lt;el-row&gt; &lt;el-col&gt; &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;query&quot; class=&quot;input-with-select&quot;&gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;el-button type=&quot;primary&quot;&gt;添加用户&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/el-card&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; query: &apos;&apos; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .card &#123; height: 100% &#125; .input-with-select &#123; margin-top: 20px; width: 350px; &#125;&lt;/style&gt; 9.1.3 引入表格组件1234567891011121314151617181920212223242526272829303132333435363738394041424344表格data属性值是表格中的数据&lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt;&lt;/el-table&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; query: &apos;&apos;, tableData: [&#123; date: &apos;2016-05-02&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1518 弄&apos; &#125;, &#123; date: &apos;2016-05-04&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1517 弄&apos; &#125;, &#123; date: &apos;2016-05-01&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1519 弄&apos; &#125;, &#123; date: &apos;2016-05-03&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1516 弄&apos; &#125;] &#125; &#125; &#125; &lt;/script&gt; 9.1.4 请求数据users.vue 12345678910111213141516171819202122232425262728293031323334353637383940接口：用户数据列表 users getexport default &#123; data()&#123; return &#123; query: &apos;&apos;, tableData: [], query: &apos;&apos;, pagenum: 1, pagesize: 2, total: -1 &#125; &#125;, created()&#123; this.getTableDate(); &#125;, methods: &#123; 获取用户列表 async getTableDate()&#123; 授权token 需要设置为token的值 const AUTH_TOKEN = localStorage.getItem(&apos;token&apos;); axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=$&#123;this.query&#125;&amp;pagenum=$&#123;this.pagenum&#125;$pagesize=$&#123;this.pagesize&#125;&apos;); console.log(res); 获取到的数据为Null 因为token无效 原因是 所有接口数据中 除了登录不需要授权 其他所有的请求都需要授权 必须要在axios文件中设置一个请求头,在Http.js文件中添加请求头axios发送请求,vue将axios封装成vue插件 const &#123;meta:&#123;status,msg&#125;,data:&#123;total,users&#125;&#125; = res.data; 判断状态。。。。。。。 &#125; &#125;&#125;或者async getData()&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); this.$http.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=&apos;+this.query+&apos;&amp;pagenum=&apos;+this.pagenum+&apos;&amp;pagesize=&apos;+this.pagesize); console.log(res);&#125; http.js 12345678导入import axios from &apos;axios&apos;;const Http = &#123;&#125;;Http.install = function(Vue,options)&#123; 设置基准值 axios.defaults.baseURL = &apos;http://localhost:8888/api/private/v1/&apos;; 授权token,如果写在这 那么所有发送请求都会授权token,所以不能写在这&#125; 9.1.5 渲染数据-一般数据123456789101112131415161718192021221.this.tableData = res.data.data.users2.给prop赋值3.表格数据分为两类 一般数据(单元格的内容就是prop的值) 特殊数据if(status === 200)&#123; this.tableData = users; this.total = total; this.$message.success(msg);&#125;else&#123; this.$message.warning(msg);&#125;&lt;el-table&gt; prop=&apos;id&apos; prop=&apos;username&apos; prop=&apos;email&apos; prop=&apos;mobile&apos; prop=&apos;create_time&apos; prop=&apos;mg_state&apos;&lt;/el-table&gt; 9.1.6 渲染数据-日期格式处理12345678910111213141516171819202122232425262728293031321.使用全局过滤器 main.js文件中 导入 import moment from &apos;moment&apos;; Vue.filter(&apos;fmDate&apos;,(v) =&gt; &#123; return moment(v).format(&apos;YYYY-MM-DD&apos;); &#125;);2.安装moment npm i moment;3.在main.js文件中引入 import moment from &apos;moment&apos;;4.在users.vue文件中prop的值不支持过滤器的使用&lt;el-table-column prop=&apos;create_time&apos; label=&quot;创建日期&quot; width=&quot;150&quot;&gt;&lt;/el-table-column&gt;5.如果单元格的内容不是prop的key对应的值，此时，需要给被显示内容的外层包裹容器template目的:在里层使用外层tableData-&gt;组件传值slot-scope作用:承上启下/传递数据&apos;tableData&apos;自动获取上层数据的值 : data=&apos;tableData&apos;在里层通过tableDat.row来使用&lt;el-table-column label=&quot;创建日期&quot; width=&quot;150&quot;&gt; &lt;template slot-scope=&apos;tableData&apos;&gt; &#123;&#123;tableData.row.create_time|fmDate&#125;&#125; &lt;/template&gt;&lt;/el-table-column&gt;6.注意: slot-scope的值可以是任意值,一般都是scope通过template的属性slot-scope可以把上层数据tableData传递给里层进行使用&lt;el-table-column label=&quot;创建日期&quot; width=&quot;150&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &#123;&#123;scope.row.create_time|fmDate&#125;&#125; &lt;/template&gt;&lt;/el-table-column&gt;scope会自动获取上层有数据的值 :data=&apos;tableData&apos;scope.row是数据源中的每个元素slot-scope和element-ui没任何关系,是vue的API 9.1.7 用户状态开关12345678910111213element-ui 开关&lt;el-table-column label=&quot;用户状态&quot; width=&quot;180&quot;&gt; 1）如果单元格的内容不是prop的key对应的值，此时，需要给被显示内容的外层包裹容器template 2）通过slot-scope获取上层数据 &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-switch 3)获取数据 scope.row.mg_state v-model=&quot;scope.row.mg_state&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt; &lt;/el-switch&gt; &lt;/template&gt;&lt;/el-table-column&gt; 9.1.8 操作123456789align=&apos;center&apos; :文本居中header-align=&apos;center&apos;: 表头居中&lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 9.2 分页组件9.2.1 分页文档引入12345678910111213141516171819202122232425分页组件@size-change:每页显示的数据条数改变时@current-change:当前页显示数据条数改变时current-page:当前页码page-sizes:当前页显示数据条数数组page-size:当前页显示的条数total：总条数&lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;currentPage4&quot; :page-sizes=&quot;[100, 200, 300, 400]&quot; :page-size=&quot;100&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;400&quot;&gt;&lt;/el-pagination&gt;方法:methods: &#123; handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); &#125;&#125; 9.2.2 配置数据12345678910111213141516171819202122232425262728293031323334353637383940414243组件配置：&lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pagenum&quot; :page-sizes=&quot;[2, 4, 6, 8]&quot; :page-size=&quot;2&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt;数据data()&#123; return &#123; input: &apos;&apos;, tableData: [], query:&apos;&apos;, pagenum: 1, pagesize: 2, total: -1 &#125;&#125;,methods: &#123; handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); &#125;, async getData()&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); this.$http.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=&apos;+this.query+&apos;&amp;pagenum=&apos;+this.pagenum+&apos;&amp;pagesize=&apos;+this.pagesize); console.log(res); const &#123;data:&#123;pagenum,total,users&#125;,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); this.tableData = users; this.total = total; &#125;else&#123; this.$message.warning(msg); &#125; &#125;&#125; 10.2.3 分页请求1234567891011121314151617181920212223242526272829303132接口:用户数据列表 get users点击页码时,发送新请求每页娴熟数据条数改变时，发送新请求methods: &#123; 每页条数改变时,重新渲染页面 handleSizeChange(val) &#123; this.pagenum = 1; this.pagesize = val; this.getData(); console.log(`每页 $&#123;val&#125; 条`); &#125;, 当前页面改变时,重新渲染页面 handleCurrentChange(val) &#123; this.pagenum = val; this.getData(); console.log(`当前页: $&#123;val&#125;`); &#125;, async getData()&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); this.$http.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=&apos;+this.query+&apos;&amp;pagenum=&apos;+this.pagenum+&apos;&amp;pagesize=&apos;+this.pagesize); console.log(res); const &#123;data:&#123;pagenum,total,users&#125;,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); this.tableData = users; this.total = total; &#125;else&#123; this.$message.warning(msg); &#125; &#125; &#125; 9.3 搜索用户1234567891011121314151617181920211）点击搜索按钮,将this.input的值赋给query查询参数,渲染表格2)点击输入框的清空,触发清空事件,渲染所有数据 给输入框加 clearable 属性,可清空 清空事件 @clear=&apos;&apos;&lt;el-col&gt; &lt;el-input placeholder=&quot;请输入内容&quot; clearable @clear=&apos;getAllUser()&apos; v-model=&quot;input&quot; class=&quot;input-with-select&quot;&gt; &lt;el-button slot=&quot;append&quot; @click=&apos;searchUser()&apos; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;el-button plain&gt;朴素按钮&lt;/el-button&gt;&lt;/el-col&gt;//清空数据时触发getAllUser()&#123; this.query = this.input; 如果不重新设置this.query = &apos;&apos; 还是原来的值 this.getData();&#125;,//搜索用户searchUser()&#123; 设置第一页开始显示 this.pagenum = 1; this.query = this.input; this.getData();&#125; 9.4 添加用户9.4.1 打开对话框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647对话框组件&lt;el-button plain @click = &apos;openDialog()&apos;&gt;添加用户&lt;/el-button&gt;对话框&lt;el-dialog title=&quot;添加用户&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.email&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.mobile&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;数据data()&#123; return &#123; //添加用户的值 默认为false隐藏 dialogFormVisible:false, //对话框数据 form: &#123; username: &apos;&apos;, password: &apos;&apos;, email: &apos;&apos;, mobile:&apos;&apos; &#125;, //对话框宽度 formLabelWidth: &apos;150px&apos; &#125;&#125;,methods: &#123; //点击按钮显示对话框 openDialog()&#123; 清空对话框中的数据 this.form = &#123;&#125;; this.dialogFormVisible = true; &#125;&#125; 9.4.2 发送请求1234567891011121314151617181920212223242526添加用户:添加用户 users post&lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addUser()&quot;&gt;确 定&lt;/el-button&gt;&lt;/div&gt;1)点击确定按钮,发送请求，请求成功之后,关闭对话框,重新渲染页面,给出提示,打开对话框清空数据//添加用户 async addUser()&#123; const res = await this.$http.post(&apos;users&apos;,this.form); //console.log(res); const &#123;meta: &#123;msg,status&#125;&#125; = res.data; if(status == 201)&#123; this.dialogFormVisible = false; this.getData(); this.$message.success(msg); &#125;else &#123; this.$message.warning(msg); &#125; &#125;, //点击按钮显示对话框 openDialog()&#123; 清空数据 this.form = &#123;&#125;; this.dialogFormVisible = true; &#125;2)点击取消,关闭对话框 9.5 删除用户9.5.1 打开确认框123456789101112131415161718&lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser()&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;&lt;/template&gt;删除处理//删除用户deleteUser()&#123; this.$confirm(&apos;确认删除该用户?&apos;, &apos;提示&apos;, &#123; confirmButtonText: &apos;确定&apos;, cancelButtonText: &apos;取消&apos;, type: &apos;warning&apos; &#125;).then(() =&gt; &#123; this.$message.success(&apos;删除成功!&apos;); &#125;).catch(() =&gt; &#123; this.$message.info(&apos;已取消删除!&apos;); &#125;);&#125; 9.5.2 处理响应123456789101112131415161718192021222324252627接口: 删除单个用户 delete users/:id点击删除框中的确认按钮=&gt;发送请求 如果删除成功,重新渲染列表，设置从第一页开始渲染 如果删除失败,给出提示//删除用户deleteUser(id)&#123; this.$confirm(&apos;确认删除该用户?&apos;, &apos;提示&apos;, &#123; confirmButtonText: &apos;确定&apos;, cancelButtonText: &apos;取消&apos;, type: &apos;warning&apos; &#125;).then(async () =&gt; &#123; const res = await this.$http.delete(`users/$&#123;id&#125;`); console.log(res); const &#123;meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); this.pagenum = 1; this.getData(); &#125;else&#123; this.$message.info(msg); &#125; &#125;).catch(() =&gt; &#123; this.$message.info(&apos;已取消删除!&apos;); &#125;);&#125;注意:传参 async的位置 9.6 编辑9.6.1 点击按钮显示对话框123456789101112131415161718192021222324252627282930313233343536371.点击编辑按钮,注册点击事件&lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;edit(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;&lt;/template&gt;2.弹出对话框&lt;el-dialog title=&quot;编辑用户&quot; :visible.sync=&quot;dialogFormVisibleEdit&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.email&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.mobile&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleEdit = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;editUser()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;3.数据data()&#123; return &#123; dialogFormVisibleEdit:false &#125;&#125;,methods: &#123; //编辑用户 edit()&#123; 弹出对话框 this.dialogFormVisibleEdit = true; &#125;&#125; 9.6.2 显示编辑数据12345678910111213接口: 根据 ID 查询用户信息 users/:id get//编辑用户 打开对话框,根据传递过来的数据进行查询数据，并渲染到表单async edit(id)&#123; this.dialogFormVisibleEdit = true; //根据id查询数据 const res = await this.$http.get(`users/$&#123;id&#125;`); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.form = data; &#125;else&#123; this.$message.warning(msg); &#125;&#125; 9.6.3 发送请求123456789101112131415接口: 编辑用户提交 users/:id put//修改数据async editUser()&#123; const res = await this.$http.put(`users/$&#123;this.form.id&#125;`,this.form); const &#123;meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); //关闭对话框 //this.dialogFormVisibleEdit = false; //重新渲染页面 //this.getData(); &#125;else&#123; this.$message.warning(msg); &#125;&#125; 9.6.4 修改用户状态12345678910111213141516接口: 修改用户状态 users/:uId/state/:type put1.开关状态改变时,触发change事件 开关是表单元素,v-model是数据双向绑定的,所以不需要重新渲染页面&lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;用户状态&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-switch @change=&apos;changeStatue(scope.row)&apos; v-model=&quot;scope.row.mg_state&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt; &lt;/el-switch&gt; &lt;/template&gt;&lt;/el-table-column&gt;2.//修改用户状态 参数写在url中 id 和typeasync changeStatue(user)&#123; const res = await this.$http.put(`users/$&#123;user.id&#125;/state/$&#123;user.mg_state&#125;`);&#125; 9.7 分配角色9.7.1 点击按钮，弹出对话框123456789101112131415161718192021222324252627282930313233343536371.&lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;edit(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRole(scope.row)&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;&lt;/template&gt;2.&lt;el-dialog title=&quot;分配角色&quot; :visible.sync=&quot;dialogFormVisibleRole&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;用户名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &#123;&#123;currentUserName&#125;&#125; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;角色名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-select v-model=&apos;currentId&apos;&gt; &lt;el-option label=&quot;请选择&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;测试&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleRole = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisibleRole = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;3.data()&#123; return &#123; //分配角色 dialogFormVisibleRole: false, currentId: -1, roles:[], 角色数组 currentUserName: &apos;&apos; &#125;&#125;,methods:&#123; //分配角色 showRole(user)&#123; this.dialogFormVisibleRole = true; &#125;&#125; 9.7.2 显示对话框-下拉列表1234select:v-model写在select中如果v-model绑定数据的值和option的value一样,默认显示option(label值)如果选择了某个option，此时,v-model绑定的数据值就是被选中的option的value值 9.7.3 显示当前用户的名字和角色12345678910111213141516171819202122232425262728接口:角色列表 get roles 打开对话框,获取数据,将获取到的数据显示在下拉框中label显示的是下拉框中的内容,value是id号如果:value和:value不加:冒号,则显示的是字符串 v.rolename不是内容methods:&#123; //分配角色 async showRole(user)&#123; 显示当前用户的名字 this.currentUserName = user.username; this.dialogFormVisibleRole = true; const res = await this.$http.get(&apos;roles&apos;); console.log(res); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.roles = data; &#125;else&#123; this.$message.info(msg); &#125; &#125;&#125;渲染数据&lt;el-form-item label=&quot;角色名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-select v-model=&apos;currentId&apos;&gt; &lt;el-option label=&quot;请选择&quot; disabled value=&quot;shanghai&quot;&gt;&lt;/el-option&gt; &lt;el-option v-for=&apos;(v,i) in roles&apos; :key=&apos;i&apos; :label=&quot;v.roleName&quot; :value=&quot;v.id&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt;&lt;/el-form-item&gt; 9.7.4 点击确定-修改角色12345678910111213141516171819202122232425261.显示当前用户名定义数据 currentUserName 方法中传入一个参数 scope.rowthis.currentUserName = scope.row.username;在标签中使用: &#123;&#123;currentUserName&#125;&#125;2.显示当前用户的角色名字 根据用户id查询角色id,将查询到的角色id赋值给select的v-model值,从而显示出来//分配角色async showRole(user)&#123; //显示当前用户的名字 console.log(user); this.currentUserName = user.username; this.dialogFormVisibleRole = true; const res = await this.$http.get(&apos;roles&apos;); console.log(res); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.roles = data; &#125;else&#123; this.$message.info(msg); &#125; //根据当前用户id请求角色id const res2 = await this.$http.get(`users/$&#123;user.id&#125;`); //console.log(res2); this.currentId = res2.data.data.rid;&#125; 9.7.5 修改用户角色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869接口： 分配用户角色 users/:id/role put1. &lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;edit(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRole(scope.row)&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt;2.&lt;el-dialog title=&quot;分配角色&quot; :visible.sync=&quot;dialogFormVisibleRole&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;用户名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &#123;&#123;currentUserName&#125;&#125; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;角色名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-select v-model=&apos;currentId&apos;&gt; &lt;el-option label=&quot;请选择&quot; disabled value=&quot;shanghai&quot;&gt;&lt;/el-option&gt; &lt;el-option v-for=&apos;(v,i) in roles&apos; :key=&apos;i&apos; :label=&quot;v.roleName&quot; :value=&quot;v.id&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleRole = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;setRole()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;3.data()&#123; return &#123; //分配角色 dialogFormVisibleRole: false, currentId: -1, roles: [], currentUserName: &apos;&apos;, currentUserId:&apos;&apos; &#125; &#125;, methods: &#123; //修改角色 async setRole()&#123; const res = await this.$http.put(`users/$&#123;this.currentUserId&#125;/role`,&#123;rid:this.currentId&#125;); const &#123;meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); //关闭对话框 this.dialogFormVisibleRole = false; &#125; &#125;, //分配角色 async showRole(user)&#123; //console.log(user); //显示当前用户的名字 this.currentUserName = user.username; //当前用户的id this.currentUserId = user.id; this.dialogFormVisibleRole = true; const res = await this.$http.get(&apos;roles&apos;); console.log(res); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.roles = data; &#125;else&#123; this.$message.info(msg); &#125; //根据当前用户id请求角色id const res2 = await this.$http.get(`users/$&#123;user.id&#125;`); //console.log(res2); //当前角色id this.currentId = res2.data.data.rid; &#125;&#125; 12345678git branchgit status git add .git commit -m &quot;&quot;git checkout master 切换到主分支git status 查看状态git merge dev-users 合并分支git push 推 10. 权限管理10.1 权限列表10.1.1 自定义面包屑组件12345678910111213141516171819202122232425262728293031cusBread.vue&lt;template&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&#123;&#123;this.level1&#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&#123;&#123;this.level2&#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt;&lt;/template&gt;&lt;script&gt; export default &#123; //组件名字 name: &apos;my-bread&apos;, props: [&apos;level1&apos;,&apos;level2&apos;] &#125;&lt;/scpript&gt;&lt;style&gt;&lt;/style&gt;main.jsimport MyBread from &apos;@/components/cusBread.vue&apos;//定义全局组件Vue.component(&quot;my-bread&quot;,MyBread);在rights.vue中使用&lt;my-bread &apos;level1=&apos;权限管理&apos; level2=&apos;权限列表&apos;&gt;&lt;/my-bread&gt;组件： 场景|特点:当页面中有多个位置有一样的标签结构时,封装成一个组件 组件中的数据来源是其他组件,数据不能写在data中，要写在prop中 组件通信: 父传子 组件分类:全局|局部 10.1.2 axios-拦截器统一设置请求头123456789101112131415161718192021222324axios文档中拦截器: 在请求或和响应被then和catch处理前拦截他们 由于在非登录请求中都要设置 token,所以在axios拦截器中发送请求之前要先处理tokenmain.js文件中//设置发送请求baseUrlaxios.defaults.baseURL = &apos;http://localhost:8888/api/private/v1/&apos;;// 设置请求拦截// 添加一个请求拦截器axios.interceptors.request.use(function (config) &#123; //在发送请求之前希望做些什么 //如果请求的不是登录请求，则设置拦截进行下面的代码 //根据config.url可以获取当前请求的地址 console.log(config); if(config.url !== &apos;login&apos;)&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); config.headers.Authorization = AUTH_TOKEN; &#125; return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;);Vue.prototype.$http = axios;设置拦截之后就不需要在发送请求之前设置头部token 10.1.3 表格展示-显示层级123456789101112131415161.如果组件的内容是开始和结束标签的里面,此时需要给内容的外层套一个template2.如果内容里面用到了数据,并且数据来源label是当前组件的父组件的数据el-table,此时需要加一个slot-scope&lt;template slot-scope=&apos;scope&apos;&gt; &lt;span v-if=&quot;scope.row.level === &apos;0&apos;&quot;&gt;一级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;1&apos;&quot;&gt;二级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;2&apos;&quot;&gt;三级&lt;/span&gt;&lt;/template&gt;要显示的层级不是 0 1 2,而是一级、二级、三级&lt;el-table-column label=&quot;层级&quot; width=&quot;240&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;span v-if=&quot;scope.row.level === &apos;0&apos;&quot;&gt;一级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;1&apos;&quot;&gt;二级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;2&apos;&quot;&gt;三级&lt;/span&gt; &lt;/template&gt;&lt;/el-table-column&gt; 10.2 角色列表10.2.1 表格展示-展开行功能分析12345678910111213141516171819202122232425262728表格展开功能： 通过设置 type=&quot;expand&quot; 和 Scoped slot 可以开启展开行功能，el-table-column 的模板会被渲染成为展开行的内容，展开行可访问的属性与使用自定义列模板时的 Scoped slot 相同。&lt;el-table :data=&quot;roles&quot; height=&apos;480px&apos; style=&quot;width: 100%&quot;&gt; 表格可展开 &lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;right&apos;&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项一&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项二&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt;&lt;span&gt;选项三&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;#&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleName&quot; label=&quot;角色名称&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleDesc&quot; label=&quot;角色描述&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; 10.2.2 表格展示-展开行-一级权限12345678910111213&lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-row v-for=&apos;(item1,i) in scope.row.children&apos;&gt; &lt;el-col&gt;&lt;span&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项二&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt;&lt;span&gt;选项三&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt;&lt;/el-table-column&gt; 10.2.3 表格展示-展开行-二级三级权限1234567891011121314151617181920212223242526272829&lt;el-table :data=&quot;roles&quot; height=&apos;480px&apos; style=&quot;width: 100%&quot;&gt; &lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-row v-for=&apos;(item1,i) in scope.row.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;span&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; &lt;el-col :span=&apos;20&apos;&gt; 二级权限 &lt;el-row v-for=&apos;(item2,i) in item1.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;span&gt;&#123;&#123;item2.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; 三级权限 &lt;el-col :span=&apos;20&apos;&gt;&lt;span v-for=&apos;(item3,i) in item2.children&apos; :key=&apos;i&apos;&gt; &#123;&#123;item3.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;#&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleName&quot; label=&quot;角色名称&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleDesc&quot; label=&quot;角色描述&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt;添加样式： 标记 把所有span标签换成 el-tag 10.2.4 展开行-样式调整-处理无权限123456789101112131415161718192021222324252627282930311.给每个标签添加x号 给每个&lt;el-tag&gt;标签添加 closable&lt;el-tag closable&gt;&lt;/el-tag&gt;2添加箭头符号 &gt; element-ui图标 &lt;i class=&apos;el-icon-arrow-right&apos;&gt;&lt;/i&gt;3.在展开行的位置处理无权限的内容&lt;el-row v-if=&apos;v-if=&apos;&apos;scope.row.children.length===0&apos;&gt; &lt;el-col&gt; &lt;span&gt;该角色未分配权限&lt;/span&gt; &lt;/el-col&gt;&lt;/el-row&gt;代码：&lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-row v-for=&apos;(item1,i) in scope.row.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;el-tag closable&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/el-tag&gt;&lt;i class=&apos;el-icon-arrow-right&apos;&gt;&lt;/i&gt;&lt;/el-col&gt; &lt;el-col :span=&apos;20&apos;&gt; &lt;el-row v-for=&apos;(item2,i) in item1.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;el-tag closable&gt;&#123;&#123;item2.authName&#125;&#125;&lt;/el-tag&gt;&lt;i class=&apos;el-icon-arrow-right&apos;&gt;&lt;/i&gt;&lt;/el-col&gt; &lt;el-col :span=&apos;20&apos;&gt;&lt;el-tag closable v-for=&apos;(item3,i) in item2.children&apos; :key=&apos;i&apos;&gt;&#123;&#123;item3.authName&#125;&#125;&lt;/el-tag&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row v-if=&apos;v-if=&apos;&apos;scope.row.children.length===0&apos;&gt; &lt;el-col&gt; &lt;span&gt;该角色未分配权限&lt;/span&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt;&lt;/el-table-column&gt; 10.3 修改权限-树形结构10.3.1 显示对话框123456789101112131415点击√弹出对话框 1.&lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRights()&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; 2.点击√,对话框显示 data()&#123; return &#123; roles: [], dialogVisible: false &#125;&#125;,methods: &#123; //分配权限 showRights()&#123; this.dialogVisible = true; &#125;&#125; 10.3.1 文档分析1234567891011121314151617181920212223242526272829301.打开对话框的同时,获取所有的权限，并查询当前角色下的所有权限，将有的权限打勾2.树形控件 tree3.树形结构data: 树形结构的数据源node-key： 每个节点的位移标识 通常是 data中的id值default-expanded-keys设置默认展开的节点 数组:[id值]default-checked-keys设置默认选中的节点 数组:[id值]props 配置选项 = &#123;label,children&#125;label和children值来源于data数据中的key名每个节点都有半选和全选:如果子节点全部选中,则节点全选显示树形结构&lt;el-dialog title=&quot;分配权限&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;50%&quot;&gt; &lt;el-tree default-expand-all ref=&apos;tree&apos; :data=&quot;treeData&quot; show-checkbox node-key=&quot;id&quot; :default-expanded-keys=&quot;expandedArr&quot; :default-checked-keys=&quot;checkedArr&quot; :props=&quot;defaultProps&quot;&gt; &lt;/el-tree&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt; 10.3.2 配置数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576接口:获取树形权限列表获取所有选项,将所有选项显示在弹出框中,并将所有的id保存在默认展开的数组中1.注册点击事件&lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRights(scope.row)&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;2.弹出框&lt;el-tree default-expand-all 展开所有节点 :data=&quot;treeData&quot; show-checkbox node-key=&quot;id&quot; 默认展开的权限id :default-expanded-keys=&quot;expandedArr&quot; 默认选中的权限id :default-checked-keys=&quot;checkedArr&quot; :props=&quot;defaultProps&quot;&gt;&lt;/el-tree&gt;3.数据配置export default &#123; data()&#123; return &#123; roles: [], //树形结构配置 dialogVisible: false, //树形结构数据 treeData: [], //默认展开的权限的id expandedArr:[], //默认选中的权限的id checkedArr:[], //树形结构配置 defaultProps: &#123; children: &apos;children&apos;, label: &apos;authName&apos; &#125; &#125; &#125;, created()&#123; this.getRoles(); &#125;, methods: &#123; //分配权限 async showRights()&#123; //显示对话框 this.dialogVisible = true; //获取树形结构的权限数据 const res = await this.$http.get(`rights/tree`); console.log(res); this.treeData = res.data.data; 第一种方法:获取所有权限的id //const tempArr = []; //this.treeData.forEach(item1 =&gt; &#123; // tempArr.push(item1.id); // item1.children.forEach(item2 =&gt; &#123; // tempArr.push(item2.id); // item2.children.forEach(item3 =&gt; &#123; // tempArr.push(item3.id); // &#125;); // &#125;); //&#125;); //this.expandedArr = tempArr; 第二种方法: 给标签添加属性 default-expand-all 是否默认展开所有节点 &#125;, //删除权限 async deleRights(role,rights)&#123; const res = await this.$http.delete(`roles/$&#123;role.id&#125;/rights/$&#123;rights.id&#125;`); console.log(res); this.roles = res.data.data; &#125;, //渲染权限列表 async getRoles()&#123; const res = await this.$http.get(`roles`); console.log(res); //this.roles = res.data.data; &#125; &#125;&#125; 10.3.3 显示已有权限123456789101112131415161718192021222324接口:获取所有权限列表获取当前角色所拥有的权限，将权限保存在默认勾选的数组中//分配权限async showRights()&#123; //显示对话框 this.dialogVisible = true; //获取树形结构的权限数据 const res = await this.$http.get(`rights/tree`); console.log(res); this.treeData = res.data.data; //获取当前角色拥有的权限id const tempArr = []; role.children.forEach(item1 =&gt; &#123; 前两个不需要添加,因为只要里面的id选中，外面的id会自动选中 //tempArr.push(item1.id); item1.children.forEach(item2 =&gt; &#123; //tempArr.push(item2.id); item2.children.forEach(item3 =&gt; &#123; tempArr.push(item3.id); &#125;); &#125;); &#125;); this.checkedArr = tempArr;&#125; 10.3.4 分配权限-分析1234567891.点击确定按钮 -&gt;发送请求 setRights()2.获取节点中全选的节点的id 3.获取节点中半选的节点的id 4.发送请求 const res = await this.$http.post(`posts/$&#123;this.currRoleId&#125;/rights`,&#123; rids:以,分割的权限id的列表 &#125;);5.关闭对话框6.更新表格 10.3.5 分配权限-实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596接口:角色授权1.&lt;el-button type=&quot;primary&quot; @click=&quot;setRights()&quot;&gt;确 定&lt;/el-button&gt;&lt;/el-button&gt;2.&lt;el-tree ref=&apos;tree&apos; :data=&quot;treeData&quot; show-checkbox node-key=&quot;id&quot; :default-expanded-keys=&quot;expandedArr&quot; :default-checked-keys=&quot;checkedArr&quot; :props=&quot;defaultProps&quot;&gt;&lt;/el-tree&gt;3.&lt;script&gt; export default &#123; data()&#123; return &#123; roles: [], //树形结构配置 dialogVisible: false, //树形结构 treeData: [], //默认展开的权限的id expandedArr:[], //默认选中的权限的id checkedArr:[], //树形结构配置 defaultProps: &#123; children: &apos;children&apos;, label: &apos;authName&apos; &#125;, currRoleId:&apos;&apos; &#125; &#125;, created()&#123; this.getRoles(); &#125;, methods: &#123; //点击确定按钮分配权限 async setRights()&#123; //通过tree树形结构的方法自动获取id 通过获取元素来操作方法 vue中通过ref来操作DOM元素 //1.获取节点中全选的节点的id //2.获取节点中半选的节点的id const arr1 = this.$refs.tree.getCheckedKeys(); const arr2 = this.$refs.tree.getHalfCheckedKeys(); //以,分割的权限id的列表 或者通过数组的方法 arr1.concat(arr2) const arr = [...arr1,...arr2]; //3.发送请求 //const res = await this.$http.post(`posts/$&#123;this.currRoleId&#125;/rights`,&#123; // rids:以,分割的权限id的列表 //&#125;); const res = await this.$http.post(`posts/$&#123;this.currRoleId&#125;/rights`,&#123; rids:arr.join(&apos;,&apos;) &#125;); console.log(res); //4.关闭对话框 this.dialogVisible = false; //5.更新表格 this.getRoles(); &#125;, //分配权限 async showRights(role)&#123; //获取当前角色的id this.currRoleId = role.id; //显示对话框 this.dialogVisible = true; //获取树形结构的权限数据 const res = await this.$http.get(`rights/tree`); console.log(res); this.treeData = res.data.data; &#125;, //删除权限 async deleRights(role,rights)&#123; const res = await this.$http.delete(`roles/$&#123;role.id&#125;/rights/$&#123;rights.id&#125;`); console.log(res); this.roles = res.data.data; //获取当前角色拥有的权限id const tempArr = []; role.children.forEach(item1 =&gt; &#123; //tempArr.push(item1.id); item1.children.treeData.forEach(item2 =&gt; &#123; // tempArr.push(item2.id); item2.children.treeData.forEach(item3 =&gt; &#123; tempArr.push(item3.id); &#125;); &#125;); &#125;); this.checkedArr = tempArr; &#125;, //渲染权限列表 async getRoles()&#123; const res = await this.$http.get(`roles`); console.log(res); //this.roles = res.data.data; &#125; &#125; &#125;&lt;/scpript&gt; 11. 首页-侧边栏-动态导航12345678910111213141516171819202122232425262728293031321.&lt;el-submenu v-for=&quot;(item1,i) in menus&quot; :index=&quot;&apos;&apos;+item1.order&quot; :key=&apos;item1.id&apos;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item :index=&quot;item2.path&quot; v-for=&apos;(item2,i) in item1.children&apos; :key=&apos;item2.id&apos;&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;&#123;&#123;item2.authName&#125;&#125; &lt;/el-menu-item&gt; &lt;/el-submenu&gt;2.data()&#123; return &#123; menus: [] &#125; &#125;, created()&#123; this.getMenus(); &#125;, beforeCreate()&#123; if(!window.localStorage.getItem(&apos;token&apos;))&#123; this.$message.warning(&apos;请先登录&apos;); this.$router.push(&#123; name: &apos;login&apos; &#125;); &#125; &#125;, methods: &#123; //侧边栏-动态导航 async getMenus()&#123; const res = await this.$http.get(`menus`); console.log(res); this.menus = res.data.data; &#125; 12. 导航守卫-路由拦截器123456789101112131415161718192021在home渲染之前,判断是否登录在路由配置生效之前,判断是否登录在每个标识生效之前，判断是不是登录标识,如果是则继续,如果不是,判断有没有token,则跳转到登录页面全局守卫://导航守卫router.beforeEach((to,from,next) =&gt; &#123; if(to.name === &apos;login&apos;)&#123; next(); &#125;else&#123; if(!window.localStorage.getItem(&apos;token&apos;))&#123; 提示消息 Message.warning(&apos;请先登录&apos;); router.push(&#123; name: &apos;login&apos; &#125;); &#125;else&#123; next(); &#125; &#125;&#125;);export default router; 13. 商品管理13.1 添加商品-步骤条121.添加提示框2.添加步骤条 goodslist.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;el-card&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1&quot;&gt; &lt;el-step title=&quot;步骤 1&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 2&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 3&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 4&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 5&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/scpript&gt;&lt;style&gt;&lt;/style&gt; 13.2 添加商品-tabs标签1234567891011121314151617181920212223242526272829303132333435363738394041当选中的是下面哪个el-tab-pane时,v-model值是当前选中的name值&lt;template&gt; &lt;el-card&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &#123;&#123;active&#125;&#125; &lt;el-tabs v-model=&quot;active&quot; tab-position=&quot;left&quot; style=&quot;height: 350px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt;基本信息&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt;商品参数&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt;商品属性&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt;商品图片&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt;商品内容&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; active: &quot;1&quot; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 13.3 添加商品基本信息-绑定表单数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667接口:添加商品因为添加商品,最后是要提交数据的，所以添加一个表单&lt;template&gt; &lt;el-card&gt; &lt;my-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/my-bread&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; 添加表单： &lt;el-form v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; &lt;el-tabs v-model=&quot;active&quot; tab-position=&quot;left&quot; style=&quot;height: 500px&quot; class=&apos;tabs&apos;&gt; 添加表单数据 &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_cat&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; ...级联选择器 &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt;商品参数&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt;商品属性&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt;商品图片&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt;商品内容&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; active: &quot;1&quot;, 数据名来源于接口数据 form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: &apos;&apos;, attrs: &apos;&apos; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; 13.4 级联选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758接口:商品数据列表1.&lt;!--级联选择器 表单元素 options： 绑定数据 v-model绑定的是一个数组:被选中的label的value值 props=&#123;label/children/value&#125;配置选项 值来源是options绑定的数据的key名 @change选择发生改变时会触发--&gt;&lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt;&lt;/el-form-item&gt;2.export default &#123; data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: &apos;&apos;, attrs: &apos;&apos; &#125;, //级联数据要使用的数据 options: &apos;&apos;, selectedOptions2: [], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125; &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; console.log(this.options); &#125; &#125; &#125; 13.5 商品参数-获取动态参数数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950接口:分类参数管理-参数列表如果要获取动态参数，必须选择商品的三级分类1.&lt;el-form label-position=&apos;top&apos; v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; 第一:给tab注册tab 被选中时触发 的事件 tab-click 来检测是不是第二个tab栏被选中 &lt;el-tabs v-model=&quot;active&quot; @tab-click = &apos;changeTab()&apos; tab-position=&quot;left&quot; style=&quot;height: 550px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_cat&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt;商品参数&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt;商品属性&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt;商品图片&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt;商品内容&lt;/el-tab-pane&gt; &lt;/el-tabs&gt;&lt;/el-form&gt;2.tab栏被选中//当tab栏选中切换时async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; $&#123;this.selectedOptions2[2]&#125;:当前选中的三级分类的id const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125;&#125; 13.6 商品参数-复选框组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172731.使用组件复选框 是表单元素 所以需要外层需要使用el-for-item&lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item v-for=&apos;(item1,i) in arrDy&apos; :key=&apos;item1.attr_id&apos; :label=&quot;item1.attr_name&quot;&gt; &lt;el-checkbox-group v-model=&quot;checkList&quot;&gt; &lt;el-checkbox v-for=&apos;(item2,i) in item1.attr_vals&apos; :key=&apos;i&apos; :label=&quot;item2&quot;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt;&lt;/el-tab-pane&gt;2.export default &#123; data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: &apos;&apos;, attrs: &apos;&apos; &#125;, //级联数据要使用的数据 options: [], selectedOptions2: [1,3,6], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, //复选框组数据 checkList: [], //动态参数数组 arrDy: [] &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //当tab栏选中切换时 async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; 因为获取参数值中attr-vals的值是字符串所以必须先转为数组 判断如果输入的是空格|空字符串的可能,如果是空字符串,则返回空数组 也要考虑中间有空格的情况 this.arrDy.forEach(item =&gt; &#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; &#125;, //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; &#125; &#125; &#125; 13.7 图片上传-文档12345678910111213Upload上传&lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload action=&quot;https://jsonplaceholder.typicode.com/posts/&quot; :on-remove=&quot;handleRemove&quot; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt;&lt;/el-tab-pane&gt; 13.8 图片上传-配置属性123456789101112131415161718192021222324252627282930313233接口:图片上传请求路径中需要添加前缀:因为设置的baseUrl只是针对axios请求的,而上传图片不针对axios1.&lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload 图片请求地址 action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&quot;handleSuccess&quot; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt;&lt;/el-tab-pane&gt;2.data()&#123; return &#123; &#125;&#125;,//上传文件的函数handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file);&#125;,handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); 图片存储服务器临时路径里面 response.data.tmp_path&#125; 14.3 商品内容-富文本编辑器1234567891011121314151617https://github.com/surmon-china/vue-quill-editorvue资源: 富文本编辑器 Rich Text Editing1.安装: npm install vue-quill-editor --save2.引入: 局部引入 import &apos;quill/dist/quill.core.css&apos; import &apos;quill/dist/quill.snow.css&apos; import &apos;quill/dist/quill.bubble.css&apos; import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos; export default &#123; //富文本编辑器 components: &#123; quillEditor &#125; &#125;3.在template中使用&lt;quill-editor&gt;&lt;/quill-editor&gt; goodsadd.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;template&gt; &lt;el-card&gt; &lt;my-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/my-bread&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-form label-position=&apos;top&apos; v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; &lt;el-tabs v-model=&quot;active&quot; @tab-click = &apos;changeTab()&apos; tab-position=&quot;left&quot; style=&quot;height: 550px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_weight&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item v-for=&apos;(item1,i) in arrDy&apos; :key=&apos;item1.attr_id&apos; :label=&quot;item1.attr_name&quot;&gt; &lt;!-- v-model控制的是全部选中的元素 --&gt; &lt;el-checkbox-group v-model=&quot;item1.attr_vals&quot;&gt; &lt;el-checkbox v-for=&apos;(item2,i) in item1.attr_vals&apos; :key=&apos;i&apos; :label=&quot;item2&quot; border&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&apos;(item,i) in arrStatic&apos; :key=&apos;item.attr_id&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;el-form-item&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&quot;handleSuccess&quot; :headers = &apos;headers&apos; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt; &lt;el-form-item&gt; &lt;el-button&gt;添加商品&lt;/el-button&gt; //富文本编辑器 &lt;quill-editor v-model=&apos;form.goods_introduce&apos;&gt;&lt;/quill-editor&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; // 富文本编辑器局部引入 import &apos;quill/dist/quill.core.css&apos; import &apos;quill/dist/quill.snow.css&apos; import &apos;quill/dist/quill.bubble.css&apos; import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos; export default &#123; //富文本编辑器 components: &#123; quillEditor //quill-editor:quill-edito &#125;, data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: [], attrs: [] &#125;, //级联数据要使用的数据 options: [], selectedOptions2: [1,3,6], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, //复选框组数据 //checkList: [], //动态参数数组 arrDy: [], //静态参数数组 arrStatic: [], //上传图片 headers: &#123; Authorization: window.localStorage.getItem(&apos;token&apos;) &#125; &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //上传文件的函数 handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file); &#125;, handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); //response.data.tmp_path &#125;, //当tab栏选中切换时 async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; this.arrDy.forEach(item =&gt; &#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; //判断当前是不是商品属性这一项,如果是的话判断有没有选中三级分类,有则获取静态商品数据 if(this.active === &apos;3&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; &#125;, //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;.form &#123; height: 400px; overflow: auto;&#125;.quill-editor &#123; margin-top: 10px;&#125;.ql-editor &#123; height: 200px;&#125;&lt;/style&gt; 13.10 表单数据处理-分类和图片123456789101112131415161718192021222324252627接口:添加商品发送添加商品请求，处理数据数据处理： 处理分类id goods_cat 图片临时路径//添加商品addGoods()&#123; //处理数据 商品分类 级联选择器数据 数组用,号分割开的字符串 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;);&#125;,//上传文件的函数handleRemove(file)&#123; console.log(&apos;移除成功&apos;); const index = this.form.pics.findIndex((item) =&gt; &#123; return item.pic === file.response.data.tmp_path; &#125;); // console.log(index); this.form.pics.splice(index,1);&#125;,handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); //console.log(response); //把临时路径放在数组中 this.form.pics.push(&#123; pic: response.data.tmp_path &#125;); //console.log(this.form.pics); //response.data.tmp_path&#125; 13.11 表单数据处理1234567891011121314151617将动态参数和静态参数数据的id和value放入attrs数组//添加商品addGoods()&#123; // 发送请求之前先处理数据 // goods_cat:商品id以,分割的字符串 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;); // 处理临时路径 this.form.pics // 处理 attrs 静态参数和动态参数id const arr1 = this.arrDy; const arr2 = this.arrStatic; const arr = [...arr1, ...arr2]; const newArr = arr.map(item =&gt; &#123; return &#123;attr_id: item.attr_id,attr_vals: item.attr_vals&#125;; &#125;); console.log(newArr); this.form.attrs = newArr;&#125; 13.12 发送请求-回到商品列表页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;template&gt; &lt;el-card&gt; &lt;my-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/my-bread&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-form label-position=&apos;top&apos; v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; &lt;el-tabs v-model=&quot;active&quot; @tab-click = &apos;changeTab()&apos; tab-position=&quot;left&quot; style=&quot;height: 550px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_weight&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item v-for=&apos;(item1) in arrDy&apos; :key=&apos;item1.attr_id&apos; :label=&quot;item1.attr_name&quot;&gt; &lt;!-- v-model控制的是全部选中的元素 --&gt; &lt;el-checkbox-group v-model=&quot;item1.attr_vals&quot;&gt; &lt;el-checkbox v-for=&apos;(item2,i) in item1.attr_vals&apos; :key=&apos;i&apos; :label=&quot;item2&quot; border&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&apos;(item) in arrStatic&apos; :key=&apos;item.attr_id&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;el-form-item&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&quot;handleSuccess&quot; :headers = &apos;headers&apos; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt; &lt;el-form-item&gt; &lt;el-button @click=&apos;addGoods()&apos;&gt;添加商品&lt;/el-button&gt; //富文本编辑器 &lt;quill-editor v-model=&apos;form.goods_introduce&apos;&gt;&lt;/quill-editor&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; // 富文本编辑器局部引入 import &apos;quill/dist/quill.core.css&apos; import &apos;quill/dist/quill.snow.css&apos; import &apos;quill/dist/quill.bubble.css&apos; import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos; export default &#123; //富文本编辑器 components: &#123; quillEditor //quill-editor:quill-edito &#125;, data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, goods_cat: &apos;&apos;, pics: [], attrs: [] &#125;, //级联数据要使用的数据 options: [], selectedOptions2: [1,3,6], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, //复选框组数据 //checkList: [], //动态参数数组 arrDy: [], //静态参数数组 arrStatic: [], //上传图片 headers: &#123; Authorization: window.localStorage.getItem(&apos;token&apos;) &#125; &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //添加商品 async addGoods()&#123; // 发送请求之前先处理数据 // goods_cat:商品id以,分割的字符串 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;); // 处理临时路径 this.form.pics // 处理 attrs 静态参数和动态参数id const arr1 = this.arrDy; const arr2 = this.arrStatic; const arr = [...arr1, ...arr2]; const newArr = arr.map(item =&gt; &#123; return &#123;attr_id: item.attr_id,attr_vals: item.attr_vals&#125;; &#125;); // console.log(newArr); this.form.attrs = newArr; const res = await this.$http.post(`goods`,this.form); console.log(res.data.meta.status); if(res.data.meta.status === 201)&#123; this.$router.push(&#123; name: &apos;goods&apos; &#125;); &#125; &#125;, //上传文件的函数 handleRemove(file)&#123; // console.log(&apos;移除成功&apos;); //console.log(file); const index = this.form.pics.findIndex(item =&gt; &#123; return file.response.data.tmp_path === item.pic; &#125;); //console.log(index); this.form.pics.splice(index,1); &#125;, handleSuccess(response)&#123; //console.log(&apos;上传成功&apos;); //console.log(response); this.form.pics.push(&#123; pic: response.data.tmp_path &#125;); //response.data.tmp_path &#125;, //当tab栏选中切换时 async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); //console.log(res); this.arrDy = res.data.data; this.arrDy.forEach(item =&gt; &#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; //判断当前是不是商品属性这一项,如果是的话判断有没有选中三级分类,有则获取静态商品数据 if(this.active === &apos;3&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); //console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; &#125;, //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;.form &#123; height: 400px; overflow: auto;&#125;.quill-editor &#123; margin-top: 10px;&#125;.ql-editor &#123; height: 200px;&#125;&lt;/style&gt; 14. 树形插件-商品分类14.1 准备组件-配置路由121.引入goodsCate.vue文件2.配置路由 14.2 element-tree-grid文档1234567891.安装 npm install element-tree-grid --save2.局部导入 先引入 var ElTreeGrid = require(&apos;element-tree-grid&apos;); 局部注册 var ElTreeGrid = require(&apos;element-tree-grid&apos;); Vue.component(ElTreeGrid.name,ElTreeGrid);3.使用&lt;el-tree-grid&gt;&lt;/el-tree-grid&gt; 14.3 element-tree-grid配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 &lt;!-- 表格 --&gt; 1. &lt;el-table height=&quot;450&quot; :data=&quot;list&quot; style=&quot;width: 100%&quot;&gt; &lt;!-- 表格展开为树形结构 --&gt; &lt;!-- treeKey 相当于 nodeKey 每个节点唯一标识 值来源于list数据中的key名 parentkey 父节点的数据的标识 cat_id levelKey 自己层级标识 childkey 子节点的数据所在key--&gt; &lt;el-tree-grid prop=&apos;cat_name&apos; label=&apos;分类名称&apos; treeKey = &apos;cat_id&apos; parentkey = &apos;cat_pid&apos; levelKey = &apos;cat_level&apos; childkey = &apos;children&apos;&gt; &lt;/el-tree-grid&gt; &lt;el-table-column label=&quot;级别&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_level===0&quot;&gt;一级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===1&quot;&gt;二级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===2&quot;&gt;三级&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;是否有效&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_deleted===false&quot;&gt;有效&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_deleted===true&quot;&gt;无效&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;2.&lt;script&gt;// 引入 element-tree-gridvar ElTreeGrid = require(&apos;element-tree-grid&apos;);export default &#123; components: &#123; ElTreeGrid &#125;, data() &#123; return &#123; list: [], pagenum: 1, pagesize: 10, total: 1, dialogFormVisibleAdd: false, form: &#123; cat_pid: -1, cat_name: &quot;&quot;, cat_level: -1 &#125;, formLabelWidth: &quot;140px&quot;, // 级联选择器要用的数据 caslist: [], selectedOptions: [], defaultProp: &#123; value: &quot;cat_id&quot;, label: &quot;cat_name&quot;, children: &quot;children&quot; &#125; &#125;; &#125;, created() &#123; this.getGoodsCate(); &#125;, methods: &#123; // 添加分类 - 发送请求 async addCate() &#123;&#125;, // 添加分类- 显示对话框 async addGoodsCate() &#123; // 获取两级分类的数据 const res = await this.$http.get(`categories?type=2`); this.caslist = res.data.data; this.dialogFormVisibleAdd = true; &#125;, // 获取所有分类 async getGoodsCate() &#123; const res = await this.$http.get( `categories?type=3&amp;pagenum=$&#123;this.pagenum&#125;&amp;pagesize=$&#123;this.pagesize&#125;` ); // console.log(res) this.list = res.data.data.result; // console.log(this.list); this.total = res.data.data.total; &#125;, // 分页的相关方法 handleSizeChange(val) &#123; // console.log(`每页 $&#123;val&#125; 条`) this.pagesize = val; this.pagenum = 1; this.getGoodsCate(); &#125;, handleCurrentChange(val) &#123; // console.log(`当前页: $&#123;val&#125;`) // this.pagenum = 2 = val this.pagenum = val; this.getGoodsCate(); &#125; &#125;&#125;;&lt;/script&gt; 14.4 添加分类-打开对话框123点击添加分类按钮,打开对话框,获取数据级联选择器二级分类数据(type=2)配置对话框中级联选择器的数据注意:添加分类,只能添加一二三级分类 14.5 添加分类-发送请求12接口： 添加分类数据点击确定按钮，发送请求 处理请求体参数数据 关闭弹出框 刷新表格 清空弹出框数据 123456789101112131415161718192021222324252627async addCate() &#123; // 处理请求体中的参数 // cat_name: &quot;&quot;, 绑定的表单数据 // cat_pid: -1, // cat_level: -1 if(this.selectedOptions.length === 0)&#123; this.form.cat_pid = 0; this.form.cat_level = 0; &#125; if(this.selectedOptions.length === 1)&#123; this.form.cat_pid = this.selectedOptions[0]; this.form.cat_level = 1; &#125; if(this.selectedOptions.length === 2)&#123; this.form.cat_pid = this.selectedOptions[1]; this.form.cat_level = 2; &#125; const res = await this.$http.post(`categories`,this.form); //console.log(res); // 清空弹出框数据 this.form = &#123;&#125;; this.selectedOptions = []; // 刷新 this.getGoodsCate(); // 关闭弹出框 this.dialogFormVisibleAdd = false; &#125; goodscate.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;template&gt; &lt;el-card class=&quot;box-card&quot;&gt; &lt;!-- 面包屑 --&gt; &lt;my-bread level1=&quot;商品管理&quot; level2=&quot;商品分类&quot;&gt;&lt;/my-bread&gt; &lt;!-- 搜索框 --&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot; class=&quot;searchArea&quot;&gt; &lt;el-button type=&quot;success&quot; @click=&quot;addGoodsCate()&quot;&gt;添加分类&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!-- 添加分类的对话框 --&gt; &lt;el-dialog title=&quot;添加分类&quot; :visible.sync=&quot;dialogFormVisibleAdd&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;分类名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.cat_name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 级联选择器 (表单元素) --&gt; &lt;el-form-item label=&quot;分类&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; change-on-select clearable :options=&quot;caslist&quot; v-model=&quot;selectedOptions&quot; :props=&quot;defaultProp&quot; &gt;&lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleAdd = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addCate()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- 表格 --&gt; &lt;el-table height=&quot;350&quot; :data=&quot;list&quot; style=&quot;width: 100%&quot;&gt; &lt;!-- 表格展开为树形结构 --&gt; &lt;!-- treeKey 相当于 nodeKey 每个节点唯一标识 值来源于list数据中的key名 parentkey 父节点的数据的标识 cat_id levelKey 自己层级标识 childkey 子节点的数据所在key--&gt; &lt;el-tree-grid prop=&apos;cat_name&apos; label=&apos;分类名称&apos; treeKey = &apos;cat_id&apos; parentkey = &apos;cat_pid&apos; levelKey = &apos;cat_level&apos; childkey = &apos;children&apos;&gt; &lt;/el-tree-grid&gt; &lt;el-table-column label=&quot;级别&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_level===0&quot;&gt;一级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===1&quot;&gt;二级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===2&quot;&gt;三级&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;是否有效&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_deleted===false&quot;&gt;有效&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_deleted===true&quot;&gt;无效&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页 --&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pagenum&quot; :page-sizes=&quot;[5, 10, 15,20]&quot; :page-size=&quot;pagesize&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot; &gt;&lt;/el-pagination&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt;// 引入 element-tree-gridvar ElTreeGrid = require(&apos;element-tree-grid&apos;);export default &#123; components: &#123; ElTreeGrid &#125;, data() &#123; return &#123; list: [], pagenum: 1, pagesize: 10, total: 1, dialogFormVisibleAdd: false, form: &#123; cat_pid: -1, cat_name: &quot;&quot;, cat_level: -1 &#125;, formLabelWidth: &quot;140px&quot;, // 级联选择器要用的数据 caslist: [], selectedOptions: [], defaultProp: &#123; value: &quot;cat_id&quot;, label: &quot;cat_name&quot;, children: &quot;children&quot; &#125; &#125;; &#125;, created() &#123; this.getGoodsCate(); &#125;, methods: &#123; // 添加分类 - 发送请求 async addCate() &#123; // 处理请求体中的参数 // cat_name: &quot;&quot;, 绑定的表单数据 // cat_pid: -1, // cat_level: -1 if(this.selectedOptions.length === 0)&#123; this.form.cat_pid = 0; this.form.cat_level = 0; &#125; if(this.selectedOptions.length === 1)&#123; this.form.cat_pid = this.selectedOptions[0]; this.form.cat_level = 1; &#125; if(this.selectedOptions.length === 2)&#123; this.form.cat_pid = this.selectedOptions[1]; this.form.cat_level = 2; &#125; const res = await this.$http.post(`categories`,this.form); //console.log(res); // 清空弹出框数据 this.form = &#123;&#125;; this.selectedOptions = []; // 刷新 this.getGoodsCate(); // 关闭弹出框 this.dialogFormVisibleAdd = false; &#125;, // 添加分类- 显示对话框 async addGoodsCate() &#123; // 获取两级分类的数据 const res = await this.$http.get(`categories?type=2`); this.caslist = res.data.data; this.dialogFormVisibleAdd = true; &#125;, // 获取所有分类 async getGoodsCate() &#123; const res = await this.$http.get( `categories?type=3&amp;pagenum=$&#123;this.pagenum&#125;&amp;pagesize=$&#123;this.pagesize&#125;` ); // console.log(res) this.list = res.data.data.result; // console.log(this.list); this.total = res.data.data.total; &#125;, // 分页的相关方法 handleSizeChange(val) &#123; // console.log(`每页 $&#123;val&#125; 条`) this.pagesize = val; this.pagenum = 1; this.getGoodsCate(); &#125;, handleCurrentChange(val) &#123; // console.log(`当前页: $&#123;val&#125;`) // this.pagenum = 2 = val this.pagenum = val; this.getGoodsCate(); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.box-card &#123; height: 100%;&#125;.searchArea &#123; margin-top: 10px; margin-bottom: 10px;&#125;.searchArea .searchInput &#123; width: 350px;&#125;&lt;/style&gt; 16. 订单管理16.1 订单列表-配置路由-省市区引入123456orders/ 省市区插件没有请求接口,因为几乎所有设备都需要使用1.引入 // catlist是一个数组import catlist from &apos;@/assets/city_data2017_element.js&apos;;2.点击编辑按钮弹出弹出框,在弹出框里设置数据this.catlist = catlist; 17. 数据统计17.1 数据报表-Echarts-配置路由123456789101112131415161718192021222324252627282930313233343536373839404142百度地图 www.echartsjs.com1.安装 npm install echarts --save2.导入import echarts from &apos;echarts&apos;;3.定义标签 &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; 4.// 引入图表文件import echarts from &apos;echarts&apos;;export default &#123; 要操作DOM需要在mounted中 mounted()&#123; this.initEcharts(); &#125;, methods: &#123; initEcharts()&#123; // 初始化 var myChart = echarts.init(document.getElementById(&apos;main&apos;)); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: &apos;ECharts 入门示例&apos; &#125;, tooltip: &#123;&#125;, legend: &#123; data:[&apos;销量&apos;] &#125;, xAxis: &#123; data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &apos;销量&apos;, type: &apos;bar&apos;, data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &#125;&#125; 17.2 数据报表-Echarts-配置123456789文档接口参数不正确: 获取图表所需数据接口: reports/:type接口文档没写怎么传: :type 测试: reports/:type reports reports/type=bing reports?type=1 reports/type/1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;el-card&gt; &lt;!-- 面包屑 --&gt; &lt;my-bread level1=&quot;数据统计&quot; level2=&quot;数据报表&quot;&gt;&lt;/my-bread&gt; &lt;!-- 图表 --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 800px;height:400px;margin-top:20px&quot;&gt;&lt;/div&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt;// 引入图表文件import echarts from &apos;echarts&apos;;export default &#123; data()&#123; return &#123; &#125; &#125;, mounted()&#123; this.initEcharts(); &#125;, methods: &#123; async initEcharts()&#123; // 初始化折线图 var myChart = echarts.init(document.getElementById(&apos;main&apos;)); // 获取图标数据 const res = await this.$http.get(`reports/type/1`); //console.log(res); const option1 = res.data.data; // 指定图表的配置项和数据 const option2 = &#123; title: &#123; text: &apos;堆叠区域图&apos; &#125;, tooltip : &#123; trigger: &apos;axis&apos;, axisPointer: &#123; type: &apos;cross&apos;, label: &#123; backgroundColor: &apos;#6a7985&apos; &#125; &#125; &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, grid: &#123; left: &apos;3%&apos;, right: &apos;4%&apos;, bottom: &apos;3%&apos;, containLabel: true &#125; &#125;; const option = &#123;...option1, ...option2&#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 18. 优化-加载动画1234567组件: loading加载1.通过自定义指令给表格添加 属性 数据loading为布尔值&lt;el-table v-loading=&quot;loading&quot; :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt;2.默认数据为false，请求数据之前设置this.loading = true,请求获取之后设置为true 19. 优化-拦截器统一处理响应main.js第一种写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;// 引入element-ui;import ElementUI from &apos;element-ui&apos;import &apos;element-ui/lib/theme-chalk/index.css&apos;import &apos;@/assets/index.css&apos;import moment from &apos;moment&apos;import MyBread from &apos;@/components/cusBread.vue&apos;// import Http from &apos;@/http/http.js&apos;// Vue.use(Http);import axios from &apos;axios&apos;import &#123;Message&#125; from &apos;element-ui&apos;axios.defaults.baseURL = &quot;http://localhost:8888/api/private/v1/&quot;;// 添加一个请求拦截器axios.interceptors.request.use(function (config) &#123; //在发送请求之前希望做些什么 //如果请求的不是登录请求，则设置拦截进行下面的代码 //根据config.url可以获取当前请求的地址 //console.log(config); if(config.url !== &apos;login&apos;)&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); config.headers.Authorization = AUTH_TOKEN; &#125; return config;&#125;, function (error) &#123; // Do something with request error return Promise.reject(error);&#125;);//添加响应拦截器// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; console.log(response); const msg = response.data.meta.msg; const status = response.data.meta.status; if(status !== 200 &amp;&amp; status !== 201)&#123; Message.warning(msg); &#125; return response;&#125;, function (error) &#123;// 对响应错误做点什么 return Promise.reject(error);&#125;);Vue.prototype.$http = axios;Vue.use(ElementUI)Vue.config.productionTip = false//定义全局组件Vue.component(&quot;my-bread&quot;,MyBread);// 格式化日期的过滤器Vue.filter(&apos;fmDate&apos;,(v) =&gt; &#123; return moment(v).format(&apos;YYYY-MM-DD&apos;);&#125;);/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) main.js第二种写法 12import Http from &apos;@/http/http.js&apos;Vue.use(Http); http.js 12345678910111213141516171819202122232425262728293031323334353637import axios from &apos;axios&apos;import &#123;Message&#125; from &apos;element-ui&apos;const Http = &#123;&#125;Http.install = function(Vue, options) &#123; axios.defaults.baseURL = &quot;http://localhost:8888/api/private/v1/&quot;; // 添加一个请求拦截器 axios.interceptors.request.use(function (config) &#123; //在发送请求之前希望做些什么 //如果请求的不是登录请求，则设置拦截进行下面的代码 //根据config.url可以获取当前请求的地址 //console.log(config); if(config.url !== &apos;login&apos;)&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); config.headers.Authorization = AUTH_TOKEN; &#125; return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;); //添加响应拦截器 // 添加响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(response); const msg = response.data.meta.msg; const status = response.data.meta.status; if(status !== 200 &amp;&amp; status !== 201)&#123; Message.warning(msg); &#125; return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); Vue.prototype.$http = axios;&#125;export default Http 20. 优化-路由懒加载123456789101112131415161718192021222324首屏加载慢: 一次性加载所有组件使用哪个组件加载哪个组件vueejs.com 路由懒加载把所有index.js组件中所有的路由配置修改为const Vue = () =&gt; import(&apos;vue&apos;);将页面中需要的标识对应的组件，写成懒加载形式import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import &#123;Message&#125; from &apos;element-ui&apos;const Login = () =&gt; import(&apos;@/components/login.vue&apos;)const Home = () =&gt; import(&apos;@/components/home.vue&apos;)const Users = () =&gt; import(&apos;@/components/users.vue&apos;)const Rights = () =&gt; import(&apos;@/components/rights.vue&apos;)const Roles = () =&gt; import(&apos;@/components/roles.vue&apos;)const Goodslist = () =&gt; import(&apos;@/components/goodslist.vue&apos;)const Goodsadd = () =&gt; import(&apos;@/components/goodsadd.vue&apos;)const Params = () =&gt; import(&apos;@/components/params.vue&apos;)const Goodscate = () =&gt; import(&apos;@/components/goodsCate.vue&apos;)const Order = () =&gt; import(&apos;@/components/order.vue&apos;)const Reports = () =&gt; import(&apos;@/components/reports.vue&apos;)多会需要多会加载如果不处理 - 打包后 -项目中所有的组件 会生成一个js文件如果路由懒加载 - 打包后 - 项目中每个组件-&gt;会生成自己的js文件npm run build 打包 21. nextTick方法12345678改变数据需要时间-经过时间-&gt;渲染视图修改过数据之后，立马获取DOM元素的数据，获取到的是之前的数据,执行完数据之后，需要经过updata和beforeUpdata钩子函数之后，数据才能改变,而这一过程需要时间,所以,如果想要实时获取DOM元素的数据,可以在获取元素时,1）使用定时器2）使用vue实例的 $nextTick()方法this.$nextTick(() =&gt; &#123; console.log(this.$refs.p.innerText);&#125;); 111.html 1234567891011121314151617181920212223242526&lt;div class=&quot;main&quot;&gt; &lt;button @click=&apos;add()&apos;&gt;按钮&lt;/button&gt;&#123;&#123;num&#125;&#125; &lt;p ref=&apos;p&apos;&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &apos;.main&apos;, data: &#123; num: &apos;&apos; &#125;, methods: &#123; add()&#123; this.num ++; console.log(this.$refs.p.innerText); 打印的p标签中的值是++之前的值,因为数据加完之后，执行update函数还需要一段时间，如果想要获取++之后的值,需要添加定时器或者使用vue的$nextTick函数 1)setInterval(() =&gt; &#123; console.log(this.$refs.p.innerText); &#125;); 2)this.$nextTick(() =&gt; &#123; console.log(this.$refs.p.innerText); &#125;); &#125; &#125; &#125;); &lt;/script&gt; 22. 优化－CDN配置123456789101112131415161718192021222324１.项目中引用的资源是通过node_module来获取，在打包过程中，node_modelu也会被打包－＞项目包会很大２.项目资源改成从网络资源获取，从CDN获取３.package.json 文件中 依赖项 dependencies配置项中的内容都是从npm下载的, 把里面的资源改成cdn引入package.json文件&quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.2&quot;, &quot;vue-router&quot;: &quot;^3.0.1&quot;, &quot;element-ui&quot;: &quot;^2.6.1&quot;, &quot;axios&quot;: &quot;^0.18.0&quot;, &quot;moment&quot;: &quot;^2.24.0&quot;, &quot;echarts&quot;: &quot;^4.2.1&quot;, &quot;element-tree-grid&quot;: &quot;^0.1.3&quot;, &quot;vue-quill-editor&quot;: &quot;^3.0.6&quot; &#125;４.在vue官网找到对应得cdn资源，将cdn添加到index.html文件中&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/moment.js/2.24.0/moment.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js&quot;&gt;&lt;/script&gt;５.所有的主流框架和三方资源都可以在CDN网站中找到https://www.bootcdn.cn6.小的插件资源找不到 文件大小比较小 不替换也可以 1234567891011121314151617181920212223241.找到package.json中使用的包2.找包的对应cdn网址 － 官网＋bootcdn3.引入 index.html src4.修改webpack打包配置 https://www.webpackjs.com/在webpack网站配置查找cdn配置方法webpack.base.config.jsmodule.exports = &#123; //... externals: &#123; key =&gt; 包名 =&gt; package.json value =&gt; 该包源码中暴露在全局中的变量名 &quot;vue&quot;: &apos;Vue&apos;, &quot;vue-router&quot;: &apos;vueRouter&apos;, &quot;element-ui&quot;: &apos;ELEMENT&apos;, &quot;axios&quot;: &apos;axios&apos;, &quot;moment&quot;: &apos;moment&apos;, &quot;echarts&quot;: &apos;echarts&apos; &#125;&#125;;5.把页面中所有导包所接收的变量与上面的全局中的变量名一样import Vue from &apos;vue&apos;;注意： 配置js的CDN资源－全局变量名－源码前几行define／exports／require／globallink的src不需要单独配置 －在main.js中 把之前引入.css文件的代码删除掉]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
