<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Fsongfang0%2F2019%2F08%2F13%2Fjs%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 实现一个call函数123456789101112// 将要改变this指向的方法挂到目标this上执行并返回Function.prototype.mycall = function (context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;not funciton&apos;) &#125; context = context || window context.fn = this let arg = [...arguments].slice(1) let result = context.fn(...arg) delete context.fn return result&#125; 2. 实现一个apply函数123456789101112131415Function.prototype.myapply = function (context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;not funciton&apos;) &#125; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 3. 实现一个bind函数123456789101112131415Function.prototype.mybind = function (context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; let _this = this let arg = [...arguments].slice(1) return function F() &#123; // 处理函数使用new的情况 if (this instanceof F) &#123; return new _this(...arg, ...arguments) &#125; else &#123; return _this.apply(context, arg.concat(...arguments)) &#125; &#125;&#125; 4. instanceof的原理1234567891011121314// 右边变量的原型存在于左边变量的原型链上function instanceOf(left, right) &#123; let leftValue = left.__proto__ let rightValue = right.prototype while (true) &#123; if (leftValue === null) &#123; return false &#125; if (leftValue === right) &#123; return true &#125; leftValue = rightValue.__proto__ &#125;&#125; 5. Object.create的基本实现原理1234function create(obj) &#123; function F() &#123;&#125; F.prototype = obj return new F() 6. new本质123456789101112131415161718function myNew (fun) &#123; return function () &#123; // 创建一个新对象且将其隐式原型指向构造函数原型 let obj = &#123; __proto__ : fun.prototype &#125; // 执行构造函数 fun.call(obj, ...arguments) // 返回该对象 return obj &#125;&#125;function person(name, age) &#123; this.name = name this.age = age&#125;let obj = myNew(person)(&apos;chen&apos;, 18) // &#123;name: &quot;chen&quot;, age: 18&#125; 7. 实现一个基本的Promise123456789101112131415161718192021222324252627282930313233343536373839// ①自动执行函数，②三个状态，③thenclass Promise &#123; constructor (fn) &#123; // 三个状态 this.state = &apos;pending&apos; this.value = undefined this.reason = undefined let resolve = value =&gt; &#123; if (this.state === &apos;pending&apos;) &#123; this.state = &apos;fulfilled&apos; this.value = value &#125; &#125; let reject = value =&gt; &#123; if (this.state === &apos;pending&apos;) &#123; this.state = &apos;rejected&apos; this.reason = value &#125; &#125; // 自动执行函数 try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125; // then then(onFulfilled, onRejected) &#123; switch (this.state) &#123; case &apos;fulfilled&apos;: onFulfilled() break case &apos;rejected&apos;: onRejected() break default: &#125; &#125;&#125; 8. 实现一个基本的深拷贝1234567891011121314// 1. JOSN.stringify()/JSON.parse()let obj = &#123;a: 1, b: &#123;x: 3&#125;&#125;JSON.parse(JSON.stringify(obj))// 2. 递归拷贝function deepClone(obj) &#123; let copy = obj instanceof Array ? [] : &#123;&#125; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; copy[i] = typeof obj[i] === &apos;object&apos; ? deepClone(obj[i]) : obj[i] &#125; &#125; return copy&#125; 9. 使用setTimeout模拟setInterval12345// 可避免setInterval因执行时间导致的间隔执行时间不一致setTimeout (function () &#123; // do something setTimeout (arguments.callee, 500)&#125;, 500) 10. js实现一个继承方法// 借用构造函数继承实例属性123456789function Child () &#123; Parent.call(this)&#125;// 寄生继承原型属性(function () &#123; let Super = function () &#123;&#125; Super.prototype = Parent.prototype Child.prototype = new Super()&#125;)() 11. 实现浅拷贝123456// 1. ...实现let copy1 = &#123;...&#123;x:1&#125;&#125;// 2. Object.assign实现let copy2 = Object.assign(&#123;&#125;, &#123;x:1&#125;) 12. 实现一个基本的Event Bus123456789101112131415161718192021222324252627// 组件通信，一个触发与监听的过程class EventEmitter &#123; constructor () &#123; // 存储事件 this.events = this.events || new Map() &#125; // 监听事件 addListener (type, fn) &#123; if (!this.events.get(type)) &#123; this.events.set(type, fn) &#125; &#125; // 触发事件 emit (type) &#123; let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) &#125;&#125;// 测试let emitter = new EventEmitter()// 监听事件emitter.addListener(&apos;ages&apos;, age =&gt; &#123; console.log(age)&#125;)// 触发事件emitter.emit(&apos;ages&apos;, 18) // 18 13. 实现一个双向数据绑定12345678910111213141516171819let obj = &#123;&#125;let input = document.getElementById(&apos;input&apos;)let span = document.getElementById(&apos;span&apos;)Object.defineProperty(obj, &apos;text&apos;, &#123; configurable: true, enumerable: true, get() &#123; console.log(&apos;获取数据了&apos;) return obj.text &#125;, set(newVal) &#123; console.log(&apos;数据更新了&apos;) input.value = newVal span.innerHTML = newVal &#125;&#125;)input.addEventListener(&apos;keyup&apos;, function(e) &#123; obj.text = e.target.value&#125;) 14. 实现一个简单路由12345678910111213141516171819202122class Route&#123; constructor()&#123; // 路由存储对象 this.routes = &#123;&#125; // 当前hash this.currentHash = &apos;&apos; // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener(&apos;load&apos;, this.freshRoute, false) window.addEventListener(&apos;hashchange&apos;, this.freshRoute, false) &#125; // 存储 storeRoute (path, cb) &#123; this.routes[path] = cb || function () &#123;&#125; &#125; // 更新 freshRoute () &#123; this.currentHash = location.hash.slice(1) || &apos;/&apos; this.routes[this.currentHash]() &#125;&#125; 15. 实现懒加载1234567891011121314151617181920212223242526272829&lt;ul&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/1.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/2.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/3.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/4.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/5.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/6.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/7.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/8.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/9.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;./imgs/default.png&quot; data=&quot;./imgs/10.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;&lt;/ul&gt;let imgs = document.querySelectorAll(&apos;img&apos;)// 可视区高度let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeightfunction lazyLoad () &#123; // 滚动卷去的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop for (let i = 0; i &lt; imgs.length; i ++) &#123; // 得到图片顶部距离可视区顶部的距离 let x = clientHeight + scrollTop - imgs[i].offsetTop // 图片在可视区内 if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123; imgs[i].src = imgs[i].getAttribute(&apos;data&apos;) &#125; &#125;&#125;setInterval(lazyLoad, 1000) 16. rem实现原理1234567function setRem () &#123; let doc = document.documentElement let width = doc.getBoundingClientRect().width // 假设设计稿为宽750，则rem为10px let rem = width / 75 doc.style.fontSize = rem + &apos;px&apos;&#125; 17. 手写实现AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/ 1. 简单实现// 实例化let xhr = new XMLHttpRequest()// 初始化xhr.open(method, url, async)// 发送请求xhr.send(data)// 设置状态变化回调处理请求结果xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 2. 基于promise实现function ajax (options) &#123; // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || &apos;get&apos; // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; // 返回一个Promise实例 return new Promise ((resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject(&apos;请求超时&apos;) // 监听状态变化回调 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; // 错误回调 xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(data[key])) &#125; encodeData = paramArr.join(&apos;&amp;&apos;) &#125; // get请求拼接参数 if (method === &apos;get&apos;) &#123; // 检测url中是否已存在 ? 及其位置 const index = url.indexOf(&apos;?&apos;) if (index === -1) url += &apos;?&apos; else if (index !== url.length -1) url += &apos;&amp;&apos; // 拼接url url += encodeData &#125; // 初始化 xhr.open(method, url, async) // 发送请求 if (method === &apos;get&apos;) xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded;charset=UTF-8&apos;) xhr.send(encodeData) &#125; &#125;)&#125; 18. 实现拖拽1234567891011121314151617181920212223242526272829303132window.onload = function () &#123; // drag处于绝对定位状态 let drag = document.getElementById(&apos;box&apos;) drag.onmousedown = function(e) &#123; var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) &#123; // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left &lt; 0) &#123; left = 0 &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123; left = window.innerWidth - drag.offsetWidth &#125; if (top &lt; 0) &#123; top = 0 &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123; top = window.innerHeight - drag.offsetHeight &#125; drag.style.left = left + &apos;px&apos; drag.style.top = top + &apos;px&apos; &#125; drag.onmouseup = function (e) &#123; this.onmousemove = null this.onmouseup = null &#125; &#125;&#125; 19. 实现一个节流函数123456789101112131415161718function throttle (fn, delay) &#123; // 利用闭包保存时间 let prev = Date.now() return function () &#123; let context = this let arg = arguments let now = Date.now() if (now - prev &gt;= delay) &#123; fn.apply(context, arg) prev = Date.now() &#125; &#125;&#125;function fn () &#123; console.log(&apos;节流&apos;)&#125;addEventListener(&apos;scroll&apos;, throttle(fn, 1000)) 20. 实现一个防抖函数123456789101112131415161718function debounce (fn, delay) &#123; // 利用闭包保存定时器 let timer = null return function () &#123; let context = this let arg = arguments // 在规定时间内再次触发会先清除定时器后再重设定时器 clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(context, arg) &#125;, delay) &#125;&#125;function fn () &#123; console.log(&apos;防抖&apos;)&#125;addEventListener(&apos;scroll&apos;, debounce(fn, 1000)) 21.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649090093&amp;idx=3&amp;sn=33f6ad07ded8f76f59effe0be854e5b1&amp;chksm=be5bcf80892c4696273f64aca067d8f0b167688af8bd493f1b0e4c156c665ae41584fbbbbf64&amp;scene=21#wechat_redirect一、理论知识1.1、讲讲输入完网址按下回车，到看到网页这个过程中发生了什么a. 域名解析b. 发起TCP的3次握手c. 建立TCP连接后发起http请求d. 服务器端响应http请求，浏览器得到html代码e. 浏览器解析html代码，并请求html代码中的资源f. 浏览器对页面进行渲染呈现给用户参考《一次完整的HTTP事务是怎样一个过程》1.2、谈谈你对前端性能优化的理解a. 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域b. 请求带宽：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体c. 缓存利用：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存d. 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出e. 代码校验：避免CSS表达式，避免重定向参考《前端工程与性能优化》1.3、前端 MV*框架的意义早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，基本不太需要框架。随着 AJAX 的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了。如果是页面型产品，多数确实不太需要它，因为页面中的 JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的 MV框架，这个状况会大有改观。之所以感受不到 MV*框架的重要性，是因为Model部分代码较少，View的相对多一些。如果主要在操作View和Controller，那当然 jQuery 这类库比较好用了。参考《前端 MV*框架的意义》1.4、请简述盒模型IE6盒子模型与W3C盒子模型。文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。CSS3中有个box-sizing属性可以控制盒子的计算方式，content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。（W3C盒子模型）border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。（IE6盒子模型）参考《盒模型》1.5、请你谈谈Cookie的弊端a. 每个特定的域名下最多生成的cookie个数有限制b. IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookiec. cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节d. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。1.6、浏览器本地存储在HTML5中提供了sessionStorage和localStorage。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。1.7、web storage和cookie的区别a. Cookie的大小是受限的b. 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽c. cookie还需要指定作用域，不可以跨域调用d. Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookiee. Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生f. IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage1.8、对BFC规范的理解BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。利用BFC可以闭合浮动，防止与浮动元素重叠。参考《Learning BFC》1.9、线程与进程的区别a. 一个程序至少有一个进程，一个进程至少有一个线程b. 线程的划分尺度小于进程，使得多线程程序的并发性高c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配1.10、请说出三种减少页面加载时间的方法a. 尽量减少页面中重复的HTTP请求数量b. 服务器开启gzip压缩c. css样式的定义放置在文件头部d. Javascript脚本放在文件末尾e. 压缩合并Javascript、CSS代码f. 使用多域名负载网页内的多个文件、图片参考《减低页面加载时间的方法》1.11、你都使用哪些工具来测试代码的性能？JSPerf, Dromaeo1.12、你遇到过比较难的技术问题是？你是如何解决的？1.13、你常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？1.14、列举IE与其他浏览器不一样的特性？a. IE的排版引擎是Trident （又称为MSHTML）b. Trident内核曾经几乎与W3C标准脱节（2005年）c. Trident内核的大量 Bug等安全性问题没有得到及时解决d. JS方面，有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等e. CSS方面，也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式参考《Trident（排版引擎）》1.15、什么叫优雅降级和渐进增强？渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。区别：a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带参考《优雅降级和渐进增强的区别》1.16、WEB应用从服务器主动推送Data到客户端有那些方式？a. html5 websoketb. WebSocket 通过 Flashc. XHR长时间连接d. XHR Multipart Streaminge. 不可见的Iframef. 标签的长时间连接(可跨域)1.17、对前端界面工程师这个职位是怎么样理解的？a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好b. 参与项目，快速高质量完成实现效果图，精确到1px；c. 与团队成员，UI设计，产品经理的沟通；d. 做好的页面结构，页面重构和用户体验；e. 处理hack，兼容、写出优美的代码格式；f. 针对服务器的优化、拥抱最新前端技术。1.18、你在现在的团队处于什么样的角色，起到了什么明显的作用？请自行根据自己情况做回答，这个没有标准答案。1.19、你的优点是什么？缺点是什么？请自行根据自己情况做回答，这个没有标准答案。1.20、如何管理前端团队?请自行根据自己情况做回答，这个没有标准答案。1.21、最近在学什么？能谈谈你未来3，5年给自己的规划吗？请自行根据自己情况做回答，这个没有标准答案。1.22、平时如何管理你的项目？a. 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；b. 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；c. 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；d. 页面进行标注（例如 页面 模块 开始和结束）；e. CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；f. JS 分文件夹存放 命名以该JS功能为准的英文翻译。g. 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理1.23、说说最近最流行的一些东西吧？常去哪些网站？CSDN、SegmentFault、php.net、MDN、css参考手册、iconfont、underscore、github、Bootstrap、W3Shool、W3Cplus、caniuse1.24、请解释一下 JavaScript 的同源策略同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。1.25、AMD和CMD 规范的区别？AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现CMD 按需执行依赖 - 懒执行，seaJS 是它的实现参考《SeaJS与RequireJS最大的区别》、《与 RequireJS 的异同》1.26、网站重构的理解重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。a. 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)b. 对于移动平台的优化，针对于SEO进行优化c. 减少代码间的耦合，让代码保持弹性d. 压缩或合并JS、CSS、image等前端资源1.27、浏览器的内核分别是什么?IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink（WebKit的分支）、Opera内核原为Presto，现为Blink；1.28、请介绍下cache-control每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。1.29、前端页面有哪三层构成，分别是什么？作用是什么？a. 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。b. 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。c. 行为层：由脚本负责。解决了页面上“内容应该如何对事件作出反应”的问题。1.30、知道的网页制作会用到的图片格式有哪些？png-8，png-24，jpeg，gif，svgWebp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。1.31、一次js请求一般情况下有哪些地方会有缓存处理？a. 浏览器端存储b. 浏览器端文件缓存c. HTTP缓存304d. 服务器端文件类型缓存e. 表现层&amp;DOM缓存参考《一次HTTP请求中有哪些地方可以缓存》1.32、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。a. 图片懒加载，滚动到相应位置才加载图片。b. 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。c. 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。d. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。1.33、谈谈以前端角度出发做好SEO需要考虑什么？a. 了解搜索引擎如何抓取网页和如何索引网页b. meta标签优化c. 关键词分析d. 付费给搜索引擎e. 链接交换和链接广泛度（Link Popularity）f. 合理的标签使用 22.1https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649090109&amp;idx=3&amp;sn=d0e5a2f009cd900d50a5d46e6a0cdadc&amp;chksm=be5bcf90892c46861b892e5c55dab0a7ee177a8f420f464b5c186727c73c76469ea9ae27c367&amp;mpshare=1&amp;scene=24&amp;srcid=01274VLuLNRLwFqxtJB6yvAx#rd]]></content>
  </entry>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2Fsongfang0%2F2019%2F08%2F13%2Fangular%2F</url>
    <content type="text"><![CDATA[Angular123angular优点: 模板功能强大丰富 比较完善的前端MVC框架 1. angular安装12345678910111213141516npm i -g angular-cli 使用cnpm安装可能导致版本不一致npm --version 查看angular-cli是否安装成功ng helpng new 项目名 新建项目ng new router --routing 带有路由参数的项目ng serve 启动项目ng serve --prod --aot 最新版的CLI加上--prod和--aot参数就自动AOT了启动服务之后发现包特别大: 可以添加以下命令 ng serve --prod --aot编译: ng build 或者 ng build --prod --aot自动化测试: ng testng serve: 运行开发模式ng build --prod: 运行项目打包构建(用于发布到生产环境)ng test: 运行karma单元测试ng lint:运行typescript代码校验ng e2e: 运行protractor端到端测试 angular-cli安装 12345如果安装过程中安装失败或者是由于网络导致的,可以使用npm config list 查看哪些项需要配置: ...... npm config set proxy=&apos;&apos; npm config delete proxy 命令简化版本 12345678ng generate cl:class c:component d:directive e:enum m:module p:pipe s:service命令简化版本: ng g c User 路由 12路由本身 &#123;path: &apos;&apos;, component: &apos;&apos;&#125;异步路由:｛path: &apos;&apos;,loadChildren: &apos;&apos;6｝ UI组件库 12UI Librariesng2-bootstrap、PrimeNG、Angular-Material2、Ionic 2. 搭建开发环境12方案1: angular-cli(内核也是webpack) 推荐使用cnpm来安装angular-cli方案2: webpack https://github.com/kun1/Angular-webpack-AOT 貌似不能访问了 NiceFish演示 12345678910https://gitee.com/mumu-osc/NiceFish 码云参考地址git clone https://gitee.com/mumu-osc/NiceFish.gitcd NiceFishnpm i -g cnpm --registry=https://registry.npm.taobao.org 修改为国内镜像 安装cnpmcnpm i -g @angular/cli 安装angular-cling helpng version 版本号 检测是否安装成功 ng -v 查看安装版本cnpm i 安装项目依赖项ng serve --open 在浏览器打开 ng serve --prod --aot 3. 详解组件12345678910111213141516组件 TS代码、模板(数据绑定、事件绑定)、外观与动效、把服务注入给组件 (keyup)=&quot;searchText($event)&quot; ()用来绑定事件 [(ngModel)]=&quot;searchText&quot; [()] 用来数据双向绑定 &#123;&#123;&#125;&#125; 值绑定组件间通讯 @Input与@Output、借助于Service、借助于路由通讯 1.给子组件传递参数 在ts文件中,定义 @Input() public panelTitle:string; 使用的时候直接在组件中赋值 &lt;div panelTitle=&quot;作者信息&quot;&gt;&lt;div&gt; 2.子组件给父组件传递参数 @OutputO 定义实例 3.借助于ServiceContentChild与ViewChild生命周期钩子函数: OnInit、AfterContentInit、AfterViewInit、Onchanges、DoCheck、AfterContentChecked、AfterViewChecked、OnDestroy管道 4. 路由1234567路由基本配置: &#123; path: &apos;&apos;, component: &apos;&apos; 或者写 loadChildren: &apos;./home/home.module#HomeModule &apos; &#125; &lt;router-outlet&gt; &lt;a routerLink=&quot;&quot;&gt; 5. 文件目录介绍12345678910111213141516171819202122232425e2e： 端到端测试node_modules： npm第三方依赖包angular-cli.json: angular-cli 命令行工具的配置文件 脚手架工具配置文件.editorconfig: 针对编辑器的代码风格约束.gitignore： git仓库忽略配置项karma.conf.js: 单元测试的集成器, karma的配置文件,执行自动化及测试的package.json: npm依赖包tsconfig.json： typescript配置文件telint.json: typescript代码风格校验工具配置文件src文件夹： app：用户的组件和模块 app.module.ts: 模块 app.component.ts: 组件 @Component(): 装饰器 Template: 模块 Controller: 控制器 app.component.html: app.component.css: app.component.js: assets：静态资源的 environments：多环境的配置文件 index.html: 整个目录的根html main.js: 脚本执行的入口文件 polyfills.ts: 导入一些必要的库，使angular运行在某些老版本的浏览器中 styles.css: 全局样式 app.component.ts 123456789101112131415161718192021222324252627从angular的核心库导入装饰器import &#123;Component&#125; from &apos;@angular/core&apos;装饰器@Componet(&#123; selector: &apos;app-root&apos;, templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;]&#125;)控制器export class AppComponent &#123; title = &apos;app works&apos;; 输入属性 @Inputs() 提供器 providers 生命周期钩子 Lifecycle Hooks 输出对象 输出属性 @Outputs 动画 Animations 样式表 styles 声明周期钩子 Lifecycle Hooks&#125; app.component.html 1&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt; app.module.ts 1234567891011121314import &#123;&#125; from &apos;./app.component&apos;;@NgModule(&#123; declarations: [ AppComponent 只能声明组件、指令、管道 ], import: [ 依赖的其他模块 BrowserModule, 必须要选的依赖 浏览器模块 FormsModule, 表单模块 HttpModule ], provideers: [], 提供什么服务，只能声明服务 bootstrap: [AppComponent] 主组件&#125;)wxport class AppModule &#123;&#125; 6. angular启动过程介绍12angular-cli.json: 加载index.html main.ts负责项目启动 7. 第三方库的使用1234567891011121314151.安装 npm i jquery bootatrap2.配置 在angular-cli.json 文件下,添加第三方的css样式和js库 &quot;styles&quot;: [ &quot;styles.css&quot;, &quot;../node_modules/bootstrap/dist/css/bootstrap.css&quot; ] &quot;scripts&quot;: [ &quot;../node_modules/jquery/jquery.js&quot;, &quot;../node_modules/bootstrap/dist/bootstrap.js&quot; ]3.jquery是js的东西，不认识，所以需要安装 npm i @types/jquery --save-dev 类型描述文件 npm i @types/bootstrap --save-dev 让typescript的代码认识javascript的代码 可以使用jquery的方法 8. 生成所需要的组件12ng g component user在app.module.ts文件中会自动配置组件 app-component.html 1234567891011121314151617&lt;app-nav&gt;&lt;/app-nav&gt;&lt;div class=&apos;container&apos;&gt; &lt;div class=&apos;row&apos;&gt; &lt;div class=&apos;col-md-3&apos;&gt; &lt;app-search&gt;&lt;/app-search&gt; &lt;/div&gt; &lt;div class=&apos;col-md-9&apos;&gt; &lt;div class=&apos;row&apos;&gt; &lt;div class=&apos;app-carousel&apos;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&apos;row&apos;&gt; &lt;div class=&apos;app-product &apos;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;app-foot&gt;&lt;/app-foot&gt; 9. 知识点9.1 循环12在开发product组件中循环使用的是 *ngFor=&apos;let item of arr&apos; &#123;&#123;item.title&#125;&#125; ng-repeat=&apos;&apos; 9.2 属性绑定1234567&lt;img src=&apos;&apos; alt=&apos;&apos;&gt;属性绑定： 如果ts文件中定义了一个src,那么使用自定义属性的方式 private imgUrl = &apos;http://placehold.it/320x150&apos;; &lt;img [src]=&apos;imgUrl&apos;&gt;样式绑定： &lt;span class=&apos;cls&apos; [class.red]=&apos;star&apos;&gt;&lt;/span&gt; private star = true; 9.3 父传子组件传值123456789101112在子组件的ts文件中 第一步： export class startsComponent implements OnInit &#123; 输入属性 @Input() private rating:number = 0; &#125; 第二步： html文件中可以显示 &lt;span&gt;&#123;&#123;rating&#125;&#125;&lt;/span&gt; 第三步： 在父组件中使用子组件的地方 &lt;app-st 10. 使用angular Route导航10.1 路由相关对象12345Routes: 路由配置,保存着哪个URL对应展示哪个组件,以及在哪个RouterOutlet中展示组件RouterOutlet: 在html中路由内容呈现为你织的占位符指令Router: 负责在运行时执行路由的对象,可以通过调用其navigate()和navigateByUrl()方法来导航到一个指定的路由RouterLink: 在html中声明路由导航用的指令ActivatedRoute: 当前激活的路由对象,保存着当前路由的信息,如路由地址,路由参数等。 10.2 配置路由1在app文件夹下,app-routing.module.ts文件中配置路由,在app.module.ts文件中导入路由模块。 app-routing.module.ts 12345678910111213141516171819导入import &#123;HomeComponent&#125; from &apos;./home/home.component&apos;;import &#123;ProductComponent&#125; from &apos;./Product/Product.component&apos;;import &#123;Code404Component&#125; from &apos;./code404/Code404.component&apos;;const routes: Routes = [ &#123; path: &apos;&apos;, 不能用／开头 component: HomeComponent &#125;, &#123; path: &apos;product&apos;, component: productComponent &#125; 处理不存在的路由 &#123; path: &apos;**&apos;, component: Code404Component &#125;] 1&lt;router-outlet&gt;&lt;//router-outlet&gt; 在哪显示组件 1234&lt;a [routerLink]=&quot;[&apos;/&apos;]&quot;&gt;主页&lt;/a&gt;&lt;a [routerLink]=&quot;[&apos;/product&apos;]&quot;&gt;产品页&lt;/a&gt;/: 根路由./: 子路由 10.3 通过router来导航1234567891011&lt;button (click) = &quot;toProduct()&quot;&gt;&lt;/button&gt; 事件绑定 ts文件中export class AppCOmponent &#123; constructor(private router: Router)&#123; &#125; toProduct()&#123; this.router.navigate([&apos;/product&apos;]); &#125; &#125; 10.4 在路由时传递参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960方式１：在查询参数中传递数据 /product?id=1&amp;name=2 获取参数： ActivatedRoute.queryParams[id] 使用方式如下: &lt;a [routerLink]=&quot;[&apos;./product&apos;]&quot; [queryParams]=&quot;&#123;id: 1&#125;&quot;&gt;商品详情&lt;/a&gt; 在商品详情组件中接收参数 .ts文件中 export class ProductComponet implements OnInit &#123; private productId:number; constructor(private routeInfo: ActivatedRoute)&#123; &#125; ngOnInit()&#123; this.productId = this.routeInfo.snapshot.queryParams[&quot;id&quot;]; &#125; &#125; 商品详情页 商品id是： &#123;&#123;productId&#125;&#125;方式２：在路由路径中传递数据 在查询参数中传递数据 &#123; path: /product/:id, component: ProductComponent &#125; 获取参数： ActivatedRoute.params[id] 使用步骤如下： 第一步： &#123; path: /product/:id, component: ProductComponent &#125; 第二步： &lt;a [routerLink]=&quot;[&apos;/product&apos;,1]&quot;&gt;商品详情&lt;/a&gt; 第三步： 在商品详情组件中接收参数 .ts文件中 export class ProductComponet implements OnInit &#123; private productId:number; constructor(private routeInfo: ActivatedRoute)&#123; &#125; ngOnInit()&#123; this.productId = this.routeInfo.snapshot.params[&quot;id&quot;]; 参数快照,跳转到同一个页面时，传递的参数导航栏的参数会变化，页面中的数据不变 或者使用参数订阅 this.routeInfo.params.subscribe((params: Params) =&gt; this.productId = params[&quot;id&quot;]); &#125; &#125; 商品详情页 商品id是： &#123;&#123;productId&#125;&#125;方式３：在路由配置中传递数据 &#123; path: /product, component: ProductComponent, data: [&#123;id:1&#125;] &#125; 获取参数： ActivatedRoute.data[0][id] 10.5 重定向路由1234567891011121314151617181920const routes: Routes = [ &#123; path: &apos;&apos;, 不能用／开头 redirectTo: &apos;/home&apos;, pathMatch: &apos;full&apos; &#125;, &#123; path: &apos;home&apos;, 不能用／开头 component: HomeComponent &#125;, &#123; path: &apos;product&apos;, component: productComponent &#125; 处理不存在的路由 &#123; path: &apos;**&apos;, component: Code404Component &#125;] 10.6 子路由12345678910111213141516171819202122232425262728const routes: Routes = [ &#123; path: &apos;&apos;, 不能用／开头 redirectTo: &apos;/home&apos;, pathMatch: &apos;full&apos; &#125;, &#123; path: &apos;home&apos;, 不能用／开头 component: HomeComponent, children: [ &#123; path: &apos;&apos;, 不能用／开头 component: DetailComponent, &#125; ] &#125;, &#123; path: &apos;product&apos;, component: productComponent &#125; 处理不存在的路由 &#123; path: &apos;**&apos;, component: Code404Component &#125;]&lt;a [routerLink]=&quot;[&apos;./&apos;]&quot;&gt;商品详情&lt;/a&gt; 跳转到当前路由的子路由 11. 作用域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677$scope: 局部作用域 只能在某一个控制器内使用 只有添加了控制器$scope才有局部作用域 $scope.$watch(&apos;监听的变量&apos;,function(newVal,oldVal)&#123; &#125;) $scope.$apply(): 监听数据的变化 在异步执行的方法中调用此方法才可以监听到数据的变化 案例: var mod = angular.module(&apos;&apos;,[]); mod.controller(&apos;&apos;,[&apos;$scope,$interval&apos;,function($scope,$interval)&#123; $interval(function()&#123; $scope.name = &apos;hellow&apos;; &#125;,2000); &#125;]); 如果不使用$interval的时候，在异步执行的方法中无法监听到数据的变化 var mod = angular.module(&apos;&apos;,[]); mod.controller(&apos;&apos;,[&apos;$scope&apos;,function($scope)&#123; $scope.name = &apos;zhangsan&apos;; setInterval(function()&#123; $scope.name = &apos;hellow&apos;; $scope.apply(); &#125;,2000); &#125;]); 在html中监听数据的变化还是zhangsan,需要在异步方法中添加$scope.apply();$rootScope: 全局作用域 在全页面可以使用ng-appng-controllerng-clickng-modelng-repeat:遍历$timeout$interval过滤器: 美元 currency: 默认是美元,3位分割 currency:&apos;￥&apos;侦听器: $watch 侦听器 $watch挂载在$scope下面,只能监听一个值得变化,不能监听一个对象;如果想要监听一个对象，设置第三个参数为true $scope.$watch(&apos;监听的变量&apos;,function(newVal,oldVal)&#123; console.log(&apos;改变了&apos;); $scope.money = newVal &gt; 10 ? 0 : 10; &#125;); 不仅可以监听字符串&apos;obj.name&apos;,也可以监听函数$scope.sum var mol = angular.module(&apos;模块名&apos;,[依赖的项]);mol.controller(&apos;控制器名&apos;,function($scope,$rootScope)&#123; //控制器 参数是依赖 &#125;); 压缩处理：写成数组的形式 mol.controller(&apos;控制器名&apos;,[&apos;$scope,$rootScope&apos;,function($scope,$rootScope)&#123; //控制器 参数是依赖 &#125;]);angular工具方法: angular.bind(); 改变this的执向 angular.bind(要指向的对象,函数,变量); angular.copy(); 拷贝对象 angular.copy(a,b); 将a拷贝给b,b原来的被覆盖 var c = angular.copy(a); c是拷贝的a angular.extend(); 对象继承 angular.extend(a,b); 把b的内容赋给a,a属性名一样的值覆盖，不一样的保留,相当于jquery中的extend(); angular.isElement(); console.log(angular.isElement(document.body)); true 可以是DOM元素也可以是jquery元素 console.log(angular.isElement($(document.body))); angular.equals([],[]); true NaN NaN true angular.forEach(数组|对象,function(val,index)&#123; 进行一系列操作 this指的是新的数组或者对象 this.push(......); &#125;,新的数组|对象); angular.fromJson|toJson() angular.toJson(json,true); 设置第二个参数为true,那么生成的字符串会有空格和换行问题:angular.identity|noop angular.lowercase|uppercase angular.element === $ 引入jquery即可 angular.element(DOM元素).css(&apos;&apos;,&apos;&apos;); 相当于jquery angular.bootstrap: 动态加载模块 angular.bootstrap(document,[&apos;model&apos;]); 跟写在ng-app中一样 动态加载模块可以加载多个,如果使用ng-app的话不可以使用多个 angular.bootatrap(dv1,[&apos;mod1&apos;]); angular.bootatrap(dv2,[&apos;mod2&apos;]);问题:angular.injector: 注射器 123456789angular.module controller: 创建控制器 var mo = angular.module(&apos;&apos;,[]); mo.controller(&apos;控制器的名字&apos;,function()&#123;&#125;); run: 相当于数据初始化 var mo = angular.module(&apos;&apos;,[]); mo.run([&apos;$rootScope&apos;],function($rootScope)&#123; $rootScope.name = &apos;hellow&apos;; &#125;); angular的过滤器 12345678910111213141516171819202122232425currency: 货币的过滤器 默认是美元,可以使用:&apos;&apos;来添加参数 如果有多个参数,可以在后面添加 : &apos;&apos; : &apos;&apos; :&apos;&apos;来传递参数 &#123;&#123;number | currency: &apos;￥&apos;&#125;&#125;number:数字过滤器 添加,号 如果有小数的情况下,默认会保留3为小数 添加: 数字,是设置保留几位小数点 &#123;&#123;number | number : 1 &#125;&#125;lowercase| uppercase: 转大小写 &#123;&#123;name | lowercase&#125;&#125;json: 将json对象转化为字符串,可以识别空格和换行 &#123;&#123;obj | json&#125;&#125;limitTo: 截取操作 传递参数是截取几位 可以是字符串也可以是数组 &#123;&#123;name | limitTo : 2&#125;&#125;date: 格式化时间 参数是: 日期格式 &#123;&#123;毫秒数 | date : &apos;&apos;&#125;&#125;orderBy: 排序 针对的是数组 添加一个参数默认是根据什么进行排序 如果需要逆排序,则需要添加第三个参数 为 true &#123;&#123;数组 | orderBy : &apos;根据什么进行排序&apos; ： true&#125;&#125;filter: 过滤器中过滤的一个方法 参数是: red ,只保留为red的数据 &#123;&#123;name : filter : &apos;red&apos;&#125;&#125; 可以匹配包含哪个字符, &#123;&#123;name : filter : &apos;re&apos;&#125;&#125; 也可以匹配整体, 比如匹配整体是 &apos;l&apos;的数据,则需要设置第二个参数为 true &#123;&#123;name : filter : &apos;red&apos; : true&#125;&#125; 如果不设置第二个参数,则主要包含哪个字符就可以 ng-repeat 12345678910111213141516angular.module(&apos;&apos;,[]).controller([&apos;$scope,$filter&apos;,function($scope,$filter)&#123; 排序功能 $scope.fnSort = function (arg)&#123; arguments.callee[&apos;fnSort&apos;+arg] = !arguments.callee[&apos;fnSort&apos;+arg]; $filter(&apos;过滤器的名字&apos;)(要操作的数据,根据什么进行操作); 如果要进行逆排序，需设置第三个参数为布尔值 $filter(&apos;orderBy&apos;)($scope.arr, arg,arguments.callee[&apos;fnSort&apos;+arg]); &#125; 搜索功能 $scope.fnFilter = function ()&#123; $scope.arr = $filter(&apos;filter&apos;)(要过滤的数据,根据什么过滤); $scope.arr = $filter(&apos;filter&apos;)(arr,$scope.val); &#125;&#125;]);点击进行排序&lt;li ng-repeat=&apos;item in arr&apos; ng-click=&apos;fnSort(item)&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; 12. 过滤器扩展及自定义过滤器123456789101112131415161718192021222324251.过滤器是可以组合使用的 &#123;&#123;name | limitTo : 2 | uppercase&#125;&#125;2.js中使用过滤器 $scope|$rootScope|$timeout|$interval|$filter $filter(&apos;过滤器的名字&apos;)(&apos;数据&apos;,参数); &lt;script&gt; var mod = angular.module(&apos;&apos;,[]); mod.controller(&apos;&apos;,[&apos;$scope&apos;,&apos;$rootScope&apos;,&apos;$filter&apos;,function($scope,$rootScope,$filter)&#123; $scope.name = $filter(&apos;limitTo&apos;)(&apos;hello&apos;,2); &#125;]); &lt;/script&gt;3.自定义过滤器 var mod = angular.module(&apos;&apos;,[]); mod.controller(&apos;&apos;,function()&#123;&#125;); mod.run([&apos;$scope&apos;,function($scope)&#123;&#125;]); 相当于初始化 mod.filter(&apos;过滤器名字&apos;,function()&#123; 内容 &#125;); 案例： mod.$filter(&apos;upcase&apos;,function()&#123; return function(str)&#123; return str.charAt(0).toUpperCase() + str.subString(1); &#125; &#125;); 13. ng-repeat指令扩展部分12345678910111213141516$index:数组的每项索引$first: 如果是第一项返回真,其余项返回假$last: 如果是最后一项返回真,其余项返回假$even: 奇数行返回真$odd: 偶数行返回真 隔行变色: &lt;li class=&quot;&#123;&#123;$even ? &apos;active1&apos; : &apos;active2&apos;&#125;&#125;&quot; ng-repeat=&quot;item in arr&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt;$middle: 中间项返回真,其余项返回假ng-repeat: ng-repeat=&quot;item in arr&quot;ng-repeat-start: 循环兄弟元素ng-repeat-end: &lt;div ng-repeat-start=&quot;item in arr&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;p&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;div ng-repeat-end&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; 14. 事件指令详解12345678910111213ng-click/dblclickng-mousedown/upng-mouseenter/leaveng-mousemove/over/outng-keydown/up/pressng-focus/blurng-submitng-selectedng-changeng-copyng-cutng-paste 15. input指令操作123456789101112131415ng-disabledng-readonlyng-checkedng-valueng-bind=&apos;text&apos;ng-cloak: 解析完成之前不显示表达式 &#123;&#123;text&#125;&#125; display: none;ng-bind-template=&quot;&#123;&#123;text&#125;&#125;,&#123;&#123;text&#125;&#125;&quot;ng-bind-html=&quot;text&quot; $scope.text=&quot;&lt;h1&gt;hello&lt;h1&gt;&quot;; 如果要显示出来需要插件 http://www.bootcdn.cn/angular.js/ 查找插件 https://cdn.bootcss.com/angular.js/1.3.0-beta.13/angular-sanitize.min.js 这个插件可以解析html 既是一个插件也是一个模块,所以需要引入 &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.3.0-beta.13/angular-sanitize.min.js&quot;&gt;&lt;/script&gt; var module = angular.module(&apos;myApp&apos;,[&apos;ngSanitize&apos;]); &lt;div ng-bind-html=&quot;text&quot;&gt;&lt;/div&gt;ng-non-bindable 16. 定时器服务12345678910$interval、$timeoutvar timer = $interval(function()&#123; num--; if(num == 0)&#123; 清理定时器 $interval.cancel(timer); $scope.text = &quot;可以点击了&quot;; $scope.isDisabled = false; &#125;&#125;,1000); 17. 样式相关指令详解1234567891011121314151617181920212223242526272829303132333435363738394041424344ng-class: &lt;div ng-class=&quot;&#123;red: true,yellow: false&#125;&quot;&gt;&lt;/div&gt;ng-style: 1.&lt;div ng-style=&quot;&#123;color: &apos;red&apos;,background: &apos;yellow&apos;&#125;&quot;&gt;&lt;/div&gt; 2.$scope.style = &#123;color: &apos;red&apos;,background: &apos;yellow&apos;&#125;; &lt;div ng-style=&quot;&#123;&#123;style&#125;&#125;&quot;&gt;&lt;/div&gt;ng-href: &lt;div ng-href=&quot;&#123;&#123;url&#125;&#125;&quot;&gt;&lt;/div&gt;ng-src: ng-attr-(suffix): &lt;div ng-attr-href=&quot;&#123;&#123;url&#125;&#125;&quot; ng-attr-title=&quot;&#123;&#123;title&#125;&#125;&quot;&gt;&lt;/div&gt;ng-show:ng-hide:ng-if:ng-switch: on default when 案例: &lt;div ng-switch on=&quot;要绑定的数据变量名&quot;&gt; &lt;p ng-switch-default&gt;默认的效果&lt;/p&gt; &lt;p ng-switch-when=&quot;false&quot;&gt;切换的效果&lt;/p&gt; &lt;/div&gt;ng-open:ng-init: 初始化数据ng-include: 引入页面 &lt;div ng-include=&quot;temp.html&quot;&gt;&lt;/div&gt;ng-model: 绑定数据 ng-model-options: updateOn: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot; ng-model-options=&quot;&#123;updateOn: &apos;blue&apos;&#125;&quot;&gt; 输入的时候数据不改变,只有失去焦点的时候页面的数据才改变ng-controllser: as: angular.module(&apos;&apos;,[]).controller(&apos;&apos;,[&quot;$scope&quot;,Fun]); function Fun()&#123; &#125; Fun.prototype.num = &apos;123&apos;; &lt;div controller=&quot;Fun as a1&quot;&gt; a1是构造函数创建出来的对象 &#123;&#123;a1.num&#125;&#125; &lt;/div&gt; 18. 标签指令123456标签指令写在控制器中: &lt;div ng-controller=&quot;&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 阻止a标签的默认行为 &lt;/div&gt; 如果不写在控制器中,会有默认的跳转行为 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 扩展12345678910angularJs在路由跳转时，如何让跳转的页面显示在最顶端参考官方文档： https://docs.angularjs.org/api/ng/service/$anchorScroll简书相关文档： http://www.jianshu.com/p/9cd7c2d2710f 如果我在A页面把页面下拉了，再点击跳转到B页面，页面的位置不是现实的最顶端（而是A页面的页面位置）。如何让页面每次跳转都把下一个页面的时候，都让页面显示在顶部： 使用 $anchorScroll 依赖： $window $location $rootScope $anchorScroll index.html 123456在ui-view 的div 中加入id&quot;view-pos&quot;&lt;body ng-controller=&quot;AppCtrl&quot;&gt; &lt;div ng-include=&quot;&apos;app/header.tpl.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-init=&quot;myInit()&quot; id=&quot;view-pos&quot; ui-view class=&quot;container-fluid&quot;&gt;&lt;/div&gt; 添加id编号 &lt;div ng-include=&quot;&apos;app/footer.tpl.html&apos;&quot;&gt;&lt;/div&gt;&lt;/body&gt; angular.js 12345678angular.module(&apos;authorization&apos;).controller(&apos;AuthController&apos;, [&apos;$location&apos;, &apos;$window&apos;, &apos;$rootScope&apos;,&apos;$anchorScroll&apos;, function ( $location, $window, $rootScope,$anchorScroll) &#123; $anchorScroll.yOffset = 30; // 总是滚动额外的30像素（此处是因为我的项目中样式设置原因，需要加上以offset） $location.hash(&apos;view-pos&apos;); $anchorScroll(); &#125;]);但测试发现设置了id之后跳转的页面url后面都会加上id &quot;#view-pos&quot;，于是修改index.html中id值为空，同时app.js中$location.hash(&apos;view-pos&apos;)中的id值也去掉（改为$location.hash(&apos;&apos;) 或者$location.hash()），这样跳转的url上就不会带上id. 12345678910111213大漠穷秋｜梅花清幽独立春寒参考项目: angular-phonecat-masterhttps://phonegap.com1.1小时快速上手2.搭建开发环境 Angular-cli webpack3.组件与指令 组件与指令 模板 数据绑定与事件绑定 组件间通讯 生命周期 动效 服务 管道4.模块与共享模块5.路由与动态加载 基本用法 多层嵌套 动态加载模块 路由守卫6.表单与数据校验 7.与服务端通讯 Observable与RxJS8.i18n9.前端自动化测试10.高阶内容 WebWorker、ServiceWorker、SEO与Universal、ionic、PWA angular2优质资源收集 1234567891011121314151617181920212223242526272829303132333435363738Angular2优质学习资源收集文档博客书籍类官方网站： https://angular.io中文站点： https://angular.cnVictor的blog（Victor是Angular路由模块的作者）： https://vsavkin.com/@vsavkinTodd Motto的Blog： https://toddmotto.com/ThoughtRAM上的Blog频道： https://blog.thoughtram.io/categories/angular-2/Angular University： http://blog.angular-university.io/Deborah&apos;s Developer MindScape： http://blogs.msmvps.com/deborahk/Jason Watmore&apos;s Blog： http://jasonwatmore.com/RxJS官方网站： http://reactivex.io/RxJS中文版文档（这是我看过的最好的关于RxJS的中文文档，注意，没有之一！向译者致敬！）： https://www.gitbook.com/book/buctwbzs/rxjs/details一本开源的Angular2书籍：https://zhangchen915.gitbooks.io/angular2-training/开源项目类Angular Angury项目： https://augury.angular.io/Angular Team在github上的地址： https://github.com/angularng2-bootstrap： https://ng-bootstrap.github.io/#/homeNGPrime： http://www.primefaces.org/primeng/#/Angular-Material2： https://github.com/angular/material2KendoUI：http://www.telerik.com/blogs/what-to-expect-in-2016-for-kendo-ui-with-angular-2-and-moreionic： https://ionic.io/一个非常好的管理后台项目（那些拿Angular来做管理系统的朋友，请务必看这个项目，它是非常好的后台管理界面模板，而且是开源免费的）： https://github.com/akveo/ng2-admin一个很好的Blog项目： https://github.com/WittBulter/sails-blog-frontendRxJS聊天室： https://github.com/ng-book/angular2-rxjs-chat教学用的项目NiceFish： http://git.oschina.net/mumu-osc/NiceFishGitHub上搜索Angular相关资源的更好方法：https://github.com/search?utf8=%E2%9C%93&amp;q=topic%3Aangular&amp;type=Repositories&amp;ref=searchresults一组Angular2应用收集：http://angularexpo.com/一组UI库：https://teradata.github.io/covalent/#/视频类一个非常好的RxJS教学视频（想快速学会RxJS的朋友请务必仔细看完这个视频）： https://coryrylan.com/blog/introduction-to-rxjs-observables-and-angular关于RxJS的更多视频（RxJS官方出的）： https://egghead.io/lessons/rxjs-rxjs-observables-vs-promises油管上的AngularConnect频道： https://www.youtube.com/channel/UCzrskTiT_ObAk3xBkVxMz5g油管上的ng-conf频道： https://www.youtube.com/user/ngconfvideos参考链接： https://www.cnblogs.com/xiaobai110/p/6416484.html https://blog.csdn.net/u010781856/article/details/72862736]]></content>
  </entry>
  <entry>
    <title><![CDATA[进阶知识]]></title>
    <url>%2Fsongfang0%2F2019%2F07%2F20%2F%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[进阶一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 1.js中typeof和instanceof函数作用及区别 typeof: 判断一个变量的类型会用 typeof 运算符,如果判断引用类型的话返回的都是object,不能返回具体是哪种引用类型 instanceof: 可以判断引用类型是哪种具体类型 Object.prototype.toString.call(Array)2.请问什么叫闭包? 闭包就是能够读取其他函数内部变量的函数 优点: 避免全局变量被污染,能访问函数内部的变量 缺点: 变量使用过后不能及时的被销毁，浪费内存空间3.简述src和href区别 src用于替换当前元素，href用于在当前文档和引用资源之间确立联系,指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内,当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕 href 是指向网络资源所在位置，建立和当前元素（锚点）,或当前文档（链接）之间的链接，用于超链接4.简述ajax的工作原理和优缺点 优点: 不刷新更新数据、异步交互 缺点： AJAX干掉了Back和History功能，即对浏览器机制的破坏5. 简述sessionStorage、localStorage和cookie的区别 1)cookie保存在浏览器端，session保存在服务器端 cookie不设置过期时 间保存在内存中，设置了过期时间保存在硬盘 cookie:只能保存字符串类型的数据 存储大小不能超过4k,sesson没有限制 cookie安全性不高 cookie会随着数据发送到服务器端 2)sessionStorage，关闭浏览器就失效,仅在当前页面有效 localStorage:保存在本地，永久有效，除非用户自动删除，在同源窗口都是有效的 都保存在客户端，不与服务器进行交互 只能存储字符串类型6.请问什么是跨域?跨域请求资源的方法有哪些? 协议、IP地址、端口有一个不相同则为跨域。 跨域解决方法: jsonp、cors、服务器反向代理7.如何减低页面加载时间 减少重复的http请求、http缓存、为内容指定Expires或Cache-Control,使内容具有缓存行。 把css放到顶部,把js放到底部 使用CDN 精灵图 事件委托 减少DOM操作 服务器启用gzip压缩功能 图片懒加载 压缩js、css文件 预加载 减少cookie个数8.常见的web攻击技术有哪些?前端需要如何处理9.清除浮动有哪几种方法 1)给父元素增加: overflow:hidden; 2)在最后一个浮动元素后面添加 &lt;div style=&apos;clear:both&apos;&gt;&lt;/div&gt; 3)伪元素清除浮动 .clearfix::after &#123; content: &quot;&quot;; display:block; height: 0; line-height: 0; visibility: hidden; clear: both; &#125;10.如何使一个元素垂直水平居中,如果是一个不定宽的元素如何实现呢? 1)定位 .son &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; 2)flex布局 .parent &#123; display: flex; justify-content: center; align-items: center; &#125;11.ES6中箭头函数于普通函数有哪些异同? this指向不同,箭头函数this指向上一级的this 普通函数： window 谁调用是谁 进阶二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 1.删除字符串中&quot;aabbccdd&quot;中所有的&quot;b&quot; var str = &quot;aabbccdd&quot;; str.replace(/b+/g,&apos;&apos;); 用正则匹配所有b，用空字符串代替 // 2.实现一个将字符串反转的函数,如&quot;ABCD&quot;得出&quot;DCBA&quot; var str = &apos;ABCD&apos;; function reverse(str)&#123; var arr = str.split(&apos;&apos;); //将字符串分割成数组 arr = arr.reverse(); //数组翻转 return arr.join(&apos;&apos;); // 将数组拼接成字符 &#125; console.log(reverse(str)); //3.用js从cookie中读取一个键为userid的cookie值 document.cookie =&quot;name=zhangsan&amp;pass=123;expires=&quot;+new Date(); console.log(document.cookie); // 4.实现一个log函数,与console.log具有相同的特性,但每条输出都带有前缀,使用工厂模式创建出带有不同前缀的log函数 // 5.列举js中几种变量类型,如何判断一个数组 instanceof： arr instanceof Array arr.constructor === &apos;Array&apos; Object.prototype.toString.call(o) === &apos;[object Array]&apos; Array.isArray(arr) // 6.事件委托 var box = document.getElementsByClassName(&apos;box&apos;)[0]; var child = document.getElementsByClassName(&apos;child&apos;)[0]; box.onclick = function(e)&#123; if(e.target.nodeName == &apos;DIV&apos;)&#123; e.target.style.backgroundColor = &apos;red&apos;; &#125; &#125; //7.排序 [1,5,8,0,-2] var arr = [1,5,8,0,-2]; for(var i = 0; i &lt; arr.length-1; i++)&#123; for(var j = 0; j &lt; arr.length-1-i; j++)&#123; if(arr[j+1] &lt; arr[j])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; console.log(arr); //8.js实现继承 原型继承 Child.protorype = new Parent(); 改变this的指向 通过call(),apply(),bind()来改变this的指向 组合继承 //9.实现3列布局,中间一列自适应宽度 双飞翼、圣杯布局 伸缩布局 //10. ajax请求时,如何解释json数据 JSON.parse(xhr.responseText); //转化成对象 //11.js去除字符串空格 var str = &apos; abbcc sdfa &apos;; console.log(str); str = str.replace(/\s+/g,&apos;&apos;); console.log(str); //12.浏览器缓存有哪些? 通常缓存有哪几种以及他们的区别是什么 协商缓存和强缓存 强缓存: expires： 设置过期时间 cache-control 协商缓存： //13.jquery的事件委托bind、live、delegate、on之间有什么区别 bind新添加的元素没有事件 delegate、on新添加的元素也有事件,事件委托 //14.$(document).ready()方法和window.onload有什么区别) 一个可以注册多次,一个只可以注册一次; 一个加载速度慢,一个加载速度快 进阶三1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092101. for(var i =0; i &lt; 5; i++)&#123; var a = 1; setTimeout(function()&#123; console.log(i); // 5 个5 &#125;,0); &#125; (function()&#123; console.log(a); //1 console.log(b); //undefined b = &quot;b&quot;; console.log(b); // b a = 2; console.log(a); // 2 var b; &#125;)(); console.log(a); // 22. var arr = [0,1,2,3,4,5,6,7,8,9]; for(var i = 0; i &lt; arr.length; i++)&#123; if(i%2 == 0)&#123; arr.splice(i,1); &#125; &#125; alert(arr); //1 2 4 5 7 83. function fun()&#123; for(var i = 0; 4&gt;i;i++)&#123; var k = 100; str += &apos;,&apos;+(k+i); &#125; &#125; var k = 1, str = k; fun(); str += k; console.log(str); //1,100,101,102,10314.//str = &quot;b ook ,de sk, pag,bag,a ni moa,food, pag, page,desk,bag,animoa&quot; 转化为数组的形式输出,要求: 去除重复单词 去除单词两端空格 单词排序var str = &quot;b ook ,de sk, pag,bag,a ni moa,food, pag, page,desk,bag,animoa&quot;;var arr = str.split(&apos;,&apos;);console.log(arr);var newArr = [];arr.map(function(item)&#123; item = item.replace(/\s+/g, &apos;&apos;); return newArr.push(item);&#125;);// console.log(newArr);arr = new Set(arr);console.log(arr);5.[1,2,3,4,5].changes(); [1,2,3,4,5,1,2,3,4,5] ？？？？？？？？？？？6.在事件中e.target和e.currentTarget有什么区别 e.target是当前点击的目标元素 e.currentTarget是父元素7.function foo()&#123; 执行顺序 try &#123; return 0; console.log(&quot;b&quot;); &#125;catch(err)&#123; &#125;finally&#123; console.log(&quot;a&quot;); &#125; &#125;console.log(foo()); // a 0try &#123; //执行的代码，其中可能有异常。一旦发现异常，则立即跳到catch执行。否则不会执行catch里面的内容 &#125;catch &#123; //除非try里面执行代码发生了异常，否则这里的代码不会执行 &#125;finally &#123; //不管什么情况都会执行，包括try catch 里面用了return ,可以理解为只要执行了try或者catch，就一定会执行 finally,先执行finally,再执行return&#125;8.var r = new Promise(function(resolve,reject)&#123; console.log(&quot;a&quot;); resolve();&#125;)setTimeout( () =&gt; console.log(&apos;d&apos;),0);r.then(() =&gt; console.log(&quot;c&quot;));console.log(&quot;b&quot;); // a b c d9.var a = 5; var b = 10; if(a == 5.0)&#123; let a = 4; var b = 1; console.log(a); // 4 console.log(b); // 1 &#125; console.log(a); // 5 console.log(b); // 110.vue生命周期 beforeCreate()、created()、beforeMount()、mounted()、beforeUpdate()、updated()、beforeDestory()、destoried()11.如何实现一个promise,promise的原理,以及他的两个参数是什么 resolve()、reject() 成功之后的回调,失败之后的回调12.vue中父子组件如何通信的 子组件: props: []13.如何理解vue中的MVVM// 创建对象有几种方法 4种 1) var obj = new Object(); obj.name = &apos;张三&apos;; 2) var obj = &#123;&#125;; 3) 构造函数 function Student()&#123; &#125; 4)工厂函数 14.简述常见的web攻击XSS和CSRF的原理15.&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么 keep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗 &lt;keep-alive&gt; &lt;router-view v-if=&apos;$route.meta.keepAlive&apos;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&apos;!$route.meta.keepAlive&apos;&gt;&lt;/router-view&gt; index.js &#123; path: &apos;/home&apos;, component: Home, meta: &#123; keepAlive: true &#125; &#125;16.active-class是哪个组件的属性 vue-router模块的router-link组件 1.怎么定义vue-router的动态路由？怎么获取传过来的动态参数 在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id 2.vue-router有哪几种导航钩子 三种，一种是全局导航钩子：router.beforeEach(to,from,next)， router.afterEach() 作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件 3.scss是什么？安装使用的步骤是？有哪几大特性？ 预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-loader、sass-loader等加载器模块， 在webpack-base.config.js配置文件中加多一个拓展:extenstion， 再加多一个模块：module里面test、loader 步骤： css的预编译。 使用步骤： 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass） 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss 第三步：还是在同一个文件，配置一个module属性 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss” 有哪几大特性: 1、可以用变量，例如（$变量名称=值）； 2、可以用混合器，例如（） 3、可以嵌套 4.axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？ ?????不懂 跨域，添加用户操作，更新操作。 5.什么是RESTful API？怎么使用? 是一个api的标准，无状态请求。请求的路由地址是固定的， 如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete 6.mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？ 一个model+view+viewModel框架，数据模型model，viewModel连接两个 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷 7.vue如何实现数据的双向绑定 8.Vuerouter跳转和location.href有什么区别 9.写一个简单的$.ajax()的请求方式 $.ajax(&#123; type: &apos;&apos;, url: &apos;&apos;, data: &#123; &#125;, success: function()&#123; &#125; &#125;); 10.viewport、rem、媒体查询、使用百分比 11.写出http状态码200 301 302 304 404 500 的含义 200: 成功 301: 302: 304: 404:请求失败 500:服务器错误 12.h5新增语义标签有哪些? 如何处理h5新标签的浏览器兼容问题 加前缀 13.浏览器的内核分别是什么 14.cors访问控制原理 15.采用何种工具发现代码的性能问题 16.Layout、paint、Composite的不同之处 17.深拷贝 18.new操作符调用构造函数会经历哪些过程 19.什么是构造函数,与普通函数有什么区别 20.有哪些节点类型,如何判断当前节点类型 21.如何合并两个数组,数组删除一个元素 22.jquery中如何实现多库并存 23.jq中get和eq有什么区别 24.[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt) 答案是什么 25.var foo = &#123;n:1&#125;; // var bar = foo; // foo.x = foo = &#123;n:2&#125;; // console.log(foo.x); undefined 26.var length = 10; // function fn()&#123; // console.log(this.length); // &#125; // var obj = &#123; // length: 5, // methods(fn)&#123; // fn(); // console.log(arguments[0]); // arguments0; // &#125; // &#125; // obj.methods(fn); 10 1 // 27.问题=========================================== // function Foo()&#123; // getName = function()&#123;console.log(1)&#125;; // return this; // &#125; // Foo.getName = function()&#123; // console.log(2); // &#125; // Foo.prototype.getName = function () &#123; console.log(3) &#125; // var getName = function()&#123;console.log(4)&#125; // function getName()&#123;console.log(5)&#125; // Foo.getName(); // getName(); // Foo().getName(); // getName(); // new Foo.getName(); // new Foo().getName(); 进阶四12345678910111213141516171819202122232425262728293031323334353637383940411.var a = 1; function test()&#123; console.log(a); //undefined var a = 2; console.log(this.a); //1 setTimeout(function()&#123; console.log(a); // 3 &#125;,0); return function()&#123; console.log(a); //2 a = 3; console.log(this.a); // 1 &#125; &#125; test()(); 2.Object.assign()函数的作用及用法 3.什么情况是跨域?如何解决跨域问题 4.什么是MVVM?MVVM和MVC区别 5.组件之间的传值 6.vuex是什么?怎么使用?文档总结 进阶五1234567891011121314151617181920212223242526272829条件与循环： v-if bool值：插入/移除元素 v-for:循环 事件处理函数： v-on:事件名.属性 = &apos;&apos; v-on: 可以简写为@ v-model:实现表单输入与应用状态之间的双向绑定 组件: component(&apos;组件名&apos;,&#123;选项&#125;) 侦听器 watch watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.debouncedGetAnswer() &#125; &#125; v-once:v-once:一次性的插值 计算属性 computed:&#123;名：函数&#125; 计算属性是基于它们的依赖进行缓存的 v-bind:class: 数组/对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331reverse():数组翻转 join(); 数组用什么拼接成字符串 一、什么是MVVM？ MVVM是Model-View-ViewModel的缩写。 MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑； View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互， Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中， 而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层 连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉， 因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题， 复杂的数据状态维护完全由 MVVM 来统一管理。 二、mvvm和mvc区别？ 它和其它框架（jquery）的区别是什么？哪些场景适合？ mvc和mvvm其实区别并不大。 都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。 mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷 三、vue的优点是什么？ 低耦合。 视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上， 当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。 你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 四、 组件之间的传值？ 父组件与子组件传值父组件通过标签上面定义传值子组件通过props方法接受数据 子组件向父组件传递数据 子组件通过$emit方法传递参数 五、路由之间跳转 声明式（标签跳转） 编程式（ js跳转） 六、vue.cli中怎样使用自定义的组件？ 有遇到过哪些问题吗？ 第一步：在components目录新建你的组件文件（indexPage.vue），script一定要export default &#123;&#125; 第二步：在需要用的页面（组件）中导入：import indexPage from &apos;@/components/indexPage.vue&apos; 第三步：注入到vue的子组件的components属性上面,components:&#123;indexPage&#125; 第四步：在template视图view中使用，例如有indexPage命名，使用的时候则index-page 七、vue如何实现按需加载配合webpack设置 -webpack中提供了require.ensure()来实现按需加载。 以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。 不进行页面按需加载引入方式：import home from &apos;../../common/home.vue&apos; 进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(&apos;../../common/home.vue&apos;))) 八、vuex面试相关 （1）vuex是什么？怎么使用？哪种功能场景使用它？ vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。 场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车（2）vuex有哪几种属性？ 有五种， 分别是 State、 Getter、Mutation 、Action、 Module vuex的State特性A、Vuex就是一个仓库， 仓库里面放了很多对象。其中state就是数据源存放地， 对应于一般Vue对象里面的dataB、state里面存放的数据是响应式的， Vue组件从store中读取数据，若是store中的数据发生改变， 依赖这个数据的组件也会发生更新C、它通过mapState把全局的 state 和 getters 映射 到当前组件的 computed 计算属性中 vuex的Getter特性A、getters 可以对State进行计算操作， 它就是Store的计算属性B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用C、 如果一个状态只在一个组件内使用，是可以不用getters vuex的Mutation特性Action 类似于 mutation， 不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。（3）不用Vuex会带来什么问题？ 可维护性会下降，想修改数据要维护三个地方； 可读性会下降， 因为一个组件里的数据，根本就看不出来是从哪来的； 增加耦合，大量的上传派发， 会让耦合性大大增加， 本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。 九、 v-show和v-if指令的共同点和不同点 v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏 v-if指令是直接销毁和 重建DOM达到让元素显示和隐藏的效果 十、 如何让CSS只在当前组件中起作用 将当前组件的&lt;style&gt;修改为&lt;style scoped&gt; 十一、的作用是什么? 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。 十二、Vue中引入组件的步骤? 1） 采用ES6的import … from …语法或CommonJS的require()方法引入组件2） 对组件进行注册, 代码如下 // 注册Vue.component(&apos;my-component&apos;, &#123;template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;) 3）使用组件&lt;my-component&gt;&lt;/my-component&gt; 十三、指令v-el的作用是什么? 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标. 可以是 CSS 选择器，也可以是一个 HTMLElement 实例十四、在Vue中使用插件的步骤 采用ES6的import … from …语法或CommonJSd的require()方法引入插件 使用 全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, &#123; someOption: true &#125;) 十五、请列举出3个Vue中常用的生命周期钩子函数 created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始,el 替换， 并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素， 当 mounted 被调用时 vm.$el 也在文档内。 activated: keep-alive组件激活时调用 十六、active-class是哪个组件的属性？ vue-router模块的router-link组件。 十七、怎么定义vue-router的动态路由以及如何获取传过来的动态参数？ 在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id。 十八、vue-router有哪几种导航钩子？ 一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。 第二种：组件内的钩子； 第三种：单独路由独享组件十九、生命周期相关面试题 总共分为8个阶段 创建前/后，载入前/后， 更新前/后，销毁前/后。 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined 还未初始化。在created阶段，vue实例的数据对象data有了，el还没有 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了， 但还是挂载之前为虚拟的dom节点，data.message还未替换。 在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数， 说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 （1）、什么是vue生命周期 答： Vue 实例从创建到销毁的过程，就是生命周期。 也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、 更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。（2）、vue生命周期的作用是什么 答：它的生命周期中有多个事件钩子， 让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 （3）、vue生命周期总共有几个阶段 答： 可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后（4）、第一次页面加载会触发哪几个钩子 答： 第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子（5）、DOM 渲染在 哪个周期中就已经完成 答：DOM 渲染在 mounted 中就已经完成了。 （6）、简单描述每个周期具体适合哪些场景 答： 生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件， 在加载实例时触发 created : 初始化完成时的事件写在这里， 如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素， 获取到DOM节点 updated : 如果对数据统一处理， 在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom二十、说出至少4种vue当中的指令和它的用法？v-if：判断是否隐藏； v-for：数据循环； v-bind:class：绑定一个属性； v-model：实现双向绑定 二十一、 vue-loader是什么？使用它的用途有哪些？ 解析.vue文件的一个加载器。 用途：js可以写es6、style样式可以scss或less、template可以加jade等二十二、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？答：css的预编译。 使用步骤：第一步：先装css-loader、node-loader、sass-loader等加载器模块 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss 第三步：在同一个文件，配置一个module属性 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss” 特性: 可以用变量，例如（$变量名称=值）； 可以用混合器，例如（） 可以嵌套二十三、为什么使用key？ 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们 ，否则 Vue 为了效率只会替换相同标签内部的内容。 二十四、为什么避免 v-if 和 v-for 用在一起 当 Vue 处理指令时， v-for 比 v-if 具有更高的优先级，通过v-if 移动到容器元素， 不会再重复遍历列表中的每个值。取而代之的是， 我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。 二十五、VNode是什么？虚拟 DOM是什么？ Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”， 简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。26.拖拽事件 12345678910111213141516171819202122231.盒子模型（box-sizing）2.弹性布局(flex 主轴侧轴)3.bom和dom, bom中的对象4.前后端跨域，怎么设置5.Jsonp原理，怎么设置6.Webstorage(localstorage中存储的内容例如昵称修改了，怎么做到的pc端会修改)7.Vue父子组件传值怎么设置的8.计算属性和侦听器用法区别9.截取url中参数以对象形式保存(手写代码)10.平时项目有多少个js文件11.Js中模块化（commonjs,requirejs）12.requirejs中define与require详解13.requirejs中的配置项，怎么用的14.Es6中使用了哪些15.let和const 的区别16.箭头函数与普通函数区别17.异步请求用的ajax还是async await18.Promise函数的状态19.P2=p1.then(return )此时p2的状态20.怎么让一大堆promise函数每5个一批执行21.jquery中的选择器22.git的指令（git log git reset）23.把数组中出现的元素统计出每一个次数（手写代码） 进阶六123456789101112131415161718192021222324252627284.学过什么新的主流框架5.介绍一下vue，有什么特性，优点6.Vue本身具备什么能力，框架怎么分层的7.vue是怎么高效的运行的，有性能瓶颈吗，怎么性能优化8.分析加载慢的原因，怎么解决9.怎么发现问题所在的10.性能优化11.讲一下从网络发起到上屏浏览器经过了哪些处理12.Js怎么执行13.js一般怎么工作的，怎么解析的js脚本14.js内存环境怎么做的15.H5有哪些新特性16.js怎么实现异步17.vue框架的异步策略18.为什么要用异步19.异步底层怎么实现的20.跨域的安全问题21.在实现过程中怎么做终端的适配的（安卓和ios,以及各种浏览器屏幕）22.做适配要遵循什么样的原则（手机端适配）23.Zepto本身是怎么实现的，一种轻量化的24.谈谈jquery内存中怎么管理25.Jquery有模板吗26.平时使用jquery过程中有什么问题27.模板渲染引擎有用过哪些28.为什么用art-template,有其他类似的模板吗29.之前工作最大收获是什么30.有一段字符串，统计一下联系三个字符后面的要比前面的大（例如abc,acd）的时间复杂度和空间复杂度31.操作系统有了解过吗 进阶七1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162vue的作用 什么是vue vue的钩子函数 vue的生命周期 vuex是什么 腾讯面试题： 1.介绍项目 2.XMLHttpRequest 3.Http状态码 4.Cache-control 5.CSS动画原理 面试： 1.圣杯布局 2.ie的某些兼容性 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或者margin-right，margin值会加倍。这种情况下IE会产生20px的距离，解决方案是在float的标签样式控制中加入display：inline;将其转化为行内属性，，只有IE会识别） 项目： 1.跨域 2.javascript数据类型 3.页面加载 4.字符串转化 5.jsonp原理 6.css合并方法 7.盒子模型 8.定位4，可以使用localStroage 5.function unique2(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i])==i)&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 8.父子通讯中最常见的数据传递方式就是通过props传递数据，就好像方法的传参一样，父组件调用子组件并传入数据， 9，默认时间是浏览器关闭就过期 1.re.exec(str) 2.分别是jsonp callback handler」 3.如何解决cookie安全性问题 1)设置cookie有效期不要过长,合适即可 2)设置HttpOnly属性为true:可以防止js脚本读取cookie信息,有效的防止XSS攻击 3)设置复杂的cookie，加密cookie ①cookie的key使用uuid，随机生成 ②cookie的value可以使用复杂组合，比如:用户名+当前时间+cookie有效时间+随机数 4)对保存到cookie里面的敏感信息必须加密 5)用户第一次登录时,保存IP+cookie加密后的token 每次请求,都去将当前cookie和ip组合起来加密后的tokenn与保存的token作对比,只有全对应才能验证成功。 4.vue和react的区别 相同点:①都支持服务器渲染②都有虚拟DOM,组件化开发，通过props参数进行父子组件数据的传递,都实现webComponent规范③数据驱动试图④都支持native的方案,React的React native，Vue的weex⑤都有管理状态,React有redux,Vue有自己的Vuex(自适应vue)⑥提供了响应式Reactive和组件化Composable的视图组件⑦将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。 5.如何实现浏览器内多个标签页之间的通信？ 6.编写一个方法,去掉一个var datas=[1,3,4,4,5,3,2,1]的重复元素 7.怎么理解MVVM模式这些框架 8.vue中父子组件如何通信并阐述以下vue的生命周期 9.cookie不设置过期时间，默认过期时间是多少？如何保证cookie的安全？ 10.描述对MVVM、MVC设计模式的认识 11.JS哪些操作会造成内存泄漏 12.浏览器缓存有哪些，通常缓存有哪几种 13.http和https有何区别?如何灵活使用? 14.react和vue有哪些相同点和不同点，说说你对这两个框架的看法 15.xml和json的区别,请用四个词语来形容 16.解释css sprites,如何使用 17.一个200*200的div在不同分辨率屏幕上下左右居中，用css实现 12ng-show/ng-hide与ng-if的区别 解释下什么是rootScrope以及scope的区别 常见的web攻击技术有哪些?前端需要如何处理 1234567891011121314151、xss跨站攻击技术：主要是攻击者往网页里嵌入恶意脚本，或者通过改变html元素属性来实现攻击，主要原因在于开发者对用户的变量直接使用导致进入html中会被直接编译成js，通常的get请求通过url来传参，可以在url中传入恶意脚本，从而获取信息，解决方法：特殊字符过滤。2、sql注入攻击：主要是就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，比如select * from test where username=&quot;wuxu&quot; or 1=1，这样会使用户跳过密码直接登录，具体解决方案：1、特殊字符过滤，不要用拼接字符串的方法来凑sql语句。2、对sql语句进行预编译，比如java的preparedstatement。3、关闭错误信息，攻击者可能会通过不断的尝试来得到数据库的一些信息，所以关闭错误信息变得重要起来。4、客户端对数据进行加密，使原来传进来的参数因为加密而被过滤掉。5、控制数据库的权限，比如只能select，不能insert，防止攻击者通过select * from test ；drop tables这种操作3、os命令注入攻击：系统提供命令执行类函数主要方便处理相关应用场景的功能.而当不合理的使用这类函数，同时调用的变量未考虑安全因素，就会执行恶意的命令调用，被攻击利用。主要原因是服务端在调用系统命令时采用的是字符串连接的方式，比如a=&quot;a.txt;rm -rf *&quot;,system(&quot;rm -rf &#123;$a&#125;&quot;)，这会给服务端带去惨痛的代价，具体解决方案：1、在程序开发时少用系统命令，执行命令的参数尽量不要从外部获取。2、参数特殊字符过滤5、邮件首部注入攻击：它允许恶意攻击者注入任何邮件头字段,BCC、CC、主题等,它允许黑客通过注入手段从受害者的邮件服务器发送垃圾邮件。主要是利用邮件系统传参的bug来进行攻击，解决方法：1、使用正则表达式来过滤用用户提交的数据。例如,我们可以在输入字符串中搜索(r 或 n)。2、永远不要信任用户的输入。3、使用外部组建和库6、目录遍历攻击：目录遍历是Http所存在的一个安全漏洞，它使得攻击者能够访问受限制的目录，并在Web服务器的根目录以外执行命令。比如 http://test.webarticles.com/show.asp?view=../../../../../Windows/system.ini，这种url会返回／windows／system.ini给用户，所以服务器上的重要文件就会遭到泄漏，解决方法：根目录访问，现在主流服务器，比如nginx，都会有www根目录，是网站的根目录，所以用户只能访问该根目录下的文件，不能访问其他目录下的文件，从而实现了权限控制。而目录遍历并不是一个漏洞，而是服务器的一个功能，而因为管理员的疏忽从而变成了漏洞7、远程目录包含攻击，原理就是注入一段用户能控制的脚本或代码，并让服务端执行。比如php中的include($filename)，而此filename由用户传入，用户即可传入一段恶意脚本，从而对服务其造成伤害，解决方法：当采用文件包含函数的时候，不应动态传入，而应该有具体的文件名，如果动态传入，要保证动态变量不被用户所控制8、会话劫持：这是一种通过获取用户Session ID后，使用该Session ID登录目标账号的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。会话劫持的第一步是取得一个合法的会话标识来伪装成合法用户，因此需要保证会话标识不被泄漏，通俗一点就是用户在登录时，唯一标示用户身份的session id被劫持，使得攻击者可以用这个session id来进行登录后操作，而攻击者主要是通过 窃取：使用网络嗅探，XSS攻击等方法获得。而第一种方式网络嗅探，我们可以通过ssl加密，也就是https来对报文进行加密，从而防止报文被截获，而第二种方式xss攻击，方式在第一种已经给出，不再赘述。此外通过设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击，还有就是设置token验证。关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。9、会话固定：会话固定是会话劫持的一种，区别就是，会话固定是攻击者通过某种手段重置目标用户的SessionID，然后监听用户会话状态；用户携带sessionid进行登录，攻击者获取sessionid来进行会话，解决方案：服务端设置用户登录后的sessionid与登录前不一样即可，另外会话劫持的方法也可以用在会话固定上10、csrf跨站伪造请求攻击：其实就是攻击者盗用了你的身份，以你的名义发送恶意请求。具体原理比较复杂，参考www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html这篇博文，具体方案：1、验证referer字段，这个字段主要是反映了访问某个网页只能有referer发起请求，所以通过referer验证，可以抵御一部分csrf攻击。2、在请求地址中加token验证，攻击者发送恶意请求时，通过token验证来进行身份验证，而token必须是一个攻击者猜不到的，很难去模拟出来的，具体来说可以放在表单的hidden字段中。3、在htttp请求头中定义字段，其实就是将2中说得token字段放入请求头，解决了每次在请求头中加入token的不便，同时在其也不会记录在地址栏里，降低了token泄露的风险 进阶八1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331.什么是盒模型,W3C盒模型与IE盒模型的区别有哪些？ box-sizing: border-box|content-box;2.js的函数参数是值传递还是地址传递？请阐述原因 值传递3.清除浮动的方法 ①父元素添加 overflow:hidden; 原理是BFC ②最后浮动元素后面添加 &lt;div style=&apos;clear:both&apos;&gt;&lt;/div&gt; ③双伪元素清除浮动 .clearfix::after&#123; content: &apos;&apos;, height: 0; line-height: 0; display: block; visibility: hidden; clear: both; &#125; .clearfix &#123; *zoom: 1; &#125;4.vue如何实现父子组件通信，以及非父子组件通信以及vue生命周期父子组件: 子组件 props: []子父组件: this.$emit(&apos;自定义函数&apos;,data);兄弟组件: 中央事件总线 共用一个vue实例 A：Vue.$emit(&apos;自定义函数&apos;,data); B：Vue.$on(&apos;自定义函数名&apos;,函数); vm.$emit(&apos;com&apos;,this.num); vm.$on(&apos;com&apos;,(num) =&gt; &#123; console.log(num); &#125;);5.前端跨域的解决方式 jsonp：script属性 服务器代理 反向代理 cors:6.闭包及优缺点 闭包: 能够读取其他函数内部的变量 优缺点: 避免全局变量被污染，不能及时释放变量的作用域5.对数组[46,54,2,67,62,43,47,58,17,33]进行冒泡的升序排序 function(arr)&#123; for(var i = 0; i &lt; arr.length-1; i++)&#123; for(var j = 0; j &lt; arr.length-1; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;6.写出以下代码在控制台的打印 new Promise(function executor(resolve)&#123; console.log(1); for(var i = 0; i &lt; 1000; i++)&#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2); &#125;).then(function()&#123; setTimeout(function()&#123; cnsole.log(3); &#125;,10); console.log(4); &#125;); setTimeout(function()&#123; console.log(5); &#125;,0); console.log(6); 1 2 6 5 7.cookieStorage和sessionStorage的区别 cookie: 保存在客户端，大小4k 设置过期时间保存在硬盘，没设置过期时间保存在内存中，没设置过期时间关闭浏览器就失效 存储类型是字符串 session: 保存在服务器，大小没有限制,安全性比cookie高 存储类型是对象 sessionStorage:关闭浏览器就失效，保存在客户端，仅在同一个标签页中有效 localStorage: 保存在本地,永久存储，永不失效，除非自己删除，保存在客户端，作用在同源窗口8.如何用原生js给一个按钮注册两个onclick事件 addEventListener attachEvent 元素.addEventListener(&apos;不带on的事件名&apos;,fn,false); 谷歌、火狐支持 元素.attachEvent(&apos;带on的事件名&apos;,fn); IE8支持9.有哪些性能优化的方法 减少http请求、精灵图、css代码压缩、减少DOM操作、少用全局变量、异步加载、浏览器缓存、图片懒加载 （1）减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamicproperties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。10.js原型、原型链的认识 获取当前对象的属性或者方法,先在当前属性下面找,如果找不到去原型对象上面找,一直往上找，直到null，如果到null一直找不到,属性返回undefined,方法报错。11.ES6常用新特性 模板字符串 let const 解构赋值 数组方法: new Set()去重 map findIndex() 箭头函数(this问题) Promise12.编写一个function将location.search转化为对象的形式&#123;&#125; location.search是url中?号及?号之后的内容 ?q=for%E5&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=for%E5%BED%A5de%27ma&amp;sc=0-13&amp;sk=&amp;cvid=043448F 先截取?号,之后将后面的内容根据&amp;符号分割为数组,将数组中每一项根据=号,分割为数组13.js引入的方式有哪些?link和@import的区别是?14.module.exports和exports区别 module.exports: 可导出一个/多个参数 exports:只能导出多个参数,不能导出对象15.为什么利用多个域名来存储网络资源会更有效？16.设立&quot;严格模式&quot;的优点： 1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 2. 消除代码运行的一些不安全之处，保证代码运行的安全； 3. 提高编译器效率，增加运行速度； 4. 为未来新版本的Javascript做好铺垫。 注：经过测试 IE6,7,8,9 均不支持严格模式。 缺点： 现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节17.在css中如何处理ie,firefox,safari,chrome的兼容性问题 浏览器样式初始化： 浏览器私有属性 cssHack语法 自动化插件18.FOUC是什么意思 FOUC:浏览器样式闪烁或者叫做无样式内存闪烁 使用Import方法对css进行导入,会导致某些页面在window下的浏览器出现一些奇怪的想象，以无样式显示内容的瞬间出现瞬间闪烁，这种现象称之为文档样式短暂失效, 原因大致为： 1)使用import方法导入样式表 2）将样式表放在页面底部 解决办法： 使用link标签引入样式表放在文档head中19.如何解决cookie安全性问题 1)设置cookie有效期不要过长,合适即可 2)设置HttpOnly属性为true:可以防止js脚本读取cookie信息,有效的防止XSS攻击 3)设置复杂的cookie，加密cookie ①cookie的key使用uuid，随机生成 ②cookie的value可以使用复杂组合，比如:用户名+当前时间+cookie有效时间+随机数 4)对保存到cookie里面的敏感信息必须加密 5)用户第一次登录时,保存IP+cookie加密后的token 每次请求,都去将当前cookie和ip组合起来加密后的tokenn与保存的token作对比,只有全对应才能验证成功。 20.vue-router钩子函数: beforeEach afterEach 21.ajax实现过程 22.如何使一个元素垂直水平居中,如果是一个不定宽的元素如何实现呢? 23.js继承 24.简述src和href区别 25.document.load和document.ready有什么区别 1234567891011121314151617181920212223242526272829303132333435363738394041421.H5新特性2.用C3实现轮播图效果3.router钩子函数4.实现下拉框效果 手动5.文件上传6.缓存 页面不刷新 不缓存 页面 刷新 要想让页面刷新怎么办7.vuex8.tab栏 要想实现点击一个出现一个9.vue请求10.拦截器 请求拦截器 和 响应拦截器11.手动实现上拉刷新下拉加载 Axios如何解决跨域问题 移动端手机键盘弹出时遮盖了输入框如何优化解决 如何更改标题 UI图高度超出屏幕范围如何优化下拉框 怎么解决页面出现&#123;&#123;msg&#125;&#125; v-clock [v-clock]&#123;display: none;&#125; css垂直居中 px、em、rem有什么区别 position几种取值 相对谁进行定位 js数据类型 new运算符创建实例时，经过了哪些步骤 用什么方法可以获取对象的类? call()、apply()、bind()方法的作用是什么? 什么时候会使用到这些方法?他们之间的区别是什么? 利用正则表达式,写一个字符串转换成驼峰命名的方法 例如: border-bottom-color borderBottomColor commonJS AMD CMD的区别 MVC、MVP、MVVM的差异 简述v-if和v-show的区别 不同组件之间如何传递数据(父子组件、兄弟组件) 组件的生命周期由哪些 什么情况下会用到computed？什么情况下会用到watch? 项目构建过程中,如何提取公共资源？ js的存储方式 实现一个深拷贝 描述一下浏览器从加载到渲染的过程,比如输入一个网址到显示页面的过程 实现一个继承方法调用 请用js实现sort函数,要求 sort([5,100,6,3,-12]) 返回[-12,3,5,6,100] 事件对象中target对象 和 currentTarget对象的区别 target在事件流目标阶段 currentTarget在时间流捕获阶段 currentTarget指向事件所绑定的元素 target始终指向事件发生时的元素 写出判断一个变量名是否为数组的方法 用ES5实现数组去重的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889200：成功 302:重定向 304：未修改 403：禁止访问 404：未找到页面 500：服务器错误 垂直居中： 定位 弹性布局 :justify-content align-items 什么是vue生命周期? DOM渲染在哪个周期中就已经完成？ 列举块元素、行内元素和空元素 数组去重 什么是闭包 判断一个变量或者对象是不是为undefined 定义一个filter,将时间戳1512023760转化成&quot;2017-11-30&quot;格式 var str = 1554515432948; function getDate(str)&#123; var date = new Date(str); // console.log(date); var year = date.getFullYear() &gt; 10 ? date.getFullYear() : &quot;0&quot; + date.getFullYear(); var month = (date.getMonth()+1)&gt; 10 ? (date.getMonth()+1) : &quot;0&quot; + (date.getMonth()+1); var day = date.getDate() &gt; 10 ? date.getDate() : &quot;0&quot; + date.getDate(); return year +&apos;-&apos;+ month +&apos;-&apos;+ day; &#125; console.log(getDate(str)); 简述vuex js哪个方法用于匹配字符串?var a=&quot;20180528&quot;，如何从a中截取字符&quot;05“ str.indexOf(&apos;asf&apos;) var a=&quot;20180528&quot;; var num = a.indexOf(&apos;05&apos;); console.log(num); console.log(a.substr(num,2)); var data=&#123;a:1,b:2,c:3&#125;;将data对象变成数组 var data=&#123;a:1,b:2,c:3&#125;; var arr = []; for(var key in data)&#123; arr[arr.length] = key; &#125; console.log(arr); split()和join的区别 split()是把一串字符串(根据某个分隔符)分成若干个元素放在一个数组里,即切割成数组的形式 join()是把数组中的字符串根据符号拼成字符串 px、em、rem的取用选择依据 px像素,绝对单位,不能做适配 em:继承父元素的字体尺寸. rem:相对于body的字体大小 性能优化： 减少http请求、http缓存、资源合并与压缩、css精灵图、懒加载 js数据类型： 内存存储：简单数据类型(string、number、boolean、null、undefined)、复杂数据类型(array、date、function) 匹配一段由数字和大小写字母组成的字符串的正则表达式: /\w/.test(str) web前端适配多端的模式有什么解决方案 position包括几种属性?absolute和relative的区别? IE6 bug的解决方法 标签上title和alt属性有什么区别 display和visibility有何异同？ 隐藏后占不占位置 div+css布局较table布局有什么优点? sessionStorage和localStorage的区别 rgba()和opacity的透明效果有什么不同 px、em、rem的区别 如何阻止事件冒泡和默认事件 事件委托是什么 如何实现浏览器内多个标签之间的通信 call和apply的区别 function().call(this,num1,num2) function().apply(this,[num1,num2]) html兼容性问题 hasClass()、addClass()、removeClass()用法 用js判断一个字符串中出现次数最多的字符,统计这个次数 var str = &quot;safsafsafsdfafdafsdfsafsdfsafd&quot;; var arr = str.split(&quot;&quot;); // console.log(arr); var obj = &#123;&#125;; for(var i = 0; i &lt; arr.length; i++)&#123; if(!obj[arr[i]])&#123; obj[arr[i]] = 1; &#125;else&#123; obj[arr[i]] ++; &#125; &#125; console.log(obj); var maxcount = 0; for(var key in obj)&#123; if(obj[key] &gt; maxcount)&#123; maxcount = obj[key]; &#125; &#125; console.log(maxcount); js字符串操作数及使用方法 怎样添加 移除 移动 复制和查找节点 insertBefore removeChild cloneChild appendChild 去除字符串空格? /^\s|/s$/g jquery中如何将数组转化为json字符串,然后再转化回来? 截取字符串abcdefg的efg eval是做什么的,性能安全如何 Node.js优缺点,适用场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230// 1.运行结果// const p1 = new Promise((resolve,reject)=&gt;&#123;// setTimeout(()=&gt;&#123;// resolve(&apos;success&apos;)// &#125;,1000);// &#125;);// const p2 = p1.then(()=&gt;&#123;// throw new Error(&apos;error----&apos;);// &#125;);// console.log(&apos;p1&apos;,p1);// console.log(&apos;p2&apos;,p2);// setTimeout(() =&gt; &#123;// console.log(&apos;p1&apos;,p1);// console.log(&apos;p2&apos;,p2);// &#125;,2000);p1 Promise__proto__: Promisecatch: ƒ catch()constructor: ƒ Promise()finally: ƒ finally()then: ƒ then()Symbol(Symbol.toStringTag): &quot;Promise&quot;__proto__: Object[[PromiseStatus]]: &quot;resolved&quot;[[PromiseValue]]: &quot;success&quot; p2 Promise__proto__: Promise[[PromiseStatus]]: &quot;rejected&quot;[[PromiseValue]]: Error: error---- at p1.then (file:///E:/index.html:17:19)Uncaught (in promise) Error: error---- at p1.then (index.html:17)index.html:22 p1 Promiseindex.html:23 p2 Promise// 2.运行结果// var str = function()&#123;// console.log(2);// &#125;// function str()&#123;// console.log(1);// &#125;// str(); //2// 3.运行结果// let p1 = new Promise((resolve,reject)=&gt;&#123;// console.log(&apos;Promise&apos;);// resolve();// &#125;);// p1.then(function()&#123;// console.log(&apos;resolved&apos;);// &#125;);// console.log(&quot;Hi!&quot;); // Promise Hi! resolved// 4.运行结果// setTimeout(function()&#123;// console.log(1);// &#125;);// new Promise(function(resolve,reject)&#123;// console.log(2);// resolve(3);// &#125;).then(function(val)&#123;// console.log(val);// &#125;);// console.log(4);// 2 4 3 1// 5.运行结果// function trans(obj,value)&#123;// obj.name = &apos;hello world&apos;;// value = value +10;// return value;// &#125;// var o = &#123;name: &apos;hello&apos;,age: 20&#125;;// var count = 10;// var ret = trans(o,count);// console.log(o,ret,count);// &#123;name: &quot;hello world&quot;,age: 20&#125; 20 10// 6.运行结果// var test = (function(i)&#123;// console.log(i);// &#125;)(5);// test(1);// 5// 111.html:71 Uncaught TypeError: test is not a function// 7.运行结果// var scope = &apos;global&apos;;// function f()&#123;// console.log(scope);// var scope = &apos;local&apos;;// console.log(scope);// &#125;// f();// undefined &apos;local// 8. 运行结果// for(var i = 0; i&lt; 5;i++)&#123; // console.log(i); // &#125; // console.log(i); //0 1 2 3 4 5 // 9.运行结果 // for(var i = 0; i&lt;=4;i++)&#123; // setTimeout(function timer()&#123; // console.log(i); // &#125;,1000); // &#125; // 5 5 5 5 5 // for(let i = 0; i &lt;=4;i++)&#123; // setTimeout(function timer()&#123; // console.log(i); // &#125;,1000); // &#125; //0 1 2 3 4 // for(var i = 0; i &lt;= 4;i++)&#123; // (function(i)&#123; // setTimeout(function timer()&#123; // console.log(i); // &#125;,1000); // &#125;)(i); // &#125; //0 1 2 3 4 // 10.运行结果 // var F = function()&#123;&#125;; // Object.prototype.a = function()&#123; // console.log(&apos;a()&apos;); // &#125; // Function.prototype.b = function()&#123; // console.log(&apos;b()&apos;); // &#125; // f.a(); //111.html:118 Uncaught ReferenceError: f is not defined // f.b(); //111.html:119 Uncaught ReferenceError: f is not defined // F.a(); a() // F.b(); b() // 11.运行结果 // var test = &#123; // name:&apos;test&apos;, // fun: function()&#123; // console.log(this.name); // function getname()&#123; // console.log(this.name); // &#125; // getname(); // &#125; // &#125; // test(); // Uncaught TypeError: test is not a function // 12.写出代码对下列数组去重并从小到大排列 // var arr = [5,2,3,6,8,6,5,4,7,1,9]; // function sort(arr)&#123; // for(var i =0; i&lt;arr.length-1;i++)&#123; // for(var j = 0; j &lt; arr.length; j++)&#123; // if(arr[j]&gt;arr[j+1])&#123; // temp = arr[j]; // arr[j] = arr[j+1]; // arr[j+1] = temp; // &#125; // &#125; // &#125; // return arr; // &#125; // 去重？ // // 13.运行 // const p1 = new Promise((resolve,reject)=&gt;&#123; // console.log(1); // resolve(); // console.log(2); // &#125;); // p1.then(()=&gt;&#123; // console.log(3); // &#125;); // console.log(4); 1 2 4 3 // 14. // const first = () =&gt; new Promise((resolve,reject)=&gt;&#123; // console.log(3); // let p1 = new Promise((resolve,reject)=&gt;&#123; // console.log(7); // setTimeout(() =&gt; &#123; // console.log(5); // resolve(6); // &#125;,0); // resolve(1); // &#125;); // resolve(2); // p1.then((arg)=&gt;&#123; // console.log(arg); // &#125;); // &#125;); // first().then((arg)=&gt;&#123; // console.log(arg); // &#125;); // console.log(4); 3 7 4 1 2 5 1.页面在那些浏览器测试过,浏览器的内核分别是什么?浏览器对老系统的支持力度 2. var foo = &apos;10&apos; + 2/&quot;2&quot;; console.log(foo); //101 console.log(typeof foo); //string 3.var foo =&apos;aaa&apos;; var bar = &#123; foo: &apos;bbb&apos;, get: function()&#123; var foo = &apos;ccc&apos;; var that = this; return function()&#123; return that.foo; &#125; &#125; &#125; console.log(bar.get()()); //bbb var baz = bar.get; alert(baz()()); //aaa 4.MVVM框架是什么?他和其他jquery的区别是什么?适用于那些场景 5.用js实现一个冒泡排序算法 var arr = [5,5,6,5,8,9,4,6,5,3,2]; for(var i = 0; i &lt; arr.length - 1 ; i ++)&#123; for(var j = 0 ; j &lt; arr.length-1; j ++)&#123; if(arr[j] &gt; arr[j+1] )&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; &#125; &#125; &#125; console.log(arr) 数组去重： var arr = [5,5,6,5,8,9,4,6,5,3,2]; var newArr = new Set(arr); console.log(newArr); 6.输入框，没有焦点的时候，显示默认提示文字;用户输入时,隐藏提示文字,且恢复为默认色,失去焦点时,如果输入内容为空,还原提示信息 &lt;input type=&quot;text&quot; class=&quot;cls&quot; value=&quot;请输入搜索内容&quot;&gt; &lt;script&gt; // 输入框，没有焦点的时候，显示默认提示文字;用户输入时,隐藏提示文字,且恢复为默认色,失去焦点时,如果输入内容为空,还原提示信息 var input = document.querySelector(&apos;.cls&apos;); input.onblur = function()&#123; var val = this.value; console.log(val); if(val == &apos;&apos;)&#123; this.value = &apos;请输入搜索内容&apos; &#125; &#125; input.onfocus = function()&#123; this.value = &apos;&apos;; &#125; &lt;/script&gt; 有问题的知识点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621.用js实现千位分隔符，要求如下： 判断输入的都必须是数字或者数字组成的字符串 例如:输入的是10000,输出则是10,0002.用js实现对集合处理的过程,其要求如下输入可以是1个2个或者3个参数,需要判断用户输入给出相应的方案,例如:输入是fun([1,3,2],[5,2,1,4],[2,1]),则输出是[1,3,2,5,4]3.BFC实现原理4.html文档中 Doctype作用: 有哪几种类型5.如何深度克隆 至少3种方法6.已知圆心为(x,y),求圆上任意一点的坐标 假设半径和角度为变量=======求解答7.event loop 事件循环8.jquery和vue的区别9.浏览器缓存有哪些，通常缓存有哪几种 浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。 浏览器在第一次请求发生后，再次请求时： 浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信； 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 强缓存 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。 协商缓存 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段10.使用递归实现对数组的快速排序11.new Promise(function executor(resolve)&#123; console.log(1); for(var i = 0; i &lt; 1000; i++)&#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2); &#125;).then(function()&#123; setTimeout(function()&#123; cnsole.log(3); &#125;,10); console.log(4); &#125;); setTimeout(function()&#123; console.log(5); &#125;,0); console.log(6); for循环是异步的,为什么不执行for循环中的代码12.编写一个function将location.search转化为对象的形式&#123;&#125; location.search是url中?号及?号之后的内容 ?q=for%E5&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=for%E5%BED%A5de%27ma&amp;sc=0-13&amp;sk=&amp;cvid=043448F 先截取?号,之后将后面的内容根据&amp;符号分割为数组,将数组中每一项根据=号,分割为数组13.js引入的方式有哪些?link和@import的区别是? 1)HTML 文件被加载时，link 引用的文件会同时被加载，而 @import 引用的文件则会等页面全部下载完毕再被加载 2)link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持14.为什么利用多个域名来存储网络资源会更有效？ 1)CDN缓存更方便。 2)突破浏览器并发限制。 3)Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢15.js是单线程还是多线程16.怎么理解MVVM模式这些框架17.JS哪些操作会造成内存泄漏18.http和https有何区别?如何灵活使用?19.jsonp原理20.css合并方法21.ie的某些兼容性 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或者margin-right，margin值会加倍。这种情况下IE会产生20px的距离，解决方案是在float的标签样式控制中加入display：inline;将其转化为行内属性，，只有IE会识别）22.url从请求道页面渲染执行了哪些过程23.js中typeof和instanceof函数作用及区别 扩展1234567891.vue和react的区别 相同点:①都支持服务器渲染②都有虚拟DOM,组件化开发，通过props参数进行父子组件数据的传递,都实现webComponent规范③数据驱动试图④都支持native的方案,React的React native，Vue的weex⑤都有管理状态,React有redux,Vue有自己的Vuex(自适应vue)⑥提供了响应式Reactive和组件化Composable的视图组件⑦将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。2.ng-show/ng-hide与ng-if的区别3.解释下什么是$rootScrope以及$scope的区别4.如何实现浏览器内多个标签页之间的通信？5.react和vue有哪些相同点和不同点，说说你对这两个框架的看法6.Cache-control7.常见的web攻击技术有哪些?前端需要如何处理8.实现一个log函数,与console.log具有相同的特性,但每条输出都带有前缀,使用工厂模式创建出带有不同前缀的log函数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071.for(var i =0; i &lt; 5; i++)&#123; var a = 1; setTimeout(function()&#123; console.log(i); // 5 个5 &#125;,0); &#125; (function()&#123; console.log(a); //1 console.log(b); //undefined b = &quot;b&quot;; console.log(b); // b a = 2; console.log(a); // 2 var b; &#125;)(); console.log(a); // 22.var arr = [0,1,2,3,4,5,6,7,8,9]; for(var i = 0; i &lt; arr.length; i++)&#123; if(i%2 == 0)&#123; arr.splice(i,1); &#125; &#125; alert(arr); //1 2 4 5 7 83.function fun()&#123; for(var i = 0; 4&gt;i;i++)&#123; var k = 100; str += &apos;,&apos;+(k+i); &#125; &#125; var k = 1, str = k; fun(); str += k; console.log(str); //1,100,101,102,10314.function foo()&#123; try &#123; return 0; console.log(&quot;b&quot;); &#125;catch(err)&#123; ​ &#125;finally&#123; console.log(&quot;a&quot;); &#125; &#125; console.log(foo()); // a 05.var r = new Promise(function(resolve,reject)&#123; console.log(&quot;a&quot;); resolve(); &#125;) setTimeout( () =&gt; console.log(&apos;d&apos;),0); r.then(() =&gt; console.log(&quot;c&quot;)); console.log(&quot;b&quot;); // a b c d6.var a = 5; var b = 10; if(a == 5.0)&#123; let a = 4; var b = 1; console.log(a); // 4 console.log(b); // 1 &#125; console.log(a); // 5 console.log(b); // 17.var length = 10; function fn()&#123; console.log(this.length); &#125; var obj = &#123; length: 5, methods(fn)&#123; fn(); console.log(arguments[0]); arguments[0](); &#125; &#125; obj.methods(fn); 10 18.问题=========================================== function Foo()&#123; getName = function()&#123;console.log(1)&#125;; return this; &#125; Foo.getName = function()&#123; console.log(2); &#125; Foo.prototype.getName = function () &#123; console.log(3) &#125; var getName = function()&#123;console.log(4)&#125; function getName()&#123;console.log(5)&#125; Foo.getName(); getName(); Foo().getName(); getName(); new Foo.getName(); new Foo().getName();9.var a = 1; function test()&#123; console.log(a); //undefined var a = 2; console.log(this.a); //1 setTimeout(function()&#123; console.log(a); // 3 &#125;,0); return function()&#123; console.log(a); //2 a = 3; console.log(this.a); // 1 &#125; &#125; test()();]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端基础vue]]></title>
    <url>%2Fsongfang0%2F2019%2F06%2F11%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80vue%2F</url>
    <content type="text"><![CDATA[前端基础vue]]></content>
  </entry>
  <entry>
    <title><![CDATA[Meta-http-equiv]]></title>
    <url>%2Fsongfang0%2F2019%2F06%2F10%2FMeta-http-equiv%2F</url>
    <content type="text"><![CDATA[Meta http-equiv属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Meta http-equiv属性详解http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 引用meat标签的http-equiv属性语法格式是：＜meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;＞ ；其中http-equiv属性主要有以下几种参数：1、Expires(期限) 说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 用法：Html代码 ＜meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2007 22:33:00 GMT&quot;＞ 注意：必须使用GMT的时间格式。 2、Pragma(cache模式) 说明：是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出 用法：Html代码 ＜meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;＞ 注意：这样设定，访问者将无法脱机浏览。 3、Refresh(刷新) 说明：自动刷新并指向新页面。 用法：Html代码 注意双引号＜meta http-equiv=&quot;Refresh&quot; content=&quot;2；URL=http://www.net.cn/&quot;＞ 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 4、Set-Cookie(cookie设定) 说明：如果网页过期，那么存盘的cookie将被删除。 用法：Html代码 ＜meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx;expires=Wednesday, 20-Jun-2007 22:33:00 GMT； path=/&quot;＞ 注意：必须使用GMT的时间格式。 5、Window-target(显示窗口的设定) 说明：强制页面在当前窗口以独立页面显示。 用法：Html代码 ＜meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;＞ 注意：用来防止别人在框架里调用自己的页面。 6、content-Type(显示字符集的设定) 说明：设定页面使用的字符集。 用法：Html代码 ＜meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=gb2312&quot;＞ 7、Pics-label(网页等级评定) 用法：Html代码 &lt;meta http-equiv=&quot;Pics-label&quot; contect=&quot;&quot;&gt; 说明：在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的。 8、Page_Enter、Page_Exit 设定进入页面时的特殊效果Html代码 &lt;meta http-equiv=&quot;Page-Enter&quot; contect=&quot;revealTrans(duration=1.0,transtion= 12)&quot;&gt; 设定离开页面时的特殊效果Html代码 &lt;meta http-equiv=&quot;Page-Exit&quot; contect=&quot;revealTrans(duration=1.0,transtion= 12)&quot;&gt; Duration的值为网页动态过渡的时间，单位为秒。 Transition是过渡方式，它的值为0到23，分别对应24种过渡方式。如下表： 0 盒状收缩 1 盒状放射 2 圆形收缩 3 圆形放射 4 由下往上 5 由上往下 6 从左至右 7 从右至左 8 垂直百叶窗 9 水平百叶窗 10 水平格状百叶窗 11垂直格状百叶窗 12 随意溶解 13从左右两端向中间展开 14从中间向左右两端展开 15从上下两端向中间展开 16从中间向上下两端展开 17 从右上角向左下角展开 18 从右下角向左上角展开 19 从左上角向右下角展开 20 从左下角向右上角展开 21 水平线状展开 22 垂直线状展开 23 随机产生一种过渡方式 9、清除缓存（再访问这个网站要重新下载！） Html代码 &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; 10、设定网页的到期时间 Html代码 &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 11、关键字,给搜索引擎用的 Html代码 &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; 12.页面描述 Html代码 &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt; 一般使用以下用法 123456禁止浏览器从本地机的缓存中调阅页面内容&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt; 清除缓存&lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; 设定网页的到期时间 &lt;META HTTP-EQUIV=&quot;Expires&quot; CONTENT=&quot;0&quot;&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue之图片上传]]></title>
    <url>%2Fsongfang0%2F2019%2F05%2F26%2Fvue%E4%B9%8B%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[##vue文件上传 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;picUpload&quot;&gt; &lt;input type=&quot;file&quot; id=&apos;file&apos; @change=&apos;getFile()&apos;&gt; 必须写id &lt;img src=&quot;&quot; id=&apos;img&apos; alt=&apos;此图片无法显示&apos;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; getFile()&#123; 第一种: //var fileReader = new FileReader(); 哪里来的file //fileReader.readAsDataURL(file.files[0]); //fileReader.onload = function () &#123; /*读取完毕 base64位数据 表示图片*/ //console.log(this.result); //document.querySelector(&apos;#img&apos;).src = this.result; //&#125; 第二种: var file = document.getElementById(&apos;file&apos;); console.log(file.files); var fileReader = new FileReader(); fileReader.readAsDataURL(file.files[0]); fileReader.onload = function () &#123; // /*读取完毕 base64位数据 表示图片*/ console.log(this.result); document.querySelector(&apos;#img&apos;).src = this.result; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[项目之获取数据总结]]></title>
    <url>%2Fsongfang0%2F2019%2F05%2F02%2F%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[##PC端项目总结 1. 搭建项目1234567vue init webpack systemnpm i npm run dev 配置打开浏览器 --open配置路由引入element-ui框架 js及样式引入axios 2. 首页获取数据2.1 获取当前的地理位置123456789101112HTML5 Geolocation API 用于获得用户的地理位置。html5的定位以及调用百度地图的步骤 js提供的API 通过IP去定位 通过JS获取经纬度,调用第三方接口(百度地图、高德地图),基于Ibs的服务: Location base service 百度地图API: http://lbsyun.baidu.com/ 开发文档-&gt; web开发-&gt; javascript API 1.获取到自己的经纬度 2.调用百度地图,把经纬度传过去 3.html5新增的API 获取用户的当前位置,PC端有问题,没有硬件支持 window.navigator.geolocation.getCurrentPosition(); 通过这个对象来获取位置,参数是一个回调函数 获取经纬度.html 123456789101112131415function getLocation()&#123; 获取位置对象的兼容 if (navigator.geolocation)&#123; 参数是一个回调函数 navigator.geolocation.getCurrentPosition(showPosition) &#125;else&#123; x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;; &#125; &#125; 这个回调函数在获取用户位置成功的时候会被调用function showPosition(position)&#123; 获取到用户的经纬度 x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude;&#125;getLocation(); 调用百度地图.html 123456789101112131415161718192021222324252627282930313233343536373839引入百度的js库 开发指南-账号和获取密钥 引入&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html&#123;height:100%&#125; body&#123;height:100%;margin:0px;padding:0px&#125; #allmap&#123;height:100%&#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=qeaWNDHywm4w1XqSRSpTaaDWhqC31V7B&quot;&gt;&lt;/script&gt; &lt;script&gt; var map = new BMap.Map(&quot;allmap&quot;); var point = new BMap.Point(116.331398,39.897445); map.centerAndZoom(point,12); var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function(r)&#123; if(this.getStatus() == BMAP_STATUS_SUCCESS)&#123; var mk = new BMap.Marker(r.point); map.addOverlay(mk); map.panTo(r.point); alert(&apos;您的位置：&apos;+r.point.lng+&apos;,&apos;+r.point.lat); &#125; else &#123; alert(&apos;failed&apos;+this.getStatus()); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 根据经纬度转换为具体位置.html 1开发文档-&gt; web服务API-&gt; 正逆地理编码-&gt; 逆地理编码]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node项目]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F26%2FNode%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Node项目1. 项目功能123456789101.用户模块 用户登录 用户注册 用户退出2.文章 文章列表 文章详情 发布新文章 编辑文章 删除文章 2. 项目准备-介绍123456789101112环境：Node.js + express数据库:mysql分布式管理工具:git实际开发中，先实现注册功能再实现登录功能,有账号才能登录git回顾 git init 目录下多一个.git文件 git status git add . git commit -m &quot;&quot; 新建仓库 关联仓库 git push -u origin master 12345678910111213141516项目准备1.创建文件夹 webkit npm init -y 第一次使用需要初始化 npm i express2.git管理 git init git status node_modues:不需要上传到git 在目录下创建一个.gitignore文件,把不想要用git管理的文件或者文件夹的名字放在这个文件里面 .gitignore：/node_modules git add . 创建远程仓库 github =&gt; + =&gt; new repository =&gt; 名字-public-creating =&gt; git commit -m &quot;&quot; git remote add origin 链接 关联仓库 git push -u origin master 第一次推送 3. 项目文件组成123456789node_modulespackage.jsonpackage-lock.json.gitignoreapp.js 程序入口文件router.js 路由配置文件/fun/fun.js:控制器文件 实现具体功能函数/views:html文件/public:静态资源文件 第一次: app.js 12345678910111213原始代码// 1.导包const express = require(&apos;express&apos;);// 2.实例化const app = express();// 3.配置路由app.get(&apos;&apos;,(req,res) =&gt; &#123; res.send(&apos;//////&apos;);&#125;);// 4.监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it at localhost:12345&apos;);&#125;); 第二次: app.js 1234567891011121314优化代码,提取路由// 1.导包const express = require(&apos;express&apos;);// //配置路由1.1 导包const router = require(&apos;./router&apos;);// 2.实例化const app = express();// 3.配置路由// // //配置路由1.2 使用路由 实例化app.use(router);// 4.监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it at localhost:12345&apos;);&#125;); router.js 12345678910111213文件作用:配置路由// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callbackrouter.get(&apos;&apos;,(req,res) =&gt; &#123; res.send(&apos;//////&apos;);&#125;);// 4.导出成员module.exports = router; 提取路由配置中函数处理部分代码,修改touter.js文件 router.js 12345678910111213// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用router.get(&apos;/&apos;,user.login);// 4.导出成员module.exports = router; user.js 1234// 提取路由配置中函数处理部分代码exports.login = (req,res) =&gt; &#123; res.send(&apos;//////&apos;);&#125;; git 1234git statusgit add .git commit -m &quot;初始化项目文件&quot;此时不需要push，只有大功能时才需要提交 4. 登录功能拆分12341.渲染登录页面2.客户端发送表单请求3.服务端处理客户端的请求,返回响应4.客户端处理服务端返回的响应 4.1 渲染登录页面12345671.导入登录页面的素材 views:signin.html public: css img 2.配置第三方包 3.统一处理静态资源文件 4.增加路由配置+找方法 5.渲染视图 res.render() 4.2 安装第三方包-配置静态资源12345671.配置第三方包 安装包npm i jquery bootstrap@3.3.7包之间加空格,可以同时安装两个包2.统一处理第三方资源在app.js文件中配置app.use(&apos;/node_modules&apos;,express.static(&apos;/node_modules&apos;));app.use(&apos;/public&apos;,express.static(&apos;/public&apos;)); 4.3 渲染登录页面-路由配置12345678910111213141516当标识是signin的时候,渲染登录页面在配置路由页面中配置渲染登录页的代码1.安装express-art-template包 官网:https://www.npmjs.com/package/express-art-template npm i art-template npm i express-art-template2.导入包之后为res对象添加了一个render()方法3.在app.js中配置app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;));4.在配置路由文件中渲染页面router.get(&apos;/&apos;,user.login); 当标识是/时，渲染页面5.在user.js文件中处理函数中的代码// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;; 模板引擎渲染页面参考代码 1234567891011121314151.导包var express = require(&apos;express&apos;);2.实例化var app = express();3.配置 当请求的是html文件时app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;));4.配置路由app.get(&apos;/&apos;, function (req, res) &#123; res.render(&apos;signin.html&apos;, &#123; user: &#123; name: &apos;aui&apos;, tags: [&apos;art&apos;, &apos;template&apos;, &apos;nodejs&apos;] &#125; &#125;);&#125;); 4.4 客户端发送表单请求12345ES6新语法：不是所有浏览器都支持1.找到表单文件2.取消表单默认行为3.获取表单数据4.ajax post signin.html 1234567891011&lt;script&gt; $(&apos;form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signin&apos;,data,function(data)&#123; console.log(data); &#125;); // 取消浏览器默认行为 // return false; e.preventDefault(); &#125;); &lt;/script&gt; 4.5 服务端处理表单-获取表单数据12345服务端 1.获取表单提交的数据 2.先验证邮箱 3.验证该邮箱的密码是否正确 4.返回200状态码 router.js 12在router.js文件中配置路由router.post(&apos;/signin&apos;,user.handleLogin); user.js 12345exports.handleLogin = (req,res) =&gt; &#123; // 获取表单提交的数据 body-parser var body = req.body; body: &#123; email: &apos;111@111.com&apos;, password: &apos;111&apos; &#125;&#125; body-parser包的使用 1234567891.安装 npm i body-parser2.导包 const bodyParser = require(&apos;body-parser&apos;);3.配置 // 配置body-parser app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); app.use(bodyParser.json()); 4.结果就是为req对象添加了body属性，来获取表单数据 var body = req.body; &#123; email: &apos;111@111.com&apos;, password: &apos;111&apos; &#125; 4.6 服务端处理表单-验证邮箱12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849通过数据库来验证在user.js文件中// 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;message&apos;&#125;);// 3.开启链接connection.connect();// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); const sqlStr = &apos;select * from `users` where email = ?&apos;; connection.query(sqlStr,body.email,(error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果results的值 有数据，则返回对应的数据(数组)，没有数据则为空数组。 if(results.length === 0)&#123; res.send(&#123; code:1, msg:&apos;邮箱不存在&apos; &#125;); &#125; //邮箱存在，验证邮箱密码是否正确 // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125; sql包使用 12345678910111213141516171819201.安装 npm i mysql// 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;message&apos;&#125;);// 3.开启链接connection.connect();// 4.执行sql语句const id = 257;const sqlStr = &apos;delete from `posts` where id = ?&apos;;connection.query(sqlStr,[id],(error,results) =&gt; &#123; console.log(results);&#125;);// 5.关闭数据库连接connection.end(); 4.7 服务端处理表单-验证密码-返回响应12345678910111213user.js//邮箱存在，验证邮箱密码是否正确// 邮箱正确,results为查询到的数据if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;);&#125;res.send(&#123; code: 200, msg: &apos;可以登录了&apos;&#125;); 4.8 客户端处理服务端返回的响应121.如果服务端返回的结果为200,邮箱密码都正确，客户端重定向到列表页2.如果不等于200,提示用户错误信息 signin.html 12345678910111213141516&lt;script&gt; $(&apos;form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signin&apos;,data,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/&apos;; &#125;else &#123; alert(data.msg); &#125; &#125;); // 取消浏览器默认行为 // return false; e.preventDefault(); &#125;);&lt;/script&gt; 4.9 登录优化-提取mysql模块fun/user.js 1234567891011121314151617181920212223242526272829303132333435// 导入数据库封装文件const mysql = require(&apos;../sql/user_login&apos;);// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); mysql.checkForm(body.email, (error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果数据存在，则返回的数据数组不为0,否则数组长度为0 if(results.length === 0)&#123; return res.send(&#123; code: 1, msg: &quot;邮箱不存在&quot; &#125;); &#125; // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125; 封装的sql/user_login.js 12345678910111213141516171819202122//专门处理数据库操作的代码并且返回执行的结果// 提取路由配置中函数处理部分代码//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.checkForm = (email,callback) =&gt; &#123; const sqlStr = &apos;select * from `users` where email = ?&apos;; connection.query(sqlStr,email,(error,results) =&gt; &#123; if(error)&#123; return callback(error); &#125; callback(null,results); &#125;);&#125; 扩展 将mysql配置前三步提取到一个文件中 db_config.js 123456789101112//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();module.exports = connection; sql/user_login.js 1234567891011导入db_config.js包const connection = require(../mysql/db_config);exports.checkForm = (email,callback) =&gt; &#123; const sqlStr = &apos;select * from `users` where email = ?&apos;; connection.query(sqlStr,email,(error,results) =&gt; &#123; if(error)&#123; return callback(error); &#125; callback(null,results); &#125;);&#125; 5. 项目-MVC-各司其职123view：视图 html文件+css+js+模板引擎model:操作数据库controls：函数处理逻辑 实现大量业务逻辑 6. 文章列表6.1 渲染列表页1231.当请求标识为&apos;/&apos;时，发起对列表页的渲染2.增加router请求,实现渲染列表的函数代码3.topList.js 实现函数代码 渲染页面 router.js 1234567891011121314151617181920// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topList = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用 //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topList.list);// 4.导出成员module.exports = router; topList.js 1234// 渲染文章列表exports.list = (req,res) =&gt; &#123; res.render(&apos;index.html&apos;);&#125; 6.2 数据处理topList.js 12345678910111213141516const topList = require(&apos;../sql/topic_list.js&apos;);// 渲染文章列表exports.list = (req,res) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器错啦&apos; &#125;); &#125; res.render(&apos;index.html&apos;,&#123; items: results &#125;); &#125;);&#125; toppic_list.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.showList = (callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` order by id desc&apos;; connection.query(sqlStr,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; index.html 123456789101112131415&lt;ul class=&quot;media-list&quot;&gt; &#123;&#123;each items&#125;&#125; &lt;li class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;/&quot;&gt; &lt;img width=&quot;40&quot; height=&quot;40&quot; class=&quot;media-object&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;&quot;&gt;&#123;&#123;$value.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;sueysok 回复了问题 • 2 人关注 • 1 个回复 • 187 次浏览 • 话题创建时间&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt; 6.3 express-session-保存用户信息12345678910111213141.安装 npm install express-session2.导包 const session = require(&apos;express-session&apos;);3.配置 var app = express(); app.use(session(&#123; secret: &apos;keyboard cat&apos;, resave: false, saveUninitialized: true &#125;)); 让req请求对象添加一个session属性4.session req.session.user = data[0]; user.js 12345678910111213141516171819202122232425262728293031323334353637// 导入数据库封装文件const mysql = require(&apos;../sql/user_login&apos;);// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); mysql.checkForm(body.email, (error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果数据存在，则返回的数据数组不为0,否则数组长度为0 if(results.length === 0)&#123; return res.send(&#123; code: 1, msg: &quot;邮箱不存在&quot; &#125;); &#125; // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; req.session.user = results[0]; console.log(req.session.user); res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125; 6.4 登录和注册的显示与隐藏1在列表页的头部部分判断session存在与否 topList.js 123456789101112131415161718const topList = require(&apos;../sql/topic_list.js&apos;);// 渲染文章列表exports.list = (req,res) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器错啦&apos; &#125;); &#125; res.render(&apos;index.html&apos;,&#123; items: results, user: req.session.user // 将保存在session中的数据取出来渲染在列表页 &#125;); &#125;);&#125; header.html 123456789101112131415161718192021判断session中的数据，如果存在就显示。。如果不存在显示登陆注册按钮&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &#123;&#123;if user&#125;&#125; &lt;a class=&quot;btn btn-default navbar-btn&quot; href=&quot;/topic/create&quot;&gt;发起&lt;/a&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;&lt;img width=&quot;20&quot; height=&quot;20&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li class=&quot;dropdown-current-user&quot;&gt; 当前登录用户:爱谁谁 &lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/settings/profile&quot;&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/signout&quot;&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;a class=&quot;btn btn-primary navbar-btn&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;a class=&quot;btn btn-success navbar-btn&quot; href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &#123;&#123;/if&#125;&#125;&lt;/ul&gt; 6.5 显示当前用户名12将user中的数据渲染出来当前登录用户:&#123;&#123;user.nickname&#125;&#125; 7.发布新文章7.1 渲染页面router.js 123456789101112131415161718192021// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topic = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic);// 4.导出成员module.exports = router; topList.js 123456// 添加话题exports.createTopic = (req,res) =&gt; &#123; res.render(&apos;topic/create.html&apos;,&#123; user: req.session.user &#125;);&#125; 7.2 客户端发送表单请求create.html 123456789101112131415161718192021&lt;form id=&quot;form&quot; action=&apos;/topic/create&apos;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;标题&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; name=&quot;title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt;内容&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;content&quot; name=&quot;content&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt; $(&apos;#form&apos;).on(&apos;submit&apos;,function(e)&#123; var dataForm = $(this).serialize(); $.post(&apos;/topic/create&apos;,dataForm,function(data)&#123; console.log(data); &#125;); //阻止浏览器默认提交 e.preventDefault(); &#125;);&lt;/script&gt; 7.3 服务端处理表单请求1231.router.js 当请求标识为/topic/create2.topList.js 接收数据,往数据库中添加数据3.createTopicHandle.js 封装处理数据库函数 router.js 12345678910111213141516171819202122// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topic = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle);// 4.导出成员module.exports = router; fun/topList.js 12345678910111213141516// 处理文章表单逻辑exports.createTopicHandle = (req,res) =&gt; &#123; const data = req.body; createTopicHandl.createHandle(data, (error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code: 500, msg: &quot;服务器出错了&quot; &#125;); &#125; res.send(&#123; code: 200, msg: &quot;话题发布成功&quot; &#125;); &#125;);&#125; createTopicHandle.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.createHandle = (data,callback) =&gt; &#123; const sqlStr = &apos;insert into `topics` set ?&apos;; connection.query(sqlStr,data,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 7.4 客户端处理服务端返回的数据123456789101112&lt;script&gt; $(&apos;#form&apos;).on(&apos;submit&apos;,function(e)&#123; var dataForm = $(this).serialize(); $.post(&apos;/topic/create&apos;,dataForm,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/&apos;; &#125; &#125;); e.preventDefault(); &#125;);&lt;/script&gt; 8. 持久化存储用户信息123456781.express-session:存的数据在服务器的内存中 每次重启服务器数据就会消失 req.session 持久化存储 -mysql或者本地存储2.express-mysql-session作用:把express-session保存的数据req.session自动的保存到数据库中1)安装 npm i express-mysql-session2)app.js文件中配置包3)express-session包也需要导入4)结果 当使用req.session.user = ？ 时,会自动把数据放在mysql中5)结果 当访问req.session.user时,会自动查询数据库 app.js 123456789101112131415161718192021// 1.导入express-mysql-sessionconst session = require(&apos;express-session&apos;);const MySQLStore = require(&apos;express-mysql-session&apos;)(session);// 2.配置express-mysql-sessionconst options = &#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, password: &apos;root&apos;, database: &apos;webkit&apos;&#125;;// 3.实例化express-mysql-sessionconst sessionStore = new MySQLStore(options);//4.app.use(session(&#123; key: &apos;session_cookie_name&apos;, secret: &apos;session_cookie_secret&apos;, store: sessionStore, resave: false, saveUninitialized: false&#125;)); 8.1 设置话题的createdAt123456自动格式化时间 momentjs.com1.安装包 npm i moment2.导包 const moment = require(&apos;moment&apos;);3.使用 在文章表单提交的时候,服务器端获取表单数据,动态的添加数据 createAt 创建时间日期 body.createdAt = moment().format(); 8.2 设置话题的创建者-userId123把当前存的用户id值 赋值给文章里面的userId区分每个文章的创建者body.userId = req.session.user.id; 9. 退出用户9.1 退出用户12delete xxx:js自带方法,删除对象成员点击退出：删除session 退回到登陆页 header.js 123456789&lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li class=&quot;dropdown-current-user&quot;&gt; 当前登录用户:&#123;&#123;user.nickname&#125;&#125; &lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/settings/profile&quot;&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/signout&quot;&gt;退出&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; router.js 1234567891011121314151617181920212223// 文件作用:配置路由// 1.导包const express = require(&apos;express&apos;);// user.js导入模块const user = require(&apos;./fun/user&apos;);// topList.js 文章列表const topic = require(&apos;./fun/topList.js&apos;);// 2.实例化const router = express.Router();// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout);// 4.导出成员module.exports = router; fun/user.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 导入数据库封装文件const mysql = require(&apos;../sql/user_login&apos;);// 渲染登录页面exports.login = (req,res) =&gt; &#123; res.render(&apos;signin.html&apos;);&#125;;// 处理登陆页表单逻辑exports.handleLogin = (req,res) =&gt; &#123; // 接收表单提交的数据 body-parser const body = req.body; // console.log(body); mysql.checkForm(body.email, (error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); 如果数据存在，则返回的数据数组不为0,否则数组长度为0 if(results.length === 0)&#123; return res.send(&#123; code: 1, msg: &quot;邮箱不存在&quot; &#125;); &#125; // 邮箱正确,results为查询到的数据 if(results[0].password !== body.password)&#123; return res.send(&#123; code: 2, msg: &quot;密码不正确&quot; &#125;); &#125; // 将用户信息存在session中 req.session.user = results[0]; // console.log(req.session.user); res.send(&#123; code: 200, msg: &apos;可以登录了&apos; &#125;); &#125;);&#125;// 退出登陆页处理exports.signout = (req,res) =&gt; &#123; // 删除session delete req.session.user; // 退出到登陆页 res.redirect(&apos;/login&apos;);&#125; 10. 文章详情10.1 渲染页面index.html 12345678910111213141516&lt;ul class=&quot;media-list&quot;&gt; &#123;&#123;each items&#125;&#125; &lt;li class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;a href=&quot;/&quot;&gt; &lt;img width=&quot;40&quot; height=&quot;40&quot; class=&quot;media-object&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;...&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;/detail/topic&quot;&gt;&#123;&#123;$value.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;sueysok 回复了问题 • 2 人关注 • 1 个回复 • 187 次浏览 • 话题创建时间 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/ul&gt; router.js 1234567891011router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) .get(&apos;/detail/topic&apos;,topic.detail);// 4.导出成员module.exports = router; topList.js 1234// 话题详情页exports.detail = (req,res) =&gt; &#123; res.render(&apos;topic/show.html&apos;);&#125; 10.2 配置路由–标识是动态的1/detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 index.html 12&lt;h4 class=&quot;media-heading&quot;&gt;&lt;a href=&quot;/detail/topic/&#123;&#123;$value.id&#125;&#125;&quot;&gt;&#123;&#123;$value.title&#125;&#125;&lt;/a&gt;&lt;/h4&gt;给每个标识后面添加动态的id,方便详情页通过id查询数据 router.js 12345678910111213141516// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.detail);// 4.导出成员module.exports = router; topList.js 123456789// 话题详情页标识:.get(&apos;/detail/topic/:topicID&apos;,topic.detail);exports.detail = (req,res) =&gt; &#123; // 获取标识动态路由参数的值 :冒号后面的 req.params &#123;topicID:9&#125; const topicID = req.params.topicID; console.log(topicID); // res.render(&apos;topic/show.html&apos;);&#125; 10.3 处理数据12341.在router.js文件中配置路由2.在fun/topList.js文件中 处理详情页逻辑业务3.在sql/detail.js文件中 处理 数据库查询代码4.在fun/topList.js文件中渲染页面数据 router.js 12345678910111213141516// 3.配置路由// 参数1:标识 参数2：callback// user.js对象导出使用// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail);// 4.导出成员module.exports = router; fun/topList.js 12345678910111213141516171819202122// 话题详情页exports.topicDetail = (req,res) =&gt; &#123; // 获取标识动态参数的值 const topicID = req.params.topicID; detailData.detail(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg:&apos;服务器出错了&apos; &#125;); &#125; if(results.length == 0)&#123; return res.send(&#123; code: 1, msg:&apos;数据已经被删除&apos; &#125;); &#125; res.render(&apos;topic/show.html&apos;,&#123; topic: results[0] &#125;); &#125;);&#125; detail.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.detail = (id,callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 10.4 处理数据不存在的情况show.html 1234567891011121314151617181920212223242526272829303132333435&lt;div class=&quot;col-md-9&quot;&gt; &#123;&#123;if !topic&#125;&#125; &lt;p&gt;此话题不存在或已被删除。&lt;/p&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;/&quot;&gt;返回首页&lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;article class=&quot;markdown-body&quot;&gt; &lt;h1&gt;&#123;&#123;topic.title&#125;&#125;&lt;/h1&gt; &lt;a href=&quot;/topic/detail/edit&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;/topic/detail/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt; &lt;hr&gt; &#123;&#123;topic.content&#125;&#125; &lt;/article&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;span&gt;lzz&lt;/span&gt; commented &lt;span&gt;24 minutes ago&lt;/span&gt; &lt;span class=&quot;action&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-thumbs-up pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; 评论测试 &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;添加回复&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;&quot; id=&quot;&quot; cols=&quot;10&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;回复&lt;/button&gt; &lt;/form&gt; &#123;&#123;/if&#125;&#125;&lt;/div&gt; 10.5 编辑与删除按钮的显示与隐藏12如果文章的用户Id与session中的id一样，则显示编辑与删除按钮，否则隐藏。将session中的数据保存在数组中,在显示页面判断显示与隐藏 topList.js 1234567891011121314151617181920212223// 话题详情页exports.topicDetail = (req,res) =&gt; &#123; // 获取标识动态参数的值 const topicID = req.params.topicID; detailData.detail(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg:&apos;服务器出错了&apos; &#125;); &#125; // if(results.length == 0)&#123; // return res.send(&#123; // code: 1, // msg:&apos;数据已经被删除&apos; // &#125;); // &#125; res.render(&apos;topic/show.html&apos;,&#123; topic: results[0], userId: req.session.user ? req.session.user.id : 0 &#125;); &#125;);&#125; show.html 12345678910111213141516171819202122232425262728293031323334353637&lt;div class=&quot;col-md-9&quot;&gt; &#123;&#123;if !topic&#125;&#125; &lt;p&gt;此话题不存在或已被删除。&lt;/p&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;/&quot;&gt;返回首页&lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;article class=&quot;markdown-body&quot;&gt; &lt;h1&gt;&#123;&#123;topic.title&#125;&#125;&lt;/h1&gt; &#123;&#123;if topic.userId === userId&#125;&#125; &lt;a href=&quot;/topic/detail/edit&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;/topic/detail/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt; &#123;&#123;/if&#125;&#125; &lt;hr&gt; &#123;&#123;topic.content&#125;&#125; &lt;/article&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;span&gt;lzz&lt;/span&gt; commented &lt;span&gt;24 minutes ago&lt;/span&gt; &lt;span class=&quot;action&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-thumbs-up pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-remove-circle pull-right&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; 评论测试 &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot;&gt;添加回复&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;&quot; id=&quot;&quot; cols=&quot;10&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;回复&lt;/button&gt; &lt;/form&gt; &#123;&#123;/if&#125;&#125;&lt;/div&gt; 10.6 删除话题12341.在a链接中设置href地址，地址中将id参数传入2.在ruter.js中,添加配置路由3.在topList.js文件中,处理配置路由函数代码4.在delete.js文件中,处理数据库代码 show.html 12将当前话题的id传入参数中&lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt; router.js 12345678910111213141516当请求删除标识时,执行对应的函数处理代码// 3.配置路由// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete);// 4.导出成员module.exports = router; fun/topList.js 1234567891011121314函数逻辑处理代码// 删除话题exports.delete = (req,res) =&gt; &#123; const topicID = req.params.topicID; deleteData.delete(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器出错了&apos; &#125;); &#125; res.redirect(&apos;/&apos;); &#125;);&#125; delete.js 123456789101112131415161718192021数据库处理代码//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.delete = (id,callback) =&gt; &#123; const sqlStr = &apos;delete from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 10.7 编辑话题-渲染页面show.html 1&lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/edit&quot;&gt;编辑&lt;/a&gt; router.js 1234567891011121314router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit);// 4.导出成员module.exports = router; topList.html 12345678910111213141516// 编辑话题exports.edit = (req,res) =&gt; &#123; const topicID = req.params.topicID; editData.edit(topicID,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code:500, msg: &apos;服务器出错了&apos; &#125;); &#125; 渲染编辑页面 res.render(&apos;topic/edit.html&apos;,&#123; topic: results[0] &#125;); &#125;);&#125; edit.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.edit = (id,callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; edit.html 12345678910111213&lt;form id=&quot;form&quot; action=&quot;/topic/edit&quot;&gt; &lt;!-- 表单隐藏域 --&gt; &lt;input type=&quot;hidden&quot; id=&quot;topic_id&quot; value=&quot;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;标题&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; name=&quot;title&quot; value=&quot;&#123;&#123;topic.title&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;content&quot;&gt;内容&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;content&quot; name=&quot;content&quot; rows=&quot;10&quot;&gt;&#123;&#123;topic.content&#125;&#125;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 10.8 编辑话题-处理表单客户端发送表单提交 edit.html 123456789101112131415161.获取id的方式可以在表单中添加隐藏项来设置topic.id2.可以在js中使用模板引擎获取id&lt;script&gt; $(&apos;#form&apos;).on(&apos;submit&apos;,function(e)&#123; var dataForm = $(this).serialize(); // var url = &quot;/topic/edit/&quot; + &#123;&#123;topic.id&#125;&#125;; var url = &quot;/topic/edit/&quot; + &quot;&#123;&#123;topic.id&#125;&#125;&quot;; $.post(url,dataForm,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/detail/topic/&#123;&#123;topic.id&#125;&#125;&apos;; &#125; &#125;); e.preventDefault(); &#125;);&lt;/script&gt; router.js 12345678910111213141516// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit) .post(&apos;/topic/edit/:topicID&apos;,topic.editHandle);// 4.导出成员module.exports = router; editHandle.js 1234567891011121314151617181920// 修改话题处理exports.editHandle = (req,res) =&gt; &#123; // 获取要修改的数据topicID const topicID = req.params.topicID; // 接收提交的数据 const body = req.body; // console.log(body); editHandle.editHandle(topicID,body,(error,results) =&gt; &#123; if(error)&#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; res.send(&#123; code: 200, msg: &quot;编辑成功&quot; &#125;); &#125;);&#125; topList.js 1234567891011121314151617181920//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.edit = (id,callback) =&gt; &#123; const sqlStr = &apos;select * from `topics` where id = ?&apos;; connection.query(sqlStr,id,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 11. 用户注册11.1 渲染注册页面signin.html 1&lt;p&gt;没有账号? &lt;a href=&quot;/signup&quot;&gt;点击创建&lt;/a&gt;.&lt;/p&gt; router.js 123456789101112131415161718// 3.配置路由// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit) .post(&apos;/topic/edit/:topicID&apos;,topic.editHandle) .get(&apos;/signup&apos;,user.signup);// 4.导出成员module.exports = router; user.js 1234// 渲染注册页面exports.signup = (req,res) =&gt; &#123; res.render(&apos;signup.html&apos;);&#125; 11.2 客户端发送表单请求signup.html 123456789$(&apos;#signup_form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signup&apos;,data,function(data)&#123; // console.log(data); &#125;); // 取消浏览器默认行为 // return false; e.preventDefault();&#125;); 11.3 服务端处理表单-获取表单数据router.js 12345678910111213141516171819202122// 3.配置路由// //渲染登录页面router.get(&apos;/login&apos;,user.login) //处理登录页面表单逻辑 .post(&apos;/signin&apos;,user.handleLogin) //渲染列表页面 .get(&apos;/&apos;,topic.list) .get(&apos;/topic/create&apos;,topic.createTopic) .post(&apos;/topic/create&apos;,topic.createTopicHandle) .get(&apos;/signout&apos;,user.signout) // /detail/topic/:topicID:如果标识是动态的，动态变化的部分用 :+形参表示 .get(&apos;/detail/topic/:topicID&apos;,topic.topicDetail) .get(&apos;/topic/:topicID/delete&apos;,topic.delete) .get(&apos;/topic/:topicID/edit&apos;,topic.edit) //话题编辑表单处理 .post(&apos;/topic/edit/:topicID&apos;,topic.editHandle) //注册页面请求 .get(&apos;/signup&apos;,user.signup) //注册页面表单处理 .post(&apos;/signup&apos;,user.signUpHandle);// 4.导出成员module.exports = router; user.js 123456//注册页面表单数据渲染exports.signUpHandle = (req,res) =&gt; &#123; //接收表单提交的数据 const body = req.body; console.log(body);&#125; 11.4 服务端处理表单-验证邮箱和昵称user.js 123接收注册表单提交的请求验证邮箱是否存在，如果不存在，则可以注册验证昵称是否存在，如果昵称不存在，则可以添加新用户 user.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//注册页面表单数据渲染exports.signUpHandle = (req,res) =&gt; &#123; const body = req.body; // console.log(body); // 验证邮箱的代码与登录一样 userLogin.checkForm(body.email,(error,results) =&gt; &#123; if(error) &#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; if(results[0]) &#123; return res.send(&#123; code: 1, msg: &quot;邮箱已存在&quot; &#125;); &#125; // 如果邮箱不存在，验证昵称 signUpHandle.signUpHandle(body.nickname,(error,results) =&gt; &#123; if(error) &#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; console.log(results); if(results[0]) &#123; return res.send(&#123; code: 2, msg: &quot;昵称已存在&quot; &#125;); &#125; // 验证完邮箱和昵称之后，把数据添加到数据库 signUpHandle.signUpData(body,(error,results) =&gt; &#123; if(error) &#123; return res.send(&#123; code: 500, msg: error.message &#125;); &#125; res.send(&#123; code: 200, msg: &quot;添加成功&quot; &#125;); &#125;); &#125;); &#125;);&#125; signUpHandle.js 1234567891011121314151617181920212223242526272829//mysql // 1.导包var mysql = require(&apos;mysql&apos;);// 2.配置mysqlvar connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;webkit&apos;&#125;);// 3.开启链接connection.connect();exports.signUpHandle = (data,callback) =&gt; &#123; const sqlStr = &apos;select * from `users` where nickname = ?&apos;; connection.query(sqlStr,data,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125;exports.signUpData = (data,callback) =&gt; &#123; const sqlStr = &apos;insert into `users` set ?&apos;; connection.query(sqlStr,data,(error,results) =&gt; &#123; if(error)&#123; callback(error); &#125; callback(null,results); &#125;);&#125; 11.5 客户端处理响应signup.html 1234567891011121314&lt;script&gt; $(&apos;#signup_form&apos;).on(&apos;submit&apos;,function(e)&#123; var data = $(this).serialize(); $.post(&apos;/signup&apos;,data,function(data)&#123; // console.log(data); if(data.code == 200)&#123; window.location.href = &apos;/login&apos;; &#125; &#125;); // 取消浏览器默认行为 // return false; e.preventDefault(); &#125;);&lt;/script&gt; 12. 处理中间件12中间件：是express框架的一个功能作用: 处理所有的请求和响应 12.1 中间件123456789101112131415161718191.搭建服务器const express = require(&apos;express&apos;);const app = express();需求: 想输出所有请求的请求方法和请求标识任何请求都会监听到,不限定请求标识app.use((req,res,next) =&gt; &#123; console.log(`$&#123;req.method&#125;,$&#123;req.path&#125;`); 调用next()方法:作用是把当前的请求交给下一个能匹配到的中间件继续处理 next();&#125;);app.get(&apos;/a&apos;,(req,res) =&gt; &#123; res.send(&apos;aaa&apos;);&#125;);app.get(&apos;/b&apos;,(req,res) =&gt; &#123; res.send(&apos;bbb&apos;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it---&apos;);&#125;); app.use 123456789app.use((req,res,next) =&gt; &#123; 处理当前请求并且执行下一个能匹配到的标识&#125;)next(): 把当前请求交给下一个能匹配到的中间件继续处理注意:app.use((req,res,next) =&gt; &#123;&#125;) 所有请求都会监听到next形参类型是函数 next()中间件的执行有顺序问题(从上到下一一匹配) 12.2 中间件-常用API方法123456781.处理所有请求app.use((req,res,next) =&gt; &#123;&#125;);2.处理标识为 /a 请求方式是get的请求app.get(&apos;/a&apos;,(req,res,next) =&gt; &#123;&#125;);3.处理标识为 /a 请求方式是post的请求app.post(&apos;/a&apos;,(req,res,next) =&gt; &#123;&#125;);4.处理标识以/a开头的所有请求 /a /a/b /abcapp.use(&apos;/a&apos;,(req,res,next) =&gt; &#123;&#125;); 12.3 中间件-执行顺序121.中间件的执行有顺序问题2.按照中间件写的位置从上到下一一匹配 app.js 123456789101112131415161718app.use((req,res,next) =&gt; &#123; console.log(`$&#123;req.method&#125;,$&#123;req.path&#125;`); 调用next()方法:作用是把当前的请求交给下一个能匹配到的中间件继续处理 next();&#125;);app.get(&apos;/a&apos;,(req,res) =&gt; &#123; res.send(&apos;aaa&apos;);&#125;);app.get(&apos;/b&apos;,(req,res) =&gt; &#123; res.send(&apos;bbb&apos;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it---&apos;);&#125;);1.没有next形参如果匹配 /a标识，只会执行app.use(),因为没有next()方法,告诉下面的请求2.有next形参如果匹配 /a标识，不仅执行app.use(),而且执行下面的app.get(&apos;/b&apos;,(req,res)=&gt; &#123;&#125;);next()会执行下面的请求 12.4 中间件-给req增加属性1231.在第一个中间件给req增加属性body2.在下一个能匹配到的中间件中使用req.body属性3.项目中的包 body-parser原理也是如此 app.js 1234567891011121314151617181920app.use((req,res,next) =&gt; &#123; console.log(`$&#123;req.method&#125;,$&#123;req.path&#125;`); 给req增加一个属性 req.obj = &#123; name = &apos;cheng&apos; &#125; 调用next()方法:作用是把当前的请求交给下一个能匹配到的中间件继续处理 next();&#125;);app.get(&apos;/a&apos;,(req,res) =&gt; &#123; 获取到req中的属性 console.log(req.obj); res.send(&apos;aaa&apos;);&#125;);app.get(&apos;/b&apos;,(req,res) =&gt; &#123; res.send(&apos;bbb&apos;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it---&apos;);&#125;); 12.5 中间件-next参数1234app.use((req,res,next) =&gt; &#123;&#125;);处理函数可以有三个参数，请求对象、响应对象、next函数1.next形参 是函数2.next(); 作用:把当前请求交给下一个能匹配到的中间件 12.6 中间件-模拟express-static方法的实现1234567891011121314151617181920const express = require(&apos;express&apos;);const fs = require(&apos;fs&apos;);const app = express();app.use((req, res, next) =&gt; &#123; const path = req.path; fs.readFile(&quot;./public&quot; + path, &quot;utf8&quot;, (err, data) =&gt; &#123; if (err) &#123; // throw err; // 如果代码来到这 证明当前文件读不到 /a -&gt; res.send(&quot;aaaa&quot;); return next(); &#125; res.send(data); &#125;);&#125;);app.get(&quot;/a&quot;, (req, res, next) =&gt; &#123; res.send(&quot;aaaaa&quot;);&#125;);app.listen(23456, () =&gt; &#123; console.log(&quot;run it----&quot;);&#125;); 1234567891011121314151617181920212223const express = require(&apos;express&apos;);const fs = require(&apos;fs&apos;);const app = express();function static(filepath) &#123; return (req, res, next) =&gt; &#123; const path = req.path; fs.readFile(filepath + path, &quot;utf8&quot;, (err, data) =&gt; &#123; if (err) &#123; // throw err; // 如果代码来到这 证明当前文件读不到 /a -&gt; res.send(&quot;aaaa&quot;); return next(); &#125; res.send(data); &#125;); &#125;&#125;app.use(static(&quot;./public&quot;));app.get(&quot;/a&quot;, (req, res, next) =&gt; &#123; res.send(&quot;aaaaa&quot;);&#125;);app.listen(23456, () =&gt; &#123; console.log(&quot;run it----&quot;);&#125;); 12.7 中间件-next()-传参数123456789101112131.next函数不传参数next()2.next传参数next()实参要求是错误对象next()如果传了实参是错误对象，会匹配处理函数有4个参数的中间件4个参数的中间件 app.use((error,req,res,next) =&gt; &#123;&#125;)4个参数的中间件 其中error指的是next()的实参错误对象3.js的代码块try&#123; 把可能出现的错误代码放在这块儿&#125;catch(error)&#123; 如果try中代码确实出错,catch形参error就是错误对象&#125; next实参 123456789101112try&#123; console.log(111); JSON.parse(&apos;saf;hslafhdslak;f&apos;); 错误代码&#125;catch(error)&#123; catch形参error就是try中代码的错误对象 console.log(222); next(error);&#125;处理函数中4个参数 (错误对象，请求对象，响应对象，next方法)app.use((error,req,res,next) =&gt; &#123; console.log(333);&#125;); 12.8 中间件作用和分类作用 12341.执行任何代码2.修改request或者response响应对象 给req增加任意一个属性3.调用下一个中间件 next()4.可以发送响应 res.send() 分类 12345应用程序级别中间件 app.use(express.static())路由级别中间件 express.Router()错误级别中间件 (err,req,res,next) =&gt; &#123;&#125;内置中间件 express.static()第三方中间件 body-parser express-session mogran serve-index 13. 项目13.1 统一处理-500-错误topList.html 123456789101112131415传入错误对象,如果出现错误,执行next(error);会匹配处理函数有4个参数的中间件// 渲染文章列表exports.list = (req,res,next) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return next(error); &#125; res.render(&apos;index.html&apos;,&#123; items: results, user: req.session.user // req.session.user session中的数据 &#125;); &#125;);&#125; app.js 12345678910// 3.配置路由// // //配置路由1.2 使用路由 实例化app.use(router);匹配这个中间件app.use((error,req,res,next) =&gt; &#123; res.send(&#123; code:500, msg:error.message &#125;);&#125;); 13.2 404页面的处理1234567891011121314151617// 3.配置路由// // //配置路由1.2 使用路由 实例化app.use(router);// 渲染404页面对于router.js文件中 匹配不到的标识，会进行如下请求// 处理所有请求，如果前面的配置路由请求不到，则进行如下渲染app.use((req,res,next) =&gt; &#123; res.render(&apos;404.html&apos;); next();&#125;);// 统一处理500错误的中间件app.use((error,req,res,next) =&gt; &#123; res.send(&#123; code:500, msg:error.message &#125;);&#125;); 13.3 请求日志1234567891011121314151617输出项目中所有的请求日志1.app.use(req,res,next) =&gt; &#123; console.log(req.method,req,path); next();&#125;);2.使用第三方来打印所有请求日志morgan:给所有功能输出日志1)安装 npm i morgan2）导入包 var morgan = require(&apos;morgan&apos;);3）配置 app.use(morgan(&apos;combined&apos;)); 或者 app.use(morgan(&apos;tiny&apos;)); 或者 app.use(morgan(&apos;:method :url :status :res[content-length] - :response-time ms&apos;)); 13.4 公共成员的使用1234app对象有一个属性locals,值类型是一个对象app.locals里面的成员num,num可以在页面文件中通过模板引擎的语法去使用app.locals.num = 100找html文件 &#123;&#123;num&#125;&#125; 123456将req.session中的数据保存在公共成员中app.localsapp.use((req,res,next) =&gt; &#123; app.locals.sessionUser = req.session.user; next();&#125;); user.js 1在模板引擎中，添加数据时，不需要user:req.session.user topList.js 12345678910111213exports.list = (req,res,next) =&gt; &#123; // 通过mysql获取列表数据 topList.showList((error,results) =&gt; &#123; if(error)&#123; return next(error); &#125; res.render(&apos;index.html&apos;,&#123; items: results // user: req.session.user // req.session.user session中的数据 &#125;); &#125;);&#125; header.html 1234567891011121314151617181920&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &#123;&#123;if sessionUser&#125;&#125; &lt;a class=&quot;btn btn-default navbar-btn&quot; href=&quot;/topic/create&quot;&gt;发起&lt;/a&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;&lt;img width=&quot;20&quot; height=&quot;20&quot; src=&quot;../public/img/avatar-max-img.png&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li class=&quot;dropdown-current-user&quot;&gt; 当前登录用户:&#123;&#123;sessionUser.nickname&#125;&#125; &lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;个人主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/settings/profile&quot;&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/signout&quot;&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;a class=&quot;btn btn-primary navbar-btn&quot; href=&quot;/login&quot;&gt;登录&lt;/a&gt; &lt;a class=&quot;btn btn-success navbar-btn&quot; href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &#123;&#123;/if&#125;&#125;&lt;/ul&gt; show.html 1234&#123;&#123;if topic.userId === sessionUser.id&#125;&#125; &lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/edit&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;/topic/&#123;&#123;topic.id&#125;&#125;/delete&quot; id=&quot;delete_topic&quot;&gt;删除&lt;/a&gt;&#123;&#123;/if&#125;&#125; 14. ES6-展开运算符数组 123456789101112131415161718192021222324252627281.const arr= [1,2,3];const temp = [...arr];console.log(temp); 1 2 32.拼接数组1）const arr = [1,2,3,4];const arr1 = [1,2,3,4,5];console.log(arr.concat(arr1));2）const arr = [1,2,3,4];const arr1 = [1,2,3,4,5];const arr2 = [...arr,...arr1];console.log(arr2);3.合并对象const per = &#123; name: &apos;zhangsan&apos;&#125;const per1 = &#123; age: 10&#125;const per2 = &#123; ...per, ...per1&#125;console.log(per2);4. 数组去重const arr = [1,2,2,3,3,6,5,5,5,4,4];const set = new Set(arr);console.log(set);Set集合 是ES6新数据类型 扩展链接12搜索网站 国内、国际 https://cn.bing.com自动格式化时间 momentjs.com 补充12windows wox+everything多窗口终端 windows conemu/cmd/Powershell/Xshell/cmder web扩展12345phoneGap打包|React-NativePC端:考虑各个浏览器 各个浏览器各个版本苹果安卓代码版本控制工具: git|svn 客户端发送表单请求12form: 默认提交 传数据 同步 整个页面都刷新ajax post 传数据 异步 页面局部刷新 页面重定向12服务端重定向： res.redirect(&apos;/&apos;); 只适用于同步请求(form表单)客户端重定向: window.location.href = &apos;&apos;; 适用于异步请求 比如说ajax请求 是异步的。这种方式不能服务端重定向，只能返回响应，让客户端重定向 GET和POST121.场景： get 查询 post:上传/添加2.安全性： post比get安全性好 POST:请求体 GET:URL中 文件扩充12.psd : ps切图文件.prd :产品需求文档 VSCode快捷键1234567选中相同代码 ctrl+D行尾行首来回跳 Fn + 左|右选中一个单词 ctrl+shift+左|右垂直方向选中 ctrl+alt+上关闭目录 ctrl+b分屏 ctrl+alt+左|右到文件所在目录 shift+alt+r]]></content>
  </entry>
  <entry>
    <title><![CDATA[promise知识点]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F26%2Fpromise%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Promise语法1. Promise使用123Promise是一个构造函数,既然是构造函数,那么我们就可以new Promise()得到一个Promise的实例在Promise上,有两个函数,分别叫做resolve(成功之后的回调)和reject(失败之后的回调)在Promise构造函数的Promise函数的Prototype属性上,有一个.then()方法,也就是说,只要Promise构造函数创建的实例,都可以访问到.then()方法 1234567891011121314151617var fs = require(&apos;fs&apos;);// new Promise是一个构造函数 对象本身不是异步的,里面的任务是异步的console.log(1);const p1 = new Promise(function(resolve)&#123; console.log(2); // 此处是异步的 fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; throw err; &#125;else&#123; console.log(3); console.log(data); &#125; &#125;); &#125;);console.log(4);打印结果是: 1 2 4 3 文件中的数据aaa 2. then方法1234567891011121314151617181920212223var fs = require(&apos;fs&apos;);// new Promise是一个构造函数 对象本身不是异步的,里面的任务是异步的const p1 = new Promise(function(resolve,reject)&#123; // 此处是异步的 fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; // 异步任务失败执行 // throw err; reject(err); &#125;else&#123; // 异步任务成功执行 resolve(data); &#125; &#125;);&#125;);p1.then(function(data)&#123; // function就是容器中的resolve函数 // 异步任务成功执行的函数就是这个函数 console.log(data);&#125;,function(err)&#123; // 异步任务失败执行此方法 console.log(err);&#125;); 3. 总结123456789101112131415var fs = require(&apos;fs&apos;);var p1 = new Promise(function(resolve,reject)&#123; fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; reject(err); 异步任务失败执行 reject &#125;else&#123; resolve(data); 异步任务成功执行 resolve &#125; &#125;);&#125;);p1.then(function(data)&#123; console.log(data); 异步任务成功 resolve()函数&#125;,function(err)&#123; console.log(err); 失败reject函数&#125;) 4. 返回Promise对象123456789101112131415161718192021222324252627282930313233343536373839404142434445var fs = require(&apos;fs&apos;);// new Promise是一个构造函数 对象本身不是异步的,里面的任务是异步的const p1 = new Promise(function(resolve,reject)&#123; // 此处是异步的 fs.readFile(&apos;./aaa.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; // 异步任务失败执行 // throw err; reject(err); &#125;else&#123; // 异步任务成功执行 resolve(data); &#125; &#125;);&#125;);const p2 = new Promise(function(resolve,reject)&#123; // 此处是异步的 fs.readFile(&apos;./bbb.txt&apos;,&apos;utf8&apos;,function(err,data)&#123; if(err)&#123; // 异步任务失败执行 // throw err; reject(err); &#125;else&#123; // 异步任务成功执行 resolve(data); &#125; &#125;);&#125;);p1.then(function(data)&#123; // function就是容器中的resolve函数 // 异步任务成功执行的函数就是这个函数 // console.log(data); // 当前函数return到的结果可以在后面then中function接收到 // return 123; // 当return的是一个Promise对象时,后面的then中的方法的第一个参数会作为p2对象的resolve函数调用 return p2;&#125;,function(err)&#123; // 异步任务失败执行此方法 console.log(err);&#125;).then(function(data)&#123; console.log(data); //bbb&#125;,function(err)&#123; console.log(err);&#125;); 1234567891011121314如果前面的函数执行失败了,不想影响后面函数的执行p1.then(function(data)&#123; console.log(data); return p2;&#125;,function(err)&#123; // 异步任务失败执行此方法 console.log(err); return p2; 返回该对象之后，会继续执行下面的代码&#125;).then(function(data)&#123; console.log(data); //bbb&#125;,function(err)&#123; console.log(err);&#125;); 1234567891011121314151617181920如果前面的函数执行失败了,立即结束所有后续函数的执行p1.then(function(data)&#123; console.log(data); return p2;&#125;,function(err)&#123; // 异步任务失败执行此方法 如果不想前面文件失败结束后面代码的执行,那么需要给文件添加失败的回调，返回一个新的promise对象 console.log(err); return p2; 返回该对象之后，会继续执行下面的代码&#125;).then(function(data)&#123; console.log(data); //bbb&#125;,function(err)&#123; console.log(err);&#125;)不管前面哪个then执行失败,都会立即结束后续代码执行,进入到这个catch函数catch作用: 如果前面有任何的Promise执行失败,则立即终止所有Promise的执行,并马上进入catch去处理Promise中抛出的异常.catch(function(err)&#123; console.log(err);&#125;); 5. 封装文件的回调123456需求: 封装一个方法,要读取文件的路径const fs = require(&apos;fs&apos;);fs.readFile(&apos;a.txt&apos;,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err console.log(data);&#125;); file.js 12345678const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err console.log(data); &#125;);&#125;getFile(&apos;a.txt&apos;); file1.js 123456789const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err return data; &#125;); 没有return,返回的是undefined&#125;console.log(getFile(&apos;a.txt&apos;)); undefined file2.js 12345678910const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) throw err callback(data); &#125;);&#125;getFile(&apos;a.txt&apos;,(data) =&gt; &#123; console.log(data);&#125;); file3.js 1234567891011const fs = require(&apos;fs&apos;);function getFile(fPath)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) return callback(err) callback(null,data); &#125;);&#125;getFile(&apos;a.txt&apos;,(err,data) =&gt; &#123; if(err) return console.log(err) console.log(data);&#125;); file4.js 123456789101112const fs = require(&apos;fs&apos;);function getFile(fPath,callbackErr,callbackSuc)&#123; fs.readFile(fPath,&apos;utf-8&apos;,(err,data) =&gt; &#123; if(err) return callbackErr(err) callbackSuc(data); &#125;);&#125;getFile(&apos;a.txt&apos;,(err) =&gt; &#123; console.log(&apos;失败了&apos;);&#125;,(data) =&gt; &#123; console.log(&apos;成功了&apos;);&#125;); 6. 回调地狱1234567891011先读取文件1,再读取文件2,再读取文件3getFile(&apos;file1.txt&apos;,funciton(data)&#123; console.log(data); getFile(&apos;file2.txt&apos;,funciton(data)&#123; console.log(data); getFile(&apos;file3.txt&apos;,funciton(data)&#123; console.log(data); &#125;); &#125;);&#125;);使用ES6中的Promise来解决回调地狱的问题 7. jQuery中的Promise123456789101112$(function()&#123; $(&apos;#btn&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url: &apos;&apos;, type: &apos;get&apos;, dataType: &apos;json&apos; &#125;) .then(function(data)&#123; console.log(data); &#125;); &#125;);&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[ajax知识点]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F26%2Fajax%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ajax1.ajax请求xml数据12345678910111213141516171819202122232425262728293031323334353637如果ajax发送请求，后台返回的是xml数据，那么需要在后台返回数据时，声明返回的是xml数据。.xml&lt;root&gt; &lt;name&gt;小明&lt;/name&gt; &lt;age&gt;20&lt;/age&gt;&lt;/root&gt;.php&lt;php&gt; 接收提交的数据 声明返回的是什么类型的数据 编码格式是什么 header(&apos;content-type:text/xml;charset=utf-8&apos;) 读取.xml文件中的数据 $data = filr_get_content(&apos;文件名.xml&apos;); echo $data;&lt;/php&gt;.html document.querySelector(&apos;id&apos;).onclick = function()&#123; 1.创建异步对象 var xhr = new XMLhttpRequest(); 2.设置请求行 xhr.open(&apos;get&apos;,&apos;.php&apos;); 3.post请求设置请求体 4.注册状态改变事件 xhr.onreadyStatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; status == 200 )&#123; console.log(xhr.responseText); 接收返回的字符串 console.log(xhr.responseXML); 接收返回的xml #document 解析XML console.log(xhr.responseXML.querySelector(&apos;name&apos;)); &lt;name&gt;小明&lt;/name&gt; console.log(xhr.responseXML.querySelector(&apos;name&apos;).innerText); 小明 &#125; &#125; 5.发送请求 xhr.send(null); &#125;; xml：缺点： 数据传输量大 2. ajax请求json数据12345678910111213141516json是一种数据的格式json的载体是字符串基本上所有语言都支持JSON语法简洁 基本上所有的语言 都提供了对应的方法 来解析jsonjson: 属性名和值都必须使用&quot;&quot;包裹，如果属性值是数组，可以不使用双引号json字符串转化为数据/对象var jsonStr = &apos;&#123;&quot;&quot;:&quot;&quot;,&quot;&quot;:&quot;&quot;&#125;&apos;var obj = JSON.parse(json字符串); 转化为对应的数组/对象将响应的结果转化为json对象var arr = JSON.parse(xhr.responseText);console.log(arr);.php设置服务器返回的格式header(&apos;content-type:application/json;charset=utf-8&apos;);$str = file_get_content(&apos;.json&apos;);echo $str; 3. 模板引擎的使用123456789101.引入文件2.定义模板&lt;script type=&apos;text/template&apos; id=&apos;template&apos;&gt; &#123;&#123;name&#125;&#125;&lt;/script&gt;var json = &#123; name: &quot;&quot;&#125;var data = template(&apos;template&apos;,json);document.body.innerHTML(data); 4. jsonp的使用1234567891011jsonp在线接口测试:http://api.asilu.com/#geo在线工具：https://www.sojson.com/api/$(&apos;input&apos;).click(function()&#123; $.ajax(&#123; url: &quot;&quot;, success: function(data)&#123; console.log(data); &#125;, dataType: &apos;jsonp&apos; &#125;);&#125;); 5. 模板引擎原理1234567891011121314151617181920211.通过id获取模板中的内容2.找到字符串中特殊符号 &#123;&#123;name&#125;&#125;3.使用字符串中特殊符号进行替换4.返回字符串&lt;script&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/script&gt;var str = document.querySelector(&apos;#template&apos;).innerHtml;var data = &#123; name:&apos;&apos;， skill:&apos;&apos;&#125;var reg = /&#123;&#123;(\w+)&#125;&#125;g/;var result = reg.exec(str);替换：while(result)&#123; str = str.replace(result[0],data[result[0]]); result = reg.exec(str);&#125; 12345var str = &apos;ssssahfsdha&#123;&#123;name&#125;&#125;sdaf &#123;&#123;age&#125;&#125;&apos;;var reg = /&#123;&#123;\w+&#125;&#125;/;console.log(reg.exec(str));reg.test(str):返回值是布尔类型reg.exec(str); 返回值是被检索到的值，没有返回null 6. 模板引擎补充1234567891011条件: &#123;&#123;if name ===&apos;&apos;&#125;&#125; &#123;&#123;else if&#125; &#123;&#123;/if&#125;&#125;循环: &#123;&#123;each arr&#125;&#125; &#123;&#123;$index&#125;&#125;&#123;&#123;$vale&#125;&#125; 键－值 &#123;&#123;&#125;&#125;原文输出： 输出链接 &#123;&#123;@name&#125;&#125; 7. 瀑布流插件 masonry12345678https://masonry.desandro.com/ github masonry瀑布流插件(堆糖网站): 宽度一样高度不一样步骤: github下载文件 https://masonry.desandro.com1.下载并引入2.引入结构HTML3.设置布局 CSS4.引入jQuery文件和插件js 5.初始化 8. 同源跨域概念123同源：协议 地址 IP号全都相同只要有一个不一样就叫跨域跨域报错： Access-control-Allow-Origin 9. 解决同源的办法123456789101112131415161.jsonp JSONP就是利用src属性 支持跨域获取资源 script:src img src index.html &lt;script&gt; fucntion doSomething(data)&#123; console.log(data); &#125; &lt;/script&gt; &lt;script src=&apos;http:127.168.10.12/addData.php?callback=doSomething&apos;&gt; addData.php: &lt;?php $something = $_GET[&apos;callback&apos;]; echo $Something.&apos;(&#123;&quot;name&quot;:&quot;jack&quot;&#125;)&apos; ?&gt;2.cros 后台程序员设置 header(&apos;Access-control-Allow-Origin:*&apos;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端vue项目]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F25%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFvue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1. 项目123456789101112131415161718192021222324252627mysql 打开后台服务器创建项目: vue init webpack mobile 设置项目运行后自动打开浏览器 在package.json文件中配置,加--open自动打开浏览器 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js --open&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;使用git管理项目: 添加文件 .gitignore node_modules .idea .vscode .git readme.md LICENSE:开源协议 开源协议之间的区别 git init 初始化本地仓库 git status git add . git commit -m &quot;初始化项目&quot; 本地仓库 提交到远程仓库 与远程仓库建立连接 git remote add origin 链接 git push -u origin master 1.1 制作项目首页的header和Tabbar区域12345678按需导入Mint-ui中的组件header: Mint-UI 中的 CSS Comonents中的header import MintUI from &apos;mint-ui&apos; import &apos;../node_modules/mint-ui/lib/style.css&apos; Vue.use(MintUI)Tabbar: Mui中的Tabbar import &apos;@/assets/css/mui.min.css&apos; import &apos;@/assets/css/icons-extra.css&apos; App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561.header部分 引入:mian.js import &#123; Header &#125; from &apos;mint-ui&apos;; Vue.component(Header.name, Header); 使用: &lt;mt-header fixed title=&quot;固定在顶部&quot;&gt;&lt;/mt-header&gt;2.中间部分3.tabbar部分 导入样式 import &apos;./lib/mui/css/mui.min.css&apos; 导入tabbar结构4.代码实现 &lt;template&gt; &lt;div id=&quot;app&quot; class=&apos;home&apos;&gt; &lt;mt-header fixed title=&quot;小桃优惠App&quot;&gt;&lt;/mt-header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;nav class=&quot;mui-bar mui-bar-tab&quot;&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/home&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-home&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;首页&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/class&apos;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-class&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;分类&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/chat&apos;&gt; &lt;span class=&quot;mui-icon mui-icon mui-icon-chat&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;桃粉圈&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/cart&apos;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-cart&quot;&gt;&lt;span class=&quot;mui-badge&quot;&gt;9&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;购物车&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&apos;/contact&apos;&gt; &lt;span class=&quot;mui-icon mui-icon-contact&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;我的&lt;/span&gt; &lt;/router-link&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &apos;App&apos;, data()&#123; return &#123; selected: [] &#125; &#125; &#125; &lt;/script&gt; &lt;style&gt; .home &#123; padding-top: 40px; &#125; &lt;/style&gt;注意：在配置tab图标时,需要引入 扩展图标的样式和字体 问题12345678910111213141516171819202122解决mui在严格模式下不支持问题导入mui的js和css文件之后,会报如下错误Uncaught TypeError: &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.d.extend (mui.min.js?5414:7)解决办法:在.babelrc文件下,配置如下代码即可,排除掉mui.js文件&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125; &#125;], &quot;stage-2&quot; ], &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;], 添加的配置 &quot;ignore&quot;: [ &quot;./src/assets/dist/js/mui.min.js&quot; ]&#125; 1.2 修改tabbar图标1234567mui扩展图标引入mui扩展样式引入扩展图标和字体文件 &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/cart&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-cart&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;购物车&lt;/span&gt; &lt;/router-link&gt; 1.3 配置路由1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556引入路由router.jsimport Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Home from &apos;@/components/home.vue&apos;import Class from &apos;@/components/class.vue&apos;import Chat from &apos;@/components/chat.vue&apos;import Cart from &apos;@/components/cart.vue&apos;import Contact from &apos;@/components/contact.vue&apos;Vue.use(Router)const router = new Router(&#123; 配置路由高亮 linkActiveClass: &apos;mui-active&apos;, //覆盖默认的路由高亮的样式，默认的类样式是 router-link-active routes: [ &#123; name: &apos;home&apos;, path: &apos;/home&apos;, component: Home &#125;, &#123; name: &apos;class&apos;, path: &apos;/class&apos;, component: Class &#125;, &#123; name: &apos;chat&apos;, path: &apos;/chat&apos;, component: Chat &#125;, &#123; name: &apos;cart&apos;, path: &apos;/cart&apos;, component: Cart &#125;, &#123; name: &apos;contact&apos;, path: &apos;/contact&apos;, component: Contact &#125; ]&#125;)export default router;main.jsimport router from &apos;./router.js&apos;var vm = new Vue(&#123; el: &apos;#app&apos;, router&#125;);路由连接的改造和路由高亮 修改tabbar为router-link to 设置路由高亮 linkActiveClass: &apos;router-link-active&apos;实现tabbar路由组件切换功能 在router.js文件中根据标识引入对应的组件注意修改：页面的样式,否则看不要效果 padding-top: 40px;新建组件 1.4 轮播图12345678910111213mint-ui组件Swipe: https://cloud.tencent.com/developer/section/1489968参考文档import &#123; Swipe, SwipeItem &#125; from &apos;mint-ui&apos;;Vue.component(Swipe.name, Swipe);Vue.component(SwipeItem.name, SwipeItem);&lt;mt-swipe :auto=&quot;4000&quot;&gt; &lt;mt-swipe-item&gt;1&lt;/mt-swipe-item&gt; &lt;mt-swipe-item&gt;2&lt;/mt-swipe-item&gt; &lt;mt-swipe-item&gt;3&lt;/mt-swipe-item&gt;&lt;/mt-swipe&gt;轮播图需要手动设置高度 1234567891011121314151617使用scss设置样式&lt;style lang=&apos;scss&apos; scoped&gt; .mint-swope &#123; height: 200px; .mint-swipe-item &#123; &amp;:nth-child(1)&#123; background-color: red; &#125; &amp;:nth-child(2)&#123; background-color: yellow; &#125; &amp;:nth-child(3)&#123; background-color: cyan; &#125; &#125; &#125;&lt;/style&gt; 1234567891011121314151617181920212223发送请求获取数据,将数据保存在数组中，轮播图遍历数组安装 axios 导入 使用npm i axios// 导入axiosimport axios from &apos;axios&apos;Vue.prototype.$http = axios;获取数据// 获取轮播图数据async getData()&#123; const res = await this.$http.get(`/api/getlunbo`); console.log(res.body); if(res.body.status === 200)&#123; this.lunboList = res.body.message; &#125;else&#123; Toast(&apos;获取数据失败&apos;); &#125;&#125;渲染轮播图页面&lt;mt-swipe :auto=&quot;4000&quot;&gt; &lt;mt-swipe-item v-for=&apos;(item,i) in lunboList&apos; :key=&apos;i&apos;&gt; &lt;img :src=&apos;item.src&apos; url=&apos;item.url&apos; alt=&apos;&apos;&gt; &lt;/mt-swipe-item&gt;&lt;/mt-swipe&gt; vue中使用axios跨域解决:跨域请求代理1234567891011121.打开config/index.jsproxyTable: &#123; 配置一下代码 &apos;/api&apos;: &#123; target: &apos;http://121.41.130.58:9090&apos;,//设置你调用的接口域名和端口号 别忘了加http changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos;//这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替 比如我要调用&apos;http://40.00.100.100:3002/user/add&apos;，直接写‘/api/user/add’即可 &#125; &#125;&#125;2.注意不要全局配置：axios.defaults.baseURL = &apos;http://vue.studyit.io&apos;; 一定不要配置这个 1.5 九宫格123456789101112131415161718192021222324252627mui/examples/hello-mui/examples/grid-default.htmlWW&lt;ul class=&quot;mui-table-view mui-grid-view mui-grid-9&quot;&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu1.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;新闻资讯&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu2.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;图片分享&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu3.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;商品购买&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu4.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;留言反馈&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu5.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;视频专区&lt;/div&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt;&lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;../assets/image/menu6.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;联系我们&lt;/div&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 1.6 中间main区域动画切换12345678910111213141516171819202122&lt;transtion&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;.v-enter &#123; opacity: 0; transform: translateX(100%);&#125;.v-leave-to &#123; opacity: 0; transform: translateX(-100%); position: absolute;&#125;.v-enter-active,.v-leave-active &#123; transition: all 0.5s ease;&#125;解决滚动条问题:.app-container &#123; padding-top: 40px; overflow-x: hidden;&#125; 点击tabbar区域实现动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div id=&quot;app&quot; class=&apos;home&apos;&gt; &lt;mt-header fixed title=&quot;小桃优惠App&quot;&gt;&lt;/mt-header&gt; &lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;nav class=&quot;mui-bar mui-bar-tab&quot;&gt; &lt;router-link class=&quot;mui-tab-item mui-active&quot; to=&quot;/tabbar&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-home&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;首页&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/search&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-search&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;搜索&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/cart&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-extra mui-icon-extra-cart&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;购物车&lt;/span&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; to=&quot;/contact&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-contact&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;个人&lt;/span&gt; &lt;/router-link&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;App&apos;, data()&#123; return &#123; selected: [] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .home &#123; padding-top: 40px; overflow-x: hidden ; &#125; .v-enter &#123; opacity: 0; transform: translateX(100%); &#125; .v-leave-to &#123; opacity: 0; transform: translateX(-100%); position: absolute; &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.2s ease; &#125;&lt;/style&gt; 2. 使用git管理项目1234567891011121314151617.gitignore 忽略文件 node_modules .idea webstorm 生产的 默认配置 .vscode vscode配置 .gitreadme.mdLICENSE:开源协议管理项目: git config --global user.name &apos;&apos; git config --global user.email &apos;&apos; git init git status git add . git status git commit -m &quot;&quot; git remote add origin 链接 与远程仓库链接 git push -u origin master 3. 点击新闻资讯跳转到列表页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811.新闻资讯 a修改为router-link to2.配置路由 新建组件3.&lt;li class=&quot;mui-table-view-cell mui-media mui-col-xs-4 mui-col-sm-4&quot;&gt; &lt;router-link to=&apos;/home/newList&apos;&gt; &lt;img src=&quot;../assets/image/menu1.png&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt;新闻资讯&lt;/div&gt; &lt;/router-link&gt;&lt;/li&gt;4.创建组件 使用mui组件的列表 media-list &lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;ul class=&quot;mui-table-view&quot;&gt; &lt;li class=&quot;mui-table-view-cell mui-media&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;../assets/image/shuijiao.jpg&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; 幸福 &lt;p class=&apos;mui-ellipsis&apos;&gt; &lt;span&gt;发表时间: 2017年7月2日&lt;/span&gt; &lt;span&gt;点击次数: 5次&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; &#125; &lt;/script&gt; &lt;style&gt; .main &#123; padding-top: 40px; &#125; .mui-ellipsis &#123; display: flex; justify-content: space-between; &#125; &lt;/style&gt;5.配置路由import NewList from &apos;@/components/newList.vue&apos;&#123; name: &apos;newList&apos;, path: &apos;/home/newList&apos;, component: NewList&#125;6.获取数据渲染界面&lt;li class=&quot;mui-table-view-cell mui-media&quot; v-for=&apos;(item,i) in newsList&apos; :key=&apos;i&apos;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; :src=&quot;item.img_url&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;p class=&apos;mui-ellipsis&apos;&gt; &lt;span&gt;发表时间: &#123;&#123;item.add_time&#125;&#125;&lt;/span&gt; &lt;span&gt;点击次数: &#123;&#123;item.click&#125;&#125;次&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/a&gt;&lt;/li&gt;export default &#123; data()&#123; return &#123; newsList: [] &#125; &#125;, mounted()&#123; this.getData(); &#125;, methods: &#123; async getData()&#123; const res = await this.$http.get(`/api/getnewslist`); console.log(res); this.newsList = res.data; &#125; &#125;&#125;7.格式化时间 4. 详情页12345678910111213141516171819202122232425261.修改组件样式： 修改router-link to &lt;li class=&quot;mui-table-view-cell mui-media&quot;&gt; &lt;router-link :to=&quot;&apos;/home/newlist/&apos; + item.id&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;../assets/image/shuijiao.jpg&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; 幸福 &lt;p class=&apos;mui-ellipsis&apos;&gt; &lt;span&gt;发表时间: 2019.09.09&lt;/span&gt; &lt;span&gt;点击次数: 4次&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/router-link r&gt; &lt;/li&gt;2.配置路由&#123; path: &apos;/home/newList/:id&apos;, component: Detial&#125;3.组件中获取传过来的id$route.params.iddata()&#123; return &#123; id: this.$route.params.id //将url地址中传递过来的值挂载到data数据中 &#125;&#125;4.获取数据渲染组件 5. 评论组件1封装成一个子组件,在需要的地方引入]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决sublime无法安装package control问题]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F25%2F%E8%A7%A3%E5%86%B3sublime%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85package-control%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[###解决sublime无法安装package control问题 12345手动安装的,其他的方法试了但不可以,成功的方法记录一下1.先下载https://github.com/wbond/sublime_package_control中的zip文件，解压后将文件夹名更改为package control2.将解压的文件放在 preferences/Browse-packages/package Control文件夹下即Sublime\Data\Packages\Package Control下3.重启sublime即可看到成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类参数]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F20%2F%E5%88%86%E7%B1%BB%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[###分类参数 1. 导航栏配置标识1&lt;el-menu-item index=&quot;params&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;分类参数&lt;/el-menu-item&gt; 2. 配置路由123456789101112131415161718192021222324252627282930313233343536373839import Vue from &apos;vue&apos;import vueRouter from &apos;vue-router&apos;Vue.use(vueRouter);import Home from &apos;@/components/home.vue&apos;import Params from &apos;@/components/params.vue&apos;import &#123;Message&#125; from &apos;element-ui&apos;const router = new vueRouter(&#123; routes: [ &#123; name: &apos;home&apos;, path: &apos;/&apos;, component: Home, children: [ &#123; name: &apos;params&apos;, path: &apos;/params&apos;, component: Params &#125; ] &#125; ]&#125;); 路由钩子函数 路由拦截router.beforeEach((to,from,next) =&gt; &#123; if(to.name === &apos;login&apos;)&#123; next(); &#125;else&#123; if(!window.localStorage.getItem(&apos;token&apos;))&#123; // 提示消息 Message.warning(&apos;请先登录&apos;); router.push(&#123; name: &apos;login&apos; &#125;); &#125;else&#123; next(); &#125; &#125;&#125;);export default router; 3. 组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;head-bread level1=&apos;商品管理&apos; level2=&apos;分类参数&apos;&gt;&lt;/head-bread&gt; &lt;el-alert title=&quot;注意只允许为第三级分类设置参数&quot; type=&quot;info&quot; show-icon&gt; &lt;/el-alert&gt; &lt;el-form label-position=&quot;left&quot; v-model=&apos;form&apos;&gt; &lt;el-form-item label=&quot;请选择分类&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-tabs type=&quot;border-card&quot; v-model=&apos;active&apos;&gt; &lt;el-tab-pane active=&apos;1&apos; label=&quot;动态参数&quot;&gt; &lt;el-button type=&apos;primary&apos;&gt;设置动态参数&lt;/el-button&gt; &lt;el-table :data=&quot;tableData&quot; stripe height=&apos;300px&apos; style=&quot;width: 100%&quot;&gt; &lt;el-table-column type=&apos;extend&apos; label=&apos;#&apos; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;属性名称&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&apos;small&apos; icon=&quot;el-icon-edit&quot; circle @click=&apos;edit(scope.row.goods_id)&apos;&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&apos;small&apos; icon=&quot;el-icon-delete&quot; circle @click=&apos;del(scope.row.goods_id)&apos;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;静态参数&quot;&gt; &lt;el-button active=&apos;2&apos; type=&apos;primary&apos;&gt;设置静态参数&lt;/el-button&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/div&gt;&lt;/template&gt; 4. 获取数据1231.选中三级分类,并且选中的是第一个tab栏时获取数据2.选中的是第一个tab栏时,并且三级分类的长度为3时获取动态数据3.选中的是第二个tab栏时,并且三级分类的长度为3时获取静态数据 5. 处理tag标签可删除可添加123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;el-table-column type=&apos;expand&apos; label=&apos;#&apos; width=&quot;180&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-tag :key=&quot;i&quot; v-for=&quot;(item,i) in scope.row.attr_vals&quot; closable :disable-transitions=&quot;false&quot; @close=&quot;handleClose(scope.row,item)&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/el-tag&gt; &lt;el-input class=&quot;input-new-tag&quot; v-if=&quot;inputVisible&quot; v-model=&quot;inputValue&quot; ref=&quot;saveTagInput&quot; size=&quot;small&quot; @keyup.enter.native=&quot;handleInputConfirm(scope.row)&quot; @blur=&quot;handleInputConfirm(scope.row)&quot; &gt; &lt;/el-input&gt; &lt;el-button v-else class=&quot;button-new-tag&quot; size=&quot;small&quot; @click=&quot;showInput&quot;&gt;+ New Tag&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt;export default &#123; data()&#123; return &#123; form: &#123;&#125;, // 三级分类的数据 options: [], // 选中值的id值 selectedOptions2: [], // 级联选择器配置 defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, active: &apos;1&apos;, arrDy: [], inputVisible: false, inputValue: &apos;&apos; &#125; &#125;, created()&#123; this.getGoods(); &#125;, methods: &#123; // 回车或者失去焦点触发的事件 handleClose(vals,tag) &#123; vals.attr_vals.splice(vals.attr_vals.indexOf(tag), 1); &#125;, showInput() &#123; this.inputVisible = true; this.$nextTick(_ =&gt; &#123; this.$refs.saveTagInput.$refs.input.focus(); &#125;); &#125;, handleInputConfirm(vals) &#123; let inputValue = this.inputValue; if (inputValue) &#123; vals.attr_vals.push(inputValue); &#125; this.inputVisible = false; this.inputValue = &apos;&apos;; &#125;, // tab切换时 tabChange()&#123; if(this.active === &apos;1&apos; &amp;&amp; this.selectedOptions2.length === 3)&#123; this.getArrDy(); &#125; &#125;, //获取动态参数的数据 async getArrDy()&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; // 处理动态数据中的attr_vals属性 变成一个数组 this.arrDy.forEach(function(item)&#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;, // 级联选择器改变时 获取数据 handleChange()&#123; if(this.selectedOptions2.length === 3 &amp;&amp; this.active === &apos;1&apos;)&#123; this.getArrDy(); &#125; &#125;, // 页面加载完毕获取三级分类的数据 async getGoods()&#123; const res = await this.$http.get(`categories?type=3`); // console.log(res); this.options = res.data.data; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .el-alert &#123; margin: 20px 0; &#125; .el-tabs &#123; margin-top: 10px; &#125; .el-tag + .el-tag &#123; margin-left: 10px; &#125; .button-new-tag &#123; margin-left: 10px; height: 32px; line-height: 30px; padding-top: 0; padding-bottom: 0; &#125; .input-new-tag &#123; width: 90px; margin-left: 10px; vertical-align: bottom; &#125;&lt;/style&gt; 6. 动态参数-动态编辑-发送请求12345678910111213141516171819async handleInputConfirm(vals) &#123; let inputValue = this.inputValue; if (inputValue) &#123; vals.attr_vals.push(inputValue); // 发送请求修改数据 const putData = &#123; attr_name: attr.attr_name, attr_sel: attr_sel, attr_vals: attr_vals.join(&apos;,&apos;); &#125; const res = await this.$http.put(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes/$&#123;attr.attr_id&#125;`,putData); console.log(res); &#125; this.inputVisible = false; this.inputValue = &apos;&apos;;&#125;问题一:接口中参数错误问题二:接口中请求参数中attr_vals类型为数组 应该是字符串 扩展12消息推送: 手机软件接收到消息-&gt;app或者网站-&gt;第三方sdk-&gt;友盟(RN/混合app)/share SDK实现分享功能: www.mob.com 社会化分享功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[商品管理]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F19%2F%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[###商品管理 1. 商品列表1234561.添加标识 :/goods 配置路由: &#123;name: &apos;goods&apos;, path: &apos;/goods&apos;, component: ()=&gt;require(&apos;@assets/components/Goods&apos;)&#125; 渲染组件: 面包屑／搜索框／表格 实现功能： 渲染列表／实现商品的删除和修改 1.1 增加商品功能1234添加标识 :/goodsadd配置路由 &#123;name: &apos;goodsadd&apos;, path: &apos;/goodsadd&apos;, component: ()=&gt;require(&apos;@assets/components/Goodsadd&apos;)&#125;渲染组件: 面包屑／alert警告/步骤条／tab栏切换 1.2 实现tab栏切换123456789101112131415161718192021222324点击基本信息－－－－－渲染表单 添加商品的基本信息级联选择器:&lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;options&quot; 级联选择器的数据 v-model=&quot;selectedOptions2&quot; 级联选择器选中项的id号 :props = &quot;defaultProp&quot; 默认配置项 @change=&quot;handleChange&quot;&gt; 级联选择器改变时触发&lt;/el-cascader&gt; data()&#123; return &#123; options: [], selectedOptions2: [], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125; &#125;&#125;页面加载完毕请求数据获取级联选择器的数据const res = await this.$http.get(`categories?type=3`);// console.log(res);this.options = res.data.data; 1.3 商品参数123456789101112131415161718192021222324252627282930311.3.1 当点击的是tab栏的第二项时,判断级联选择器选中的数组的长度是不是等于3,如果tab选中的是第二项并且级联选择器的长度等于3,发请求获取动态参数的数据,否则提示用户选择级联选择器@tab-click = &apos;changeTab()async changeTab()&#123; if(this.active == &quot;2&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; this.arrDy.forEach(function(item)&#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125;&#125;1.3.2根据获取的动态参数的数据 渲染商品参数的数据 复选框 &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrDy&quot; :key=&apos;i&apos;&gt; &lt;el-checkbox-group v-model=&quot;item.attr_vals&quot;&gt; &lt;el-checkbox :label=&quot;item1&quot; border size=&quot;medium&quot; v-for=&quot;(item1,i) in item.attr_vals&quot; :key=&apos;i&apos;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt;1.3.3 默认复选框全选中v-model绑定的是所有选中的复选框的label值 而item.attr_vals是所有的复选框的值&lt;el-checkbox-group v-model=&quot;item.attr_vals&quot;&gt; &lt;el-checkbox v-model=&quot;checked&quot; :label=&quot;item1&quot; border size=&quot;medium&quot; v-for=&quot;(item1,i) in item.attr_vals&quot; :key=&apos;i&apos;&gt;&lt;/el-checkbox&gt;&lt;/el-checkbox-group&gt; 1.4 商品属性-获取静态参数12345678910111213141516171.4.1当点击的是tab栏的第三项时,判断级联选择器选中的数组的长度是不是等于3,如果tab选中的是第三项并且级联选择器的长度等于3,发请求获取静态参数的数据,否则提示用户选择三级分类if(this.active == &quot;3&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125;1.4.2 渲染组件&lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrStatic&quot; :key=&apos;i&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;/el-tab-pane&gt; 1.5 图片上传12345678910111213141516171819202122232425262728293031323334353637&lt;el-form-item&gt; &lt;el-upload class=&quot;upload-demo&quot; multiple action=&quot;http://localhost:8888/api/private/v1/upload&quot; 上传路径 :headers = &apos;header&apos; :on-remove=&quot;handleRemove&quot; 移除事件 :on-success=&apos;handleSuccess&apos; 上传成功事件 list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt;&lt;／el-form-item&gt; data()&#123; return &#123; header: &#123; Authorization: localStorage.getItem(&quot;token&quot;) &#125; &#125;&#125;handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file);&#125;,handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); 无效token,因为请求拦截器 是在axios中设置的,需要在文件上传的header中设置请求体 &#123;data: null, meta: &#123;…&#125;&#125; data: null meta: &#123;msg: &quot;无效token&quot;, status: 400&#125; __proto__: Object &#123;data: &#123;…&#125;, meta: &#123;…&#125;&#125; data: &#123;tmp_path: &quot;tmp_uploads\5f629ba1357ffa667fc5b0484bcfeba3.jpg&quot;, url: &quot;http://127.0.0.1:8888/tmp_uploads\5f629ba1357ffa667fc5b0484bcfeba3.jpg&quot;&#125; meta: &#123;msg: &quot;上传成功&quot;, status: 200&#125; __proto__: Object&#125;, 1.6 富文本编辑器12345678910vue插件import &apos;quill/dist/quill.core.css&apos;import &apos;quill/dist/quill.snow.css&apos;import &apos;quill/dist/quill.bubble.css&apos;import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos;expore default &#123; components: quillEditor&#125;&lt;quill-editor v-model=&apos;goods_introduce&apos;&gt;&lt;/quill-editor&gt; 1.7 点击添加商品按钮添加商品发送请求1234567891011121314151617181920212223242526272829303132333435363738async addGoods()&#123; 处理商品分类数据 goods_cat this.form.goods_cat = this.selectedOptions.join(&quot;,&quot;); 处理路径 处理动态静态参数 const arr1 = this.arrDy; const arr2 = this.arrStatic; const newArr1 = arr1.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); const newArr2 = arr2.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); this.form.attrs = [...newArr1, ...newArr2]; 发送请求,请求成功回到列表页 const res = await this.$http.post(`goods`,this.form); console.log(res); this.$router.push(&#123; name: &apos;goods&apos; &#125;);&#125; 当删除文件时 handleRemove(file)&#123; 从当前的this.form.pics中移除当前元素 const index = this.form.pics.findIndex((item) =&gt; &#123; 返回满足条件的索引 return item.pics === file.response.data.tmp_path; &#125;); this.form.pics.splice(index,1); &#125; 当文件上传成功时,将文件的临时路径保存在 handleSuccess(response)&#123; this.form.pics.push(&#123; pics: response.data.tmp_path &#125;) &#125; 1.8 代码总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;!-- 自定义面包屑 --&gt; &lt;head-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/head-bread&gt; &lt;!-- alert警告框 --&gt; &lt;el-alert class=&apos;info&apos; center title=&quot;添加商品信息&quot; type=&quot;info&quot; show-icon&gt; &lt;/el-alert&gt; &lt;!-- 步骤条：步骤条的active与tab的active一致,才能在点击哪个tab时显示第几步 --&gt; &lt;el-steps :active=&quot;+active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;!-- tab --&gt; &lt;el-form label-position=&quot;top&quot; label-width=&quot;80px&quot; :model=&quot;form&quot;&gt; &lt;el-tabs v-model=&apos;active&apos; tab-position=&quot;left&quot; @tab-click = &apos;changeTab()&apos; style=&quot;height: 400px;overflow: auto&quot;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_weight&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrDy&quot; :key=&apos;i&apos;&gt; &lt;el-checkbox-group v-model=&quot;item.attr_vals&quot;&gt; &lt;el-checkbox :label=&quot;item1&quot; border size=&quot;medium&quot; v-for=&quot;(item1,i) in item.attr_vals&quot; :key=&apos;i&apos;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&quot;(item,i) in arrStatic&quot; :key=&apos;i&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;el-form-item&gt; &lt;el-upload class=&quot;upload-demo&quot; multiple :headers=&apos;headers&apos; action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&apos;handleSuccess&apos; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt; &lt;el-button type=&apos;primary&apos; plain style=&apos;margin-bottom: 10px&apos; @click=&apos;add()&apos;&gt;添加商品&lt;/el-button&gt; &lt;quill-editor v-model=&apos;form.goods_introduce&apos;&gt;&lt;/quill-editor&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 富文本编辑器组件import &apos;quill/dist/quill.core.css&apos;import &apos;quill/dist/quill.snow.css&apos;import &apos;quill/dist/quill.bubble.css&apos;import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos;export default &#123; data()&#123; return &#123; // 添加商品所需参数 form: &#123; goods_name:&apos;&apos;, goods_price: &apos;&apos;, goods_weight: &apos;&apos;, goods_number: &apos;&apos;, goods_introduce: &apos;&apos;, goods_cat: &apos;&apos;, //选中的3级分类 以,号分割的分类列表 pics: [], //图片路径 pics: [&#123;pics: &quot;&quot;&#125;] attrs: &apos;&apos; //静态动态参数 [商品参数] &#125;, active: &quot;1&quot;, // 级联选择器数据 options: [], // 选中的级联选择器 selectedOptions2: [], // 级联默认配置 defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, // 动态参数 arrDy: [], // 静态参数 arrStatic: [], // 复选框选中时的值 checked: [], // 上传文件时的请求头配置 token headers: &#123; Authorization: localStorage.getItem(&quot;token&quot;) &#125; &#125; &#125;, components: &#123; quillEditor &#125;, mounted()&#123; this.getGoods(); &#125;, methods: &#123; // 添加商品 async add()&#123; // 处理文件路径 //this.form.pics // 处理分类 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;); // 处理动态静态列表 const arr1 = this.arrDy; const arr2 = this.arrStatic; const newArr1 = arr1.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); const newArr2 = arr2.map((item) =&gt; &#123; return &#123;attr_id: item.attr_id, attr_vals: item.attr_vals&#125;; &#125;); this.form.attrs = [...newArr1, ...newArr2]; const res = await this.$http.post(`goods`,this.form); console.log(res); this.$router.push(&#123; name: &apos;goods&apos; &#125;); &#125;, // 如果选中的tabs是商品参数,并且级联选择器的长度=3,获取动态参数的数据 async changeTab()&#123; if(this.active == &quot;2&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; // 处理动态数据中的attr_vals属性 变成一个数组 this.arrDy.forEach(function(item)&#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125; if(this.active == &quot;3&quot;)&#123; if(this.selectedOptions2.length == 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择三级分类&apos;); &#125; &#125; &#125;, handleChange()&#123; &#125;, // 移除图片时 handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file); // 找到当前图片的索引,删除这一项 const index = this.form.pics.findIndex((item) =&gt; &#123; return item.pics === file.response.data.tmp_path; &#125;); this.form.pics.splice(index,1); &#125;, // 图片上传成功时,往数组添加一项 handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); //response.data.tmp_path this.form.pics.push(&#123; pics: response.data.tmp_path &#125;); &#125;, // 获取三级分类数据 async getGoods()&#123; const res = await this.$http.get(`categories?type=3`); // console.log(res); this.options = res.data.data; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .info &#123; margin-top: 20px; &#125;&lt;/style&gt; 扩展12345678ES6数组新方法1)findIndex 返回满足条件的索引 1. 数组遍历方法 2. 该方法的形参是 callback 3. 该方法有返回return条件 4. 该方法会把符合条件的元素item的索引自动返回2)map 返回一个新数组3) 复选框 点击就消失 v-model v-m-v]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fvue%2F</url>
    <content type="text"><![CDATA[vuex豆瓣项目1.项目功能12公共组件： 头部组件+侧边栏功能组件： 列表组件 + 详情组件 2. 新建项目1234567vue2: vue init webpack-simple/webpack 项目名vue3:vue create 项目名 vue3:生成项目的目录更简洁 babel： 将ES6转化为 其他低版本 js eslint: 自动检查代码规范cd 目录npm run serve 3. 安装第三方资源1234567891011121314151617181920212223npm i vue-router bootstrap@3.3.7 vuex配置组件 新建组件，在app.vue文件中国引入，并配置组件 new Vue(&#123; el:&apos;&apos;, components: &#123; 组件名：组件常量 &#125; &#125;);配置路由 在index.js文件中配置路由 import Vue from &apos;vue&apos; import VueRouter from &apos;vue-router&apos; Vue.use(VueRouter) const router = new VueRouter(&#123; routes: [ &#123; name:&quot;&quot;, path: &quot;&quot;, component: 组件名 &#125; ] &#125;); 4. 配置vuex1234567891011121314151617181920212223242526272829301.在main.js文件中导入vuex配置vuex 实例化vuex 挂载vuex2.由于vuex是一段有独立功能的代码，所以把vuex的代码进行封装store／store.jsimport Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; title: &apos;sadflihafkljsl&apos; &#125;, mutations: &#123; setTitle(state)&#123; state.title = &apos;sadfsaf&apos;; &#125; &#125;, actions: &#123; getDateList(context)&#123; context.commit(&apos;setTitle&apos;); &#125; &#125;&#125;)export default store;3.由于项目中数据很多，所以需要把每个组件的数据都单独写在一个文件中，引入到store.js文件中４.新建movielist.js 模块：专门处理列表组件的数据的部分 －数据管理模块// 使用仓库store选项modules让仓库状态与模块状态进行关联 modules: &#123; movieList &#125; store.js 1234567891011import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import movieList from &apos;./movielist&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; // 使用仓库store选项modules让仓库状态与模块状态进行关联 modules: &#123; movieList &#125;&#125;)export default store; movieList.js 12345678910111213// 模块：专门处理列表组件的数据的部分 数据管理模块const movieList = &#123; state: &#123; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;export default movieList; 12每个组件的数据管理－&gt;交给自家的数据管理模块movielist．vue -&gt; movielist.js 5. 配置列表数据处理模块1234567891.以前写在data中的数据写在state中2.发送请求 豆瓣API 不支持跨域 支持jsonp axios:有跨域问题 不支持jsonp jsonp: 可以发送jsonp 库 工具3.安装 jsonp npm i jsonp 使用： jsonp(url.options,fn); fn(error,data)4.导入包 import jsonp from &quot;jsonp&quot; jsonp(url,(error,data) =&gt; &#123;&#125;); movielist.js 12345678910111213141516171819202122232425262728// 模块：专门处理列表组件的数据的部分 数据管理模块import jsonp from &apos;jsonp&apos;const movieList = &#123; state: &#123; // 声明数据 title: &apos;&apos;, subjects: [] &#125;, mutations: &#123; // 修改数据 // title数据来源于actions异步请求接收的数据 setTitle(state,payload)&#123; state.title = payload.title; state.subjects = payload.subjects; &#125; &#125;, actions: &#123; getDateList(context)&#123; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(&apos;http://api.douban.com/v2/movie/in_theaters&apos;,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125;&#125;export default movieList; movielist.vue 12345678910111213141516171819202122232425262728293031323334&lt;template&gt;&lt;div&gt; &lt;h1 class=&quot;page-header&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;标题&lt;/h4&gt; 详情 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState([&apos;title&apos;]) &#125;, created()&#123; this.getDateList() &#125;, methods: &#123; ...mapActions([&apos;getDateList&apos;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123在组件中调用title数据之后页面上不显示数据原来：&#123;&#123;title&#125;&#125; =&gt; 计算属性 = store = state = state.title现在： &#123;&#123;title&#125;&#125; =&gt; 计算属性 = store = modules = state= state.title 6. 开启命名空间123456789101112131415161718192021221.在使用数据时，需要写使用那个模块的哪个属性 ...mapState(模块名，[属性名]) computed: &#123; ...mapState(&quot;movieList&quot;,[&apos;title&apos;]) &#125;, methods: &#123; ...mapActions(&quot;movieList&quot;,[&apos;getDateList&apos;]) &#125; 2. 使用模块名字之前，需要在模块中开启命名空间 const movielist = &#123; 开启命名空间 namespaced: true, state: &#123; &#125;, mutations: &#123; &#125;, sctions: &#123; &#125; &#125; 7. 点击不同列表，发送不同请求1在发请求是，jsonp中请求标识就是路由配置中的path值 movielist.js 1234567891011121314151617181920212223242526272829const movieList = &#123; // 开启命名空间 namespaced: true, state: &#123; // 声明数据 title: &apos;&apos;, subjects: [] &#125;, mutations: &#123; // 修改数据 // title数据来源于actions异步请求接收的数据 setTitle(state,payload)&#123; state.title = payload.title; state.subjects = payload.subjects; &#125; &#125;, actions: &#123; 在方法中传入一个参数，该参数可以获取路由配置中的path值 getDateList(context,payload)&#123; const id = payload.path; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(`http://api.douban.com/v2/movie$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125;&#125; movielist.vue 1234567在方法调用时将路由参数传进去 点哪个标识获取哪个的数据created()&#123; this.getDateList(this.$route)&#125;,只有在第一个方法标识改变时，才能获取到数据，因为调用请求数据的方法只触发一次 钩子函数只执行一次，组件已经有了，组件会被复用 8. watch检测路由123456789101112131415161718检测路由参数的变化在组件中检测movielist.vuenew Vue(&#123; watch: &#123; $route(to,from)&#123; console.log(&apos;标识变了&apos;); 对路由变化做出相应 this.getDateList(to); &#125; &#125;&#125;);movielist.jsactions: &#123; getDateList(context,payload)&#123; const id = payload.path &#125;&#125; movielist.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt;&lt;div&gt; &lt;h1 class=&quot;page-header&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;media&quot; v-for=&quot;(item,i) in subjects&quot; :key=&apos;i&apos;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/h4&gt;&#123;&#123;item.original_title&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState(&quot;movieList&quot;,[&apos;title&apos;,&apos;subjects&apos;]) &#125;, created()&#123; this.getDateList(this.$route) &#125;, watch: &#123; $route(to,from)&#123; console.log(to); this.getDateList(to); &#125; &#125;, methods: &#123; ...mapActions(&quot;movieList&quot;,[&apos;getDateList&apos;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; movielist.js 12345678910111213141516171819202122232425262728293031// 模块：专门处理列表组件的数据的部分 数据管理模块import jsonp from &apos;jsonp&apos;const movieList = &#123; // 开启命名空间 namespaced: true, state: &#123; // 声明数据 title: &apos;&apos;, subjects: [] &#125;, mutations: &#123; // 修改数据 // title数据来源于actions异步请求接收的数据 setTitle(state,payload)&#123; state.title = payload.title; state.subjects = payload.subjects; &#125; &#125;, actions: &#123; getDateList(context,payload)&#123; const id = payload.path; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(`http://api.douban.com/v2/movie$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125;&#125;export default movieList; 9. 列表渲染数据12345678&lt;div class=&quot;media&quot; v-for=&quot;(item,i) in subjects&quot; :key=&apos;i&apos;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img :src=&quot;item.images.small&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/h4&gt;&#123;&#123;item.original_title&#125;&#125; &lt;/div&gt; &lt;/div&gt; 10. 列表-vuex-router-sync12345678910请求数据的url是从外部传递过来的，如果能从context中有路由参数，context本身没有路由参数，可以考虑找一个vuex的插件给仓库增加路由信息1.插件： vuex-router-sync2.安装： npm i vuex-touter-sync// npm install --save vuex-touter-sync3.导入并配置 放在main.js文件中 import &#123;sync&#125; from &apos;vuex-touter-sync&apos;; import store from &apos;vuex/store&apos; import router from &apos;router/index.js&apos; const unsync = sync(store,router);4.导入之后 context仓库中就会多一些路由参数信息const path = context.rootState.route.path; main.js 12345678910111213141516import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import vuex from &apos;vuex&apos;import router from &apos;./router/index&apos;import store from &apos;./vuex/index.js&apos;import &apos;../node_modules/bootstrap/dist/css/bootstrap.min.css&apos;import &apos;./assets/css/index.css&apos;给仓库添加路由信息import &#123;sync&#125; from &apos;vuex-touter-sync&apos;;const unsync = sync(store,router);Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App),&#125;).$mount(&apos;#app&apos;) movielist.js 12345678910111213actions: &#123; getDateList(context,payload)&#123; // const id = payload.path; 给仓库添加路由信息 vuex-router-sync const id = context.rootState.route.path; // 异步获取数据的代码 // 在有数据的位置调用mutations中的方法,并且传递结果 jsonp(`http://api.douban.com/v2/movie$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setTitle&apos;,data); &#125;); &#125; &#125; movielist.vue 123456789101112131415161718192021&lt;script&gt;import &#123;mapState,mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState(&quot;movieList&quot;,[&apos;title&apos;,&apos;subjects&apos;]) &#125;, created()&#123; 调用方法时不用传参数 this.getDateList() &#125;, watch: &#123; $route(to,from)&#123; console.log(to); this.getDateList(to); &#125; &#125;, methods: &#123; ...mapActions(&quot;movieList&quot;,[&apos;getDateList&apos;]) &#125;&#125;&lt;/script&gt; 11. 豆瓣电影-详情11.1 配置路由12345678910111213141516171819点击图片跳转到详情页movielist.vue&lt;template&gt;&lt;div&gt; &lt;h1 class=&quot;page-header&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;media&quot; v-for=&quot;(item,i) in subjects&quot; :key=&apos;i&apos;&gt; 配置路由 &lt;router-link :to=&quot;&#123;name: &apos;moviedetail&apos;,params: &#123;id: item.id&#125;&#125;&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img :src=&quot;item.images.small&quot; alt=&quot;海报点击链接&quot;&gt; &lt;/div&gt; &lt;/router-link&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/h4&gt;&#123;&#123;item.original_title&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt; 11.2 详情-渲染movieDetail.js 12345678910111213141516171819202122232425import jsonp from &apos;jsonp&apos;const movieDetail = &#123; namespaced: true, state: &#123; movie: &#123; &#125; &#125;, mutations: &#123; setMovie(state,payload)&#123; state.movie = payload; &#125; &#125;, actions: &#123; getDetail(context)&#123; console.log(context); const id = context.rootState.route.params.id; jsonp(`https://api.douban.com/v2/movie/subject/$&#123;id&#125;`,(error,data) =&gt; &#123; console.log(data); context.commit(&apos;setMovie&apos;,data); &#125;); &#125; &#125;&#125;export default movieDetail; store.js 12345678910111213import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import movieList from &apos;./movielist&apos;import movieDetail from &apos;./movieDetail&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; // 使用仓库store选项modules让仓库状态与模块状态进行关联 modules: &#123; movieList, movieDetail &#125;&#125;)export default store; movieDetail.vue 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;movie.title&#125;&#125;&lt;/h2&gt; &lt;img :src=&quot;movie.images.large&quot; alt=&quot;电影海报&quot;&gt; &lt;hr&gt; 简介： &lt;p&gt;简介：&#123;&#123;movie.summary&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState,mapActions&#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapState(&quot;movieDetail&quot;,[&apos;movie&apos;]) &#125;, created()&#123; this.getDetail(); &#125;, methods: &#123; ...mapActions(&quot;movieDetail&quot;,[&quot;getDetail&quot;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 12. webpack12.1 webpack介绍1234webpack : 打包 处理项目的资源 闭包： 避免全局变量被污染webpack需要配置parcel: 快速、零配置的web应用程序打包器 https://www.css88.com 12.2 webpack安装1234567891011121314151.webpack文档： https://www.webpackjs.com2.处理项目中所有的资源处理成 对应的模块js/css/jpg/png3.安装： 前提是安装node.js的最新版本4.本地安装： 对大部分项目建议本地安装 每个项目的配置是不一样的 为了保证每个项目有自己的配置5.创建一个文件夹 mkdir 文件夹名 npm第一次使用需要 npm init -y 初始化配置文件 webpack安装某个版本或者特定版本 npm install --save-dev webpack npm install --save-dev webpack@版本号 如果使用的是webpack 4+版本,还需要安装cli npm install --save-dev webpack-cli6.安装结果是可以在当前目录下使用指令进行打包7.webpack和vue没有关系8.指令： webpack --help 查看所有指令 同时测试webpack有没有安装成功 12.3 目录设置123456789101.在下载的webpack文件夹中添加文件 index.html 首页 src/ assets/index.css main.js 程序入口文件 index.js 自己模块2.执行webpack指令 报错： no entry found 没有入口 入口： entry webpack从哪个文件开始打包 出口： output 打包后生成什么文件 12.4 配置文件12345678910111213141516171819202122232425262728291.新建配置文件 webpack.config.js文件 2.配置 从node中引入了path模块 与 const fs = require(&apos;fs&apos;); const path = require(&apos;path&apos;); module.exports = &#123; 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125; &#125;3.重新打包 指令： webpack 默认打包结果是一个压缩文件 dist/bundle.js 用webpack打包后,会提示一个警告,mode选项没有被设置，webpack将使用production这个值，可以设置mode选项为development(非压缩文件)或者production(压缩文件) const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125; &#125; 12.5 webpack-css-loader(处理样式文件)123456789101112131415161718192021222324252627282930webpack默认不能处理样式文件在webpack官网的指南/管理资源下/加载CSS1)安装 npm install --save-dev style-loader css-loader2)const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, 配置css样式 module: &#123; rules: [ &#123; test: /\.css$/, use为什么是数组，里面指的存储是有顺序的，而对象是没有顺序的 use: [ &apos;style-loader&apos;, =&gt; 把处理完的样式代码放在head标签中 &apos;css-loader&apos; =&gt;处理 .css中的样式代码=&gt;放在style 标签里 ] &#125; ] &#125; &#125;webpack默认只能处理.js文件, 非js文件,css需要安装/配置对应的loader加载器 12.6 图片资源12345678910111213141516171819202122232425262728293031323334需要加载器来处理1.安装 npm install --save-dev file-loader2. const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, 配置css样式 module: &#123; rules: [ &#123; test: /\.css$/, use为什么是数组，里面指的存储是有顺序的，而对象是没有顺序的 use: [ &apos;style-loader&apos;, =&gt; 把处理完的样式代码放在head标签中 &apos;css-loader&apos; =&gt;处理 .css中的样式代码=&gt;放在style 标签里 ] &#125;,&#123; 配置图片 test: /\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ] &#125; ] &#125; &#125;3.重新打包 12.7 字体文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051自定义字体文件css3属性@font-face &#123; font-family: &quot;自定义字体名&quot; src: url(&quot;路径&quot;)&#125;使用body &#123; font-family: &apos;字体名&apos;&#125;2.webpack配置2.1 const path = require(&apos;path&apos;); module.exports = &#123; 将默认的生产模式改为开发模式 mode: &quot;development&quot;, 入口： 程序从哪开始打包 entry: &apos;./src/main.js&apos;, 出口： 打包的结果存放位置 output: &#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, 配置css样式 module: &#123; rules: [ &#123; test: /\.css$/, use为什么是数组，里面指的存储是有顺序的，而对象是没有顺序的 use: [ &apos;style-loader&apos;, =&gt; 把处理完的样式代码放在head标签中 &apos;css-loader&apos; =&gt;处理 .css中的样式代码=&gt;放在style 标签里 ] &#125;,&#123; 配置图片 test: /\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ] &#125;,&#123; 配置字体 &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ] &#125; &#125; ] &#125; &#125;3.打包 webpack 12.8 服务器12345678910111213141516171819202122webpack官网 ： 指南=&gt;管理资源是处理各种资源的配置 指南=&gt;管理输出 清理dist文件夹 指南=&gt;开发 使用webpack-dev-serve配置服务器功能能够实时重新加载 1)安装 npm install --save-dev webpack-dev-server 2)配置 devServer: &#123; contentBase: &apos;./dist&apos; &#125; 3)自定义指令package.json 文件中的scripts是写自定义指令的 &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --open&quot; &#125; 在所有指令中 其他的都是 npm run 指令名 start比较特别 直接 npm start就可以执行指令 webpack服务器]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端项目]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[电商项目1. git介绍1.1 git命令及创建、切换、合并分支1234567891011121314151617181920212223初始化本地仓库 创建目录，在目录中右键打开 git Bash Here , git init 初始化本地仓库 git status 查看文件状态 git add -A 将已经修改的文件和新文件提交到暂存区 git commit -m &quot;&quot; 本地仓库 创建分分支 git branch 分支名：创建分支 git checkout 分支名: 来到了这个分支上（使用分支，或者说切换到哪个分支） 使用分支实现了不同代码的互相独立 git status 查看状态 git add user.html 将新文件user.html提交到暂存区 git commit -m &quot;&quot; 提交到了新分支 不同分支下，相同的文件不会相互影响，只是里面的代码内容那个不同 git log 查看提交过几次 主分支会继承次分支的提交 次分支3次 一共提交4次 还有主分支提交（思考） 合并分支 git checkout master 切换到主分支 git merge 分分支 合并哪个分分支 conflict: 冲突 1.2 git分支相关命令12345678git branch 分支名 创建分支git checkout 分支名 切换分支git merge 分支名 合并分支git branch 查看有几个分支 *号指向哪说明当前在哪个分支下git branch -D 分支名 (大写D或者小写d均可，大写表示强制删除) 只能在当前分支下删除其他分支，不能删除当前分支git checkout -b 分支 创建分支并切换到该分支 1.3 多人协同介绍1.3.1 冲突1234567891011121314同一个文件同一行代码在执行合并的时候，在两个分支上不一样，就会发生冲突。解决冲突后重新提交 git add -A git commit -m &quot;&quot;; git merge master如果进入vim代码编辑模式，按shift+:+q 退出 （:q）master分支： base.css background:red; 第九行user分支: base.css background:yellow; 第九行出现冲突，不知道要保留哪个，如果不是同一行不会出现冲突 1.3.2 远程仓库123456789101112131415161718192021221.创建共享仓库 git要求共享仓库是一个以.git结尾的目录 mkdir git.git 创建以.git结尾的目录 cd git.git 进入这个目录 git init --bare 初始化一个共享仓库，也叫裸仓库 这样就创建好了一个共享的仓库，但这时仓库是空的，并且不允许在这个仓库中进行任何的修改2.向共享仓库共享(同步)内容 将自己开发的项目同步到这个目录中，其他开发者就可以共享你开发的项目 git push ../git.git（远程仓库） master 把自己的项目提交到远程仓库的主分支上 把自己的项目的主分支与分分支合并之后再推到远程仓库的主分支 git checkout master git merge user git push ../git.git master 3.如果别人要使用你提交的项目，克隆 git clone git.git(远程仓库) web(把代码克隆到哪) 克隆下来之后进行操作，再推到远程仓库 git checkout -b cart git add -A git commit -m &quot;&quot; git push ./git.git cart 推到远程仓库的cart分支4.如果自己要使用别人修改之后的远程仓库中的项目，需要把项目拉下来 git pull ../git.git cart 1.3.3 远程仓库相关命令1234567891011创建目录git.git git init --bare 初始化远程仓库将自己的代码提交到远程仓库 git push git.git master从远程仓库拉下代码，第一次是clone git clone ../git.git web(文件夹名项目名) 完成或者修改自己的项目后,推到远程仓库 git push ../git.git cart(分支) 把别人的代码拉下来 git pull ../git.git login(分支) 2. github介绍123456781.点击+号，new repository=&gt;项目名=&gt;描述=&gt;public=&gt;不勾选InInitialize=&gt;create repository2.链接使用SSH将项目提交到github，远程仓库 git push SSH链接 master 第一次将github上的代码赋值下来 git clone SSH链接 项目名 2.1 配置SSH12345678不使用密码登录github在命令行窗口打开 ssh-keygen -t rsa 一直回车键 在c盘用户下有一个.ssh文件，id_rsa.pub文件 中的内容复制到github中 github设置中settings=&gt;SSH and GPG keys=&gt;New SSH key=&gt;title:随便写，内容粘到key中=&gt;add SSH Key如果没有配置SSH，输入git push 链接 master会报致命错误使用https会总是提示输入用户名和密码，如果使用SSH需要以上配置 2.2 练习12345678910111213141516171819202122232425创建文件，添加文件并初始化仓库git init git add -Agit commmit -m &quot;&quot;git push 链接 master另一个人git clone 链接 项目名 不写项目名，默认以.git前面的文件为名称git add -Agit commit -m &quot;&quot;git push 链接 master自己：git pull 链接 分支错误： 如果修改了文件之后没有add commit，不会让你pull error:Your local changes to the following files would be overwritten by merge: index.html Please commit your changes or stash them before you merge.错误： 如果一个人push了，另一个人不能同时push，必须先把代码pull下来以后，才能push，防止冲突 提示：在push之前先做pull防止冲突 2.3 添加远程主机12git remote add origin 链接使用origin代替链接地址 2.4 github pages12345678910111213创建项目=&gt;项目名=&gt;描述=&gt;public =&gt;create repository进入项目文件夹=&gt;git init git add -A git commit -m &quot;&quot; git remote add origin 链接 git push origin master代码右上有一个settings github pages source=&gt;master branch=&gt;save刷新页面 进入github pages进入网站链接即可注意： 只能是静态网站 大小不能超过100M 2.5 git和svn12git是分布式的代码管理工具svn是集中式的代码管理工具 3. 电商项目3.1 介绍12轮播图实现： zepto swiper iScroll滚动 3.2 配置前端服务器1234567配置Apache配置域名： PHPStudy 其他选项菜单=&gt;站点域名管理=&gt;网站域名 网站根目录 第二域名 网站端口可不写 新增 保存并生成 修改host文件配置域名： 其他选项菜单=&gt;打开host=&gt;localhst www.letao.com 或者打开C盘目录,windows/system32/extc/hosts 3.3 配置后端服务器123见文档前端地址：http://www.letao.com后端地址：http://localhost:3030 3.4 后端接口跨域问题123456修改API文档中的app.js文件中,去除注释 app.all(&apos;*&apos;,function(req,res,next)&#123; res.header(&apos;Access-Control-Allow-Origin&apos;,&apos;*&apos;); next(); &#125;); 重启node ,输入两次^C，退出node,再次输入npm start,重新启动node 3.5 登录问题123456789101112131415161718192021222324252627282930313233343536373839user/login.html添加form表单，修改按钮，发送ajax请求步骤： 1.引入jquery.js文件 2.实现登录功能 2.1 获取用户输入表单的信息 2.2 将信息通过ajax请求发送到服务器端 2.3 等待服务器端的响应结果，处理登录后的逻辑 接收地址中的url参数，将?号及?号后面的内容提取出来 var search = location.search.slice(1); var reg = /url=(.+)/; 利用正则表达式来匹配url地址 var match = reg.exec(search); var url = match &amp;&amp; match[1]; 如果有url地址则跳转到该地址，如果没有则跳转到Index.html页面 url = url || &apos;/&apos;; $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; var data = $(this).serialize(); console.log(data); username=xxx&amp;password=123456; $.ajax(&#123; // url:&apos;http://localhost:3000/user/login&apos;, 反向代理 url:&apos;http://58.com/api/user/login&apos;, 可以被简写为 &apos;/api/user/login&apos; 访问api就是访问localhost:3000,不会出现跨域问题 type:&apos;post&apos;, data:data, 对象|字符串都可以 success:function(info)&#123; console.log(info); location.href = &apos;url&apos;; &#125; &#125;); 由于使用ajax发送请求，不需要刷新，所以取消默认跳转功能 return false; |e.preventDefault(); | e.cancelBubble = true; &#125;); 12密码是md5加密的；serialize()：jquery的方法获取表单数据 返回数据是value=key&amp;value2=key2格式的 3.6 查询用户信息(cookie跨域)1234567891011121314151617user/index.html 会员中心 引入jquery.js文件步骤： 获取用户信息 1.发送请求获取用户信息 $.ajax(&#123; // url:&apos;http://localhost:3000/user/queryUserMessage&apos;, 出现跨域问题，使用反向代理实现跨域 url:&apos;http://58.com/api/user/queryUserMessage&apos;, 简写为 url:&apos;/api/user/queryUserMessage&apos;, type:&apos;get&apos;, 参数无 success:function(info)&#123; console.log(info); 无法获取已登录信息，因为跨域限制了cookie 根据响应结果判断是否登录 if(info.error)&#123; location.href = &apos;/user/login.html&apos;; &#125; &#125; &#125;); 123注意： 跨域不但限制了XMLHttpRequest(即ajax)也限制了cookie。 CORS中设置的Access-Control-Allow-Origin:*只是用来解决XMLHttpRequest的跨域限制的，并不能解决cookie的跨域问题。 3.7 配置Apache的反向代理123456789通过配置apache可以实现代理访问nodejs服务器配置apache： 1.phpstudy中=&gt;其他选项菜单=&gt;打开配置文件=&gt;vhosts-conf proxyRequests Off 关闭正向代理 proxyPass /api http://localhost:3000 如果访问的地址是/api开头 代理到localhost:3000 2.phpstudy中=&gt;其他选项菜单=&gt;打开配置文件=&gt;httpd-conf LoadModule proxy_module modules/mod_proxy.so 解开注释 LoadModule proxy_http_module modules/mod_proxy_http.so 解开注释 重新启动PHPStudy 3.8 退出登录1234567891011121314151617181920通过git实现,下载代码到目录，创建新分支，并切换到该分支 feature-userindex.html点击退出按钮，跳转到登录页面步骤： 1.添加点击事件 2.发送请求 3.等待后端响应 4.处理响应的逻辑 $(&apos;.btn_outLogin&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url:&apos;/api/user/logout&apos;, type:&apos;get&apos;, 不需要参数 success:function(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/index.html&apos;; &apos;/&apos; &#125; &#125; &#125;); &#125;); 3.9 用户注册123456789101112131415161718192021222324252627282930313233343536373839404142434445register.html引入jquery.js文件步骤： 修改html文件，添加form表单，修改注册a链接为button按钮 1.获取表单中用户填写的信息 2.发送这些信息 3.等待后端响应结果 4.处理响应的逻辑 $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; 获取表单中用户填写的信息,serialize方法会自动忽略没有name的表单信息，如果不需要确认密码，那么可以把确认密码的name属性去掉 var data = $(this).serialize(); $.ajax(&#123; url:&apos;/api/user/register&apos;, type:&apos;post&apos;, data:data, success:funtion(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/user/login.html&apos;; return; &#125; 错误提示 alert(info.message); &#125; &#125;); 阻止表单默认提交 return false; &#125;); 获取验证码 步骤： 1.点击事件 2.发送请求 3.等待服务端响应结果 4.处理相应的逻辑 $(&apos;.btn_getCode&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url:&apos;/api/user/vCode&apos;, type:&apos;get&apos;, 参数无 success:function(info)&#123; console.log(info); &#125; &#125;); &#125;); 3.10 修改密码1234567891011121314151617181920212223242526272829303132333435363738394041424344password.html引入jquery.js文件，添加form表单，修改按钮a链接为button步骤： 1.获取表单信息 2.发送表单信息 3.等待服务器响应结果 4.处理相关业务逻辑 $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; 获取表单中用户填写的信息,serialize方法会自动忽略没有name的表单信息，如果不需要确认密码，那么可以把确认密码的name属性去掉 var data = $(this).serialize(); $.ajax(&#123; url:&apos;/api/user/updatePassword&apos;, type:&apos;post&apos;, data:data, success:funtion(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/user/login.html&apos;; return; &#125; 错误提示 alert(info.message); &#125; &#125;); 阻止表单默认提交 return false; &#125;); 获取验证码 步骤： 1.点击事件 2.发送请求 3.等待服务端响应结果 4.处理相应的逻辑 $(&apos;.btn_getCode&apos;).on(&apos;click&apos;,function()&#123; $.ajax(&#123; url:&apos;/api/user/vCodeForUpdatePassword&apos;, type:&apos;get&apos;, 参数无 success:function(info)&#123; console.log(info); &#125; &#125;); &#125;); 123456789用户模块完成git statusgit add -Agit commit -m &quot;用户模块完成，等待测试&quot; 确定分支，和修改的文件，将代码发送到远程仓库上的feature-user分支上git push origin feature-user创建新的分支，首先先切换到主分支master，再创建新分支，因为原来的feature-user分支还没测试完毕。git checkout mastergit checkout -b feature-address 3.11 收货地址列表1234567891011121314151617181920212223242526272829303132333435363738394041git checkout feature-addressuser/address.html引入jquery.js文件，引入模板引擎template-web.js文件获取地址列表 步骤: 1.发送ajax请求 2.等待服务器响应 3.处理数据 $.ajax(&#123; url:&apos;/api/address/queryAddress&apos;, type:&apos;get&apos;, 参数无,修改文档参数为无。 success:function(info)&#123; console.log(info); if(info.error)&#123; location.href = &quot;/user/login.html?url=&quot;+location.href; return; &#125; 可以简写为： if(info.error) return location.href=&quot;/user/login.html?url=&quot;+location.href; 处理数据使用模板引擎 调用模板引擎 var html = template(&apos;template&apos;,&#123;lists:info&#125;); $(&apos;ul&apos;).html(html); &#125; &#125;); 模板引擎： 定义模板 &lt;script type=&quot;text/html&quot; id=&quot;template&quot;&gt; &#123;&#123;each lists value&#125;&#125; &lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;div class=&quot;mui-slider-right mui-disabled&quot;&gt; &lt;a class=&quot;mui-btn mui-btn-red&quot; data-id=&apos;&#123;&#123;value.id&#125;&#125;&apos;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;a href=&quot;addressManage.html&quot; class=&quot;mui-navigate-right mui-slider-handle&quot;&gt; &lt;div class=&quot;delivery&quot;&gt;邮编：&lt;span&gt;&#123;&#123;value.postCode&#125;&#125;&lt;/span&gt;&amp;nbsp;收货人：&lt;span&gt;&#123;&#123;value.recipients&#125;&#125;&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;address&quot;&gt;&#123;&#123;value.address&#125;&#125;&#123;&#123;value.addressDetail&#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/script&gt; 3.12 乐淘添加地址123456789101112131415161718192021222324252627282930313233343536371)在address.html页面添加添加地址按钮&lt;style&gt; .add_btn &#123; padding: 0 30px; &#125;&lt;/style&gt;&lt;div class=&quot;add_btn&quot;&gt; &lt;a href=&quot;/user/addAddress.html&quot; type=&quot;submit&quot; class=&quot;mui-btn mui-btn-primary btn-login&quot;&gt;新增地址&lt;/a&gt;&lt;/div&gt;2)给列表添加a链接，跳转到修改页面3)添加form表单，修改提交按钮新增地址步骤： 1.获取表单数据 2.发送数据到服务端 3.等待服务器响应结果 4.处理响应逻辑 $(&apos;form&apos;).on(&apos;submit&apos;,function()&#123; 获取表单数据 var data = $(this).serialize(); $.ajax(&#123; url:&apos;/api/address/addAddress&apos;, type:&apos;post&apos;, data:data, success:function(info)&#123; console.log(info); if(info.success)&#123; location.href = &apos;/user/address.html&apos;; &#125; &#125; &#125;); 阻止默认跳转 return false; &#125;); 3.13 删除地址123456789101112131415161718192021不能直接给删除按钮绑定点击事件，因为地址列表是由模板引擎渲染来的，当点击按钮的时候，ajax还没渲染完，所以需要事件委托来绑定事件。$(&apos;#address&apos;).on(&apos;click&apos;,&apos;.mui-btn-red&apos;,function()&#123; var id = $(this).attr(&apos;data-id&apos;); var _this = $(this); $.ajax(&#123; url:&apos;/api/address/deleteAddress&apos;, type:&apos;post&apos;, data:&#123;id:id&#125;, success:function(info)&#123; console.log(info); if(info.success)&#123; 这里面的this是ajax里面的this // _this.parent().parent().parent(); // parents(); 获取祖先的方法,获取祖先中的li父元素 _this.parents(&apos;li&apos;).fadeOut(function()&#123; $(this).remove(); &#125;); &#125; &#125; &#125;);&#125;); 3.14 编辑地址12 3.15 将feature-address分支提交到远程仓库1234567切换到分支： git checkout feature-address git add -A git commit -m &quot;收货地址&quot; git push origin feature-address git checkout master git merge feature-address git checkout -b featrue-product 3.16 优化登录123456789101112131415address.html从哪个页面点击到登录页面，登录之后再跳转到原来的页面跳转到登录页面时,传入参数url记录当前传入的是哪个地址，if(info.error) return location.href= &apos;/user/login.html?url=&apos;+location.href;login.html获取地址参数，如果有url参数，登录成功后跳转到url参数所对应的地址，如果没有url参数，则默认跳转到首页。location.search: 获取的是url地址后面 ？号及？号后面的内容var search = location.search.slice(1); 从下标为1的地方开始截取，截取到结尾。search:url=location.href通过正则表达式获取地址中的参数var reg = /url=(.+)/;var match = reg.exec(search);var url = match &amp;&amp; match[1];url = url || &apos;/&apos;; 4. mui组件介绍1234dev.dcloud.net.cn/mui mui组件图片轮播区域滚动组件提示框：4种 5. 商品列表123456789101112131415161718192021222324252627282930index.html引入模板引擎$.ajax(&#123; url:&apos;/api/product/queryProduct&apos;, type:&apos;get&apos;, data:&#123; page: 1, pageSize:6 &#125;, success:function(info)&#123; console.log(info); 调用模板引擎 var html = template(&apos;template&apos;,info); $(&apos;#product&apos;).html(html); &#125;&#125;);模板引擎&lt;script type=&apos;text/template&apos; id=&apos;template&apos;&gt; &#123;&#123;each data value&#125;&#125; &lt;a href=&quot;/product.html?id=&#123;&#123;value.id&#125;&#125;&quot; class=&quot;cz_product&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;/api&#123;&#123;value.pic[0].picAddr&#125;&#125;&quot; alt=&quot;&quot;/&gt; &lt;p class=&quot;name&quot;&gt;&#123;&#123;value.proName&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span class=&quot;price&quot;&gt;&amp;yen;&#123;&#123;value.price&#125;&#125;&lt;/span&gt;&lt;span class=&quot;oldPrice&quot;&gt;&amp;yen;&#123;&#123;value.oldPrice&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;button class=&quot;button&quot;&gt;立即购买&lt;/button&gt; &lt;/div&gt; &lt;/a&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; 6. 商品详情123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990product.html 获取地址中的商品id，然后根据id获取商品详情1.获取地址参数 a.解析地址参数数据 var search = location.search.slice(1); var arr = search.split(&apos;&amp;&apos;); var obj = &#123;&#125;; arr.forEach(function(item)&#123; var temp = item.split(&apos;=&apos;); console.log(temp[0]); console.log(temp[1]); obj[temp[0]] = temp[1]; &#125;);2.发送请求$.ajax(&#123; url:&apos;/api/product/queryProductDetail&apos;, type:&apos;get&apos;, data:&#123;id: obj.id&#125;, success:function(info)&#123; console.log(info); 将info.size中的数据，分割成数组 info.size = info.size.split(&apos;-&apos;); 计算折扣： toFixed(1):保留几位小数点 info.discount = (info.price/info.oldPrice*10).toFixed(1); 调用模板引擎 var html = template(&apos;template&apos;,info); $(&apos;#detail&apos;).html(html); &#125; &#125;);3.处理json数据定义模板引擎只有一条数据，不需要遍历&lt;script type=&quot;text/html&quot; id=&quot;template&quot;&gt; &lt;div class=&quot;cz_banner mui-slider&quot;&gt; &lt;div class=&quot;mui-slider-group mui-slider-loop&quot;&gt; &lt;div class=&quot;mui-slider-item mui-slider-item-duplicate&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-item mui-active&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-item mui-active&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-item mui-slider-item-duplicate&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/product.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mui-slider-indicator&quot;&gt; &lt;div class=&quot;mui-indicator mui-active&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mui-indicator&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;p_title&quot;&gt; &#123;&#123;proName&#125;&#125; &lt;/div&gt; &lt;div class=&quot;p_price&quot;&gt; &lt;span class=&quot;fold&quot;&gt;&lt;span&gt;&#123;&#123;discount&#125;&#125;&lt;/span&gt;折&lt;/span&gt; 价格：&lt;strong class=&quot;present&quot;&gt;¥ &#123;&#123;price&#125;&#125;&lt;/strong&gt; &lt;del class=&quot;original&quot;&gt;¥&#123;&#123;oldPrice&#125;&#125;&lt;/del&gt; &lt;/div&gt; &lt;div class=&quot;p_size&quot;&gt; 尺码： &#123;&#123;each size val&#125;&#125; &lt;span class=&quot;btn_size&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/span&gt; &#123;&#123;/each&#125;&#125; &lt;/div&gt; &lt;div class=&quot;p_number&quot;&gt; 数量： &lt;span class=&quot;jian btn_act&quot;&gt;-&lt;/span&gt; &lt;input type=&quot;tel&quot; class=&quot;btn_num&quot; value=&quot;1&quot; /&gt; &lt;span class=&quot;jia btn_act&quot;&gt;+&lt;/span&gt; 剩余：&#123;&#123;num&#125;&#125; 件 &lt;/div&gt; &lt;div class=&quot;p_detail&quot;&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;img data-lazyload=&quot;images/detail.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;/script&gt;删除除轮播图和区域滚动以外的js插件, 上拉刷新 图片懒加载 7. 添加购物车12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758修改produce.html中的购物车按钮，跳转到/cart.html点击购物车添加购物车： 1.添加点击事件 获取商品信息 2.发送ajax请求 $(&apos;.btn_addCart&apos;).on(&apos;click&apos;,function()&#123; 获取商品信息 数量 var num = $(&apos;.btn_count&apos;).val(); var size = $(&apos;span.active&apos;).text(); $.ajax(&#123; url: &apos;/api/cart/addCart&apos;, type:&apos;post&apos;, data:&#123; productId:obj.id, num:num, size: 40 &#125; success:function(info)&#123; console.log(info); if(info.error)&#123; return mui.alert( &apos;请先登录&apos;, &apos;提示&apos;, &apos;确认&apos;, function()&#123; location.href = &apos;/user/login.html?url=&apos;+location.href; &#125; ); &#125; mui.toast(&apos;添加成功&apos;); &#125; &#125;); &#125;);选择型号:由于元素是动态添加的不能直接给元素添加事件，通过实践委托来实现 // 获取型号 $(&apos;#detail&apos;).on(&apos;click&apos;, &apos;.btn_size&apos;, function () &#123; $(this).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); &#125;)// 修改商品数量$(&apos;#detail&apos;).on(&apos;click&apos;, &apos;.btn_act&apos;, function () &#123; // 获取数量 var input = $(this).siblings(&apos;input&apos;); var n = input.val()-0; 转数字 if($(this).is(&apos;.jia&apos;)) &#123; // 加 如果n的值大于库存的值，return if(n &gt;= $(&apos;.btn_total&apos;).text()-0) return; return input.val(++n); &#125; // 减 if(n &lt;= 1) return; input.val(--n);&#125;)注意：如果商品数量手动修改的话，添加失去焦点事件 8. 购物车列表123456789101112131415161718192021222324252627cart.html获取购物车列表1.发送ajax请求2.等待响应3.处理json数据$.ajax(&#123; url:&apos;/api/cart/queryCart&apos;, type:&apos;get&apos;, data:&#123;id: obj.id&#125;, success:function(info)&#123; console.log(info); if(info.error)&#123; return mui.alert( &apos;请先登录&apos;, &apos;提示&apos;, &apos;确认&apos;, function()&#123; location.href = &apos;/user/login.html?url=&apos;+location.href; &#125; ) &#125; var html = template(&apos;template&apos;,&#123;lists:info&#125;); $(&apos;#cart&apos;).html(html); &#125; &#125;);模板引擎 9. 分类123456789cate.html获取分类1.发送请求获取顶级分类$.ajax(&#123; &#125;);2.处理顶级分类数据3.点击顶级分类，获取相应的二级分类4.处理二级分类数据 10. cookie跨域12 11. mui上拉下拉刷新1直接调用mui组件 12. 购物车上下拉交互12 13. 分类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869发送ajax请求，获取一级二级分类&lt;!-- 自定义顶级分类模板 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;topTpl&quot;&gt; &lt;ul&gt; &#123;&#123;each rows val&#125;&#125; &lt;li data-id=&quot;&#123;&#123;val.id&#125;&#125;&quot;&gt;&#123;&#123;val.categoryName&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/script&gt;&lt;!-- 自定义二级分类模板 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;childTpl&quot;&gt; &lt;span class=&quot;title&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; &lt;ul class=&quot;mui-clearfix&quot;&gt; &#123;&#123;each rows val&#125;&#125; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;img src=&quot;/api&#123;&#123;val.brandLogo&#125;&#125;&quot; alt=&quot;&quot;/&gt; &lt;p&gt;&#123;&#123;val.brandName&#125;&#125;&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/script&gt;发送ajax请求// 获取分类// 1. 发送请求获取顶（一）级分类$.ajax(&#123; url: &apos;/api/category/queryTopCategory&apos;, type: &apos;get&apos;, success: function (info) &#123; // 2. 处理顶（一）级分类数据 console.log(info); // 调用模板引擎 var html = template(&apos;topTpl&apos;, info); // 添加DOM $(&apos;#top&apos;).html(html); // 添加默认数据 $(&apos;#top li:first-child&apos;).trigger(&apos;click&apos;); &#125;&#125;); // 3. 再次点击顶（一）级分类，获取相应的二级分类$(&apos;#top&apos;).on(&apos;click&apos;, &apos;li&apos;, function () &#123; // 获取顶级分类id var id = $(this).attr(&apos;data-id&apos;); // 顶级分类名称 var text = $(this).text(); // 改变顶级分类的样式 $(this).addClass(&apos;now&apos;).siblings().removeClass(&apos;now&apos;); $.ajax(&#123; url: &apos;/api/category/querySecondCategory&apos;, type: &apos;get&apos;, data: &#123;id: id&#125;, success: function (info) &#123; // 4. 处理二级分类数据 console.log(info); // 顶级分类名称 info.text = text; // 调用模板引擎 var html = template(&apos;childTpl&apos;, info); // 添加DOM $(&apos;#child&apos;).html(html); &#125; &#125;);&#125;) 14. cors跨域1cors可以同时支持ajax跨域和cookie跨域。反向代理可以支持cookie跨域。 15. 关于上拉下拉操作12购物车上拉刷新下拉加载mui官网案例：上拉加载 下拉刷新 16. 购物车上下拉交互1添加mui上拉下拉组件，实现功能 17. 下拉刷新1下拉取数据 18. 上拉加载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104上拉取数据&lt;!-- 自定义购物车模板 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt; &#123;&#123;each data val&#125;&#125; &lt;li data-product=&quot;&quot; class=&quot;mui-table-view-cell&quot;&gt; &lt;div class=&quot;mui-slider-right mui-disabled&quot;&gt; &lt;a class=&quot;mui-btn mui-btn-blue&quot;&gt;编辑&lt;/a&gt; &lt;a class=&quot;mui-btn mui-btn-red&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;mui-navigate-right mui-slider-handle&quot;&gt; &lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;/api&#123;&#123;val.pic[0].picAddr&#125;&#125;&quot;&gt; &lt;div class=&quot;mui-media-body&quot;&gt; &lt;p class=&quot;name&quot;&gt;&#123;&#123;val.proName&#125;&#125;&lt;/p&gt; &lt;p class=&quot;info&quot;&gt; &lt;span class=&quot;price&quot;&gt;&amp;yen;&#123;&#123;val.price&#125;&#125;&lt;/span&gt; &lt;span class=&quot;oldPrice&quot;&gt;&amp;yen;&#123;&#123;val.oldPrice&#125;&#125;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;x&#123;&#123;val.num&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span class=&quot;size&quot;&gt;鞋码：&#123;&#123;val.size&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt;&lt;script&gt;// 初始化变量var page = 1;var pageSize = 5;mui(function()&#123; mui.init(&#123; pullRefresh : &#123; container: &quot;.cz_container&quot;, down: &#123; height: 50, auto: true, contentdown: &quot;下拉可以刷新&quot;, contentover: &quot;释放立即刷新&quot;, contentrefresh: &quot;正在刷新...&quot;, callback: function () &#123; $.ajax(&#123; url: &apos;/api/cart/queryCartPaging&apos;, type: &apos;get&apos;, data: &#123; // 刷新永远为第1页 page: 1, pageSize: pageSize &#125;, success: function (info) &#123; // console.log(info); // 调用模板引擎 var html = template(&apos;tpl&apos;, info); // 添加DOM $(&apos;#cart&apos;).html(html); // 当请求完成时需要手动 // 终止请求（官方文档有误） mui(&apos;.cz_container&apos;).pullRefresh().endPulldownToRefresh(); // 下拉刷新后将页码重置为1 page = 1; mui(&apos;.cz_container&apos;).pullRefresh().enablePullupToRefresh(); &#125; &#125;); &#125; &#125;, up: &#123; height: 50, auto: false, contentrefresh: &quot;正在加载...&quot;, contentnomore: &apos;没有更多数据了&apos;, callback: function () &#123; page++; // 发送请求请求更多数据 $.ajax(&#123; url: &apos;/api/cart/queryCartPaging&apos;, type: &apos;get&apos;, data: &#123; page: page, pageSize: pageSize &#125;, success: function (info) &#123; console.log(info); // 终止上拉交互 if(info.length == 0) &#123; mui(&apos;.cz_container&apos;).pullRefresh().endPullupToRefresh(true); return; &#125; // 调用模板引擎 var html = template(&apos;tpl&apos;, info); // 一定追加 $(&apos;#cart&apos;).append(html); // 手动终止请求 mui(&apos;.cz_container&apos;).pullRefresh().endPullupToRefresh(); &#125; &#125;) &#125; &#125; &#125; &#125;);&#125;);&lt;/script&gt; 19. 购物车完善12 20. 后端登录123456789101112131415161718192021222324252627282930313233343536373839进入后台首页，判断有没有登录，没登陆跳转到登录页1.检测用户登录// 检测用户登录$.ajax(&#123; url: &apos;/api/employee/checkRootLogin&apos;, type: &apos;get&apos;, success: function (info) &#123; if(info.error) location.href = &apos;/admin/login.html&apos;; &#125;&#125;);2.登录页面// 获取地址参数var search = location.search.slice(1);// 使用正则匹配 url 参数的值var reg = /url=(.+)/;// 匹配到的地址var match = reg.exec(search);var url = match &amp;&amp; match[1];url = url || &apos;/admin&apos;;$(&apos;form&apos;).on(&apos;submit&apos;, function () &#123; // 1. 获取用户表单填写的信息 var data = $(this).serialize(); // 2. 发送请求至服务端 $.ajax(&#123; url: &apos;/api/employee/employeeLogin&apos;, type: &apos;post&apos;, data: data, success: function (info) &#123; // 3. 待待响应结果 console.log(info); if(info.success) &#123; return location.href = url; &#125; // 提示错误 alert(info.message); &#125; &#125;) return false;&#125;) 21. 后台退出登录12345678910111213// 退出登录$(&apos;.fa-sign-out&apos;).parent().on(&apos;click&apos;, function () &#123; // 发送请求 $.ajax(&#123; url: &apos;/api/employee/employeeLogout&apos;, type: &apos;get&apos;, success: function (info) &#123; if(info.success) &#123; location.href = &apos;/admin/login.html?url=&apos; + location.href; &#125; &#125; &#125;);&#125;) 22. 后台用户列表1234567891011121314151617181920212223242526272829303132333435363738// 获取用户列表$.ajax(&#123; url: &apos;/api/user/queryUser&apos;, type: &apos;get&apos;, data: &#123; page: 1, pageSize: 100 &#125;, success: function (info) &#123; console.log(info); // 调用模板引擎 var html = template(&apos;tpl&apos;, info); // 添加DOM $(&apos;tbody&apos;).html(html); &#125;&#125;);模板引擎&lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt; &#123;&#123;each rows val key&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;key+1&#125;&#125;&lt;/td&gt; 因为使用id删除数据后编号不是连续的 &lt;td&gt;&#123;&#123;val.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;val.mobile&#125;&#125;&lt;/td&gt; &#123;&#123;if(val.isDelete == 0)&#125;&#125; &lt;td&gt;是&lt;/td&gt; &#123;&#123;else&#125;&#125; &lt;td&gt;否&lt;/td&gt; &#123;&#123;/if&#125;&#125; &lt;td data-id=&quot;&#123;&#123;val.id&#125;&#125;&quot; data-status=&#123;&#123;val.isDelete&#125;&#125;&gt; &#123;&#123;if(val.isDelete == 0)&#125;&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;btn btn-info btn-xs&quot;&gt;启 用&lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;btn btn-warning btn-xs&quot;&gt;禁 用&lt;/a&gt; &#123;&#123;/if&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; 23. 后台修改用户12 24. 省市县插件12 项目中问题121.后端端口号不正确，导致发生ajax请求之后没有响应。2.表单默认提交，导致控制台测试的数据，打印后会立刻消失 扩展相对路径和绝对路径12345671.凡是以./或者是../开头的都叫相对路径2.在window系统中，凡是以盘符开头的都叫绝对路径 c:\admin3.在linux或者是MAC系统中，凡是以/开头的都叫绝对路径 4.在网络环境中，凡是以http://域名：端口号/a/b/c开头的叫绝对路径http://letao.com 可以被简写成 /http://letao.com/a/b 可以被简写成 /a/bhttp://letao.com/api/user/login 可以被简写成 /api/user/login git创建分支特点123如果是添加新功能： feature-user如果是修复bug: fix-user如果是着急修复的bug:hotfix-user 保留几位小数点12var num = 123.456;num.toFixed(1); 保留一位小数点 字符串的数字相比较12如果是字符串的数字相比较,先比较第一位数字，第一位大的就大&apos;3&apos; &gt; &apos;20&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[node笔记]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Node1. Node是什么123456789101112131415161718nodejs.cn node中文网https://nodejs.org/en 英文网node社区: https://cnodejs.orgjs代码是浏览器里面的解释器来运行js代码。Node.js是一个基于Chrome V8引擎的JavaScript的运行环境，node.js使用了一个事件驱动、非阻塞式I/O的模型，使其轻量又高效。。node是js的运行环境。浏览器和node中js的区别： 1.没有DOM和BOM 2.有ECMAScript 3.有自己的APInode -v:检测是否安装好node按node回车：进入REPL环境中,进行代码的简单测试按ctrl+c两次退出REPL环境node运行js文件： 1.命令行窗口进入.js文件所在目录 2.node+空格+.js文件名+回车 3.输入cls命令 清屏 node helloworld.js 2. 模块体验2.1 fs文件模块12345678910111213141516171819202122232425262728293031321.node中模块fs 读取本地文件 1)导入模块 var fs = require(&apos;fs&apos;); 2)使用该模块的API fs.readFile(形参1，形参2，形参3); 形参1:path要读取文件的文件路径 形参2:可选参数 形参3:回调函数 callback(err,data) fs.readFile(&apos;txt.txt&apos;,function(error,data)&#123; console.log(error); 如果错误，抛出异常，后续代码不会执行，不需要写return|else;s throw： js关键字 if(error)&#123; throw error; &#125; data默认类型是Buffer16进制数据,toString()把数据转化为字符串格式 data = data.toString(); console.log(data); &#125;);2.node中模块fs 写入文件 1）导入fs模块 var fs = require(&apos;fs&apos;); 2）使用fs的API fs.writeFile(形参1，形参2，形参3,形参四); 形参1:path要读取文件的文件路径 形参2:要写入的数据 形参3:可选参数 形参4:回调函数 callback(err) fs.writeFile(&apos;txt.txt&apos;,&apos;我是数据&apos;,function(error)&#123; console.log(error); &#125;); 注意:如果文件路径不存在此文件,会自动创建该文件;如果文件存在，会把数据重新写入此文件,会覆盖原来的内容。 2.2 http模块12345678910111213141516171819202122232425262728http快速搭建服务器1.导入http模块var http = require(&apos;http&apos;);2.创建服务器实例对象var server = http.createServer();3.绑定事件，处理请求和响应.on(&apos;request&apos;,callback(request,response));&apos;request&apos;:固定语法回调函数中,request是请求对象(请求路径/请求浏览器信息/系统信息等)，reponse是响应对象var app = server.on(&apos;request&apos;,function(request,response)&#123; 处理请求对象 返回响应 console.log(&apos;发送请求&apos;); 向发起请求的页面写入字符串 response.write(&apos;sadfjsakjfla&apos;); 结束当前响应 response.end(); 如果没有结束响应，前端发起请求，会一直等待服务端返回响应,当超时之后就会。。&#125;);4.监听端口号.listen(端口号，callback());app.listen(8080,function()&#123; console.log(&apos;run it at localhost:12345 in your bower&apos;);&#125;);注意： 在客户端输入localhost:8080,页面上会出现字符 在node服务端会显示两次&quot;发送请求&quot;,原因是发送了两次请求 除了自己发送的请求之外，还有浏览器默认的请求，网站的小图标，facvico.ico 2.3 模块特点123456789101112模块：具有独立功能的js文件是一个模块导出: module.exports.xxx = xxx;导入模块： require(&quot;文件路径&quot;);111.jsvar model = require(&apos;./222.js&apos;);console.log(model); &#123;num: 10&#125;console.log(model.num); 10222.jsvar num = 10;module.exports.num = num; 2.4 模块系统2.4.1 导出模块12345678910111213每个js模块都会有一个module.exports对象module.exports.成员名 = 值;var add = function(x,y)&#123; return x + y;&#125;导出module.exports: 原来是个空对象 &#123;&#125;module.exports.add = add;module.exports: &#123;add:function()&#123;&#125; &#125;导入vae model = require(&apos;222.js&apos;);console.log(model.add(1+5)); 2.4.2 导入模块1234567891011121314require方法的注意事项： 1.require方法的作用 导入模块并且执行模块中的代码 var model = require(&quot;./b.js&quot;); 2.require方法 同步加载模块 3.加载模块时，如果后面是js文件，可以不写后缀 var model = require(&quot;./b&quot;); 4.require方法导入模块时，路径是不能省略的，如果省略了，就会当作是自己模块中的方法，会报错。必须添加./或../ require(&apos;b&apos;); 报错，找不到b模块 require(&apos;./b&apos;); 5.不会重复加载 var model1 = require(&apos;./b&apos;); var model2 = require(&apos;./b&apos;); var model3 = require(&apos;./b&apos;); 就会执行一次结果，不会重复执行,会把第一次执行结果，自动缓存，无论后面导入几次，都不会去执行，为了提高性能，提高内存。 2.5 模块分类及第三方包的使用12345678910111213141.核心模块 由module本身自己提供,例如fs文件模块、http模块2.自己定义的模块 自己写的.js文件，按照路径来加载，注意./或者../不能省略3.第三方模块 1)在npm网站找包（模块） https://www.npmjs.com/ npmjs官网 npm -v npm init npm install 包名：安装包,会多node_modules等很多文件 2)打开cmd，使用命令npm install 包名 安装 3)在需要使用的位置，通过require(&apos;第三方包名&apos;)加载包 var $ = require(&apos;jquery&apos;); 第三方包的加载方式和核心模块的方式一样。 4)看文档调用API 3. node命令使用123npm -v 查看npm版本npm initnpm install 包名： npm install jquery 4. npm包管理器4.1 npm是什么1234567npm:Node Package Manager第一次使用npm需要npm initnpm init 一直回车，在项目的目录下，会生成一个配置文件，package.json文件。npm install jquery 1.在目录下,会生成node_module文件，各种第三方包的源码，同时会生成一个package-lock.json文件 2.修改配置文件package.json的信息，在依赖项里面增加包的名字 4.2 npm常用指令1234567891011121.npm init简化 npm init -y 生成package.json 使用这个指令，不需要一直敲回车，会自动生成默认值2.npm install 包名|npm i 包名 会默认下载最新稳定版3.npm install 包名@版本号 下载指定版本的jquery npm install jquery@1.11.2 install可以简写为i4.简写 npm i 包名5.卸载包 npm uninstall 包名 简写为 npm un 包名6.升级/更新包 npm i npm -g 4.3 package.json文件1234dependencies 依赖项:当前项目依赖了哪些包如果只输入npm i会自动的去package.json的dependencies中找依赖的包并下载。npm i 如果写完项目,需要上传到github,不需要上传node_module文件夹，只需上传package.json文件即可。 4.4 package-lock.json文件1231.锁定包的版本 更安全2.锁定包下载地址 第二次下载时速度更快npm5以下的版本不会自动生成 npm5以上版本会自动生成这个文件 4.5 npm使用总结123456npm init -y 生成package.json文件npm i 包名@版本号npm i npm un 包名 卸载包node_modules 不需要关心这个文件夹里面的东西，是各个包package-lock.json:锁定包版本和下载地址 5. ES6介绍12http://es6.ruanyifeng.comECMAScript 6 入门 5.1 ES6关键字 - let12345678910111213141516171819202122var变量： 变量提升 全部变量/局部变量 可以声明同名的变量 没有块级作用域let: 用来声明变量 1.在同一个作用域内不能声明多个同名变量 let a = 10; let a = 20; console.log(a); 报错,a已经声明 2.变量必须先声明再使用，如果直接使用会报错,变量没有被定义，没有变量提升 console.log(a); let a = 10; 变量不会被提升 3.let声明的变量有块级作用域 &#123;&#125; if(1)&#123; let a = 10; &#125; console.log(a); 4.let声明的变量可以被重新赋值 let a= 10; a = 20; console.log(a); 20 5.2 ES6关键字 - const123456789101112const:用来声明常量const a = 10;console.log(a); 10特点： 1.声明的同时必须赋值 const a; 报错，少了一个初始值 2.const声明的常量不能被重新赋值 const a = 10; a = 20; 3.其他特点和let一样 块级作用域 先声明后使用 没有变量提升 在同一个作用域内不能声明多个同名变量 4.如果不知道变量和常量怎么区分，建议全使用const，如果报错，使用let. 5.3 ES6 解构赋值1解构赋值：把变量的值提取出来赋值给新变量的过程 5.3.1 数组的解构赋值12345678910111213141516171819201.var arr = [1,2,3];var [a,b,c] = arr;console.log(a,b,c); 1 2 32.var arr = [1,2,3];var [a,b] = arr;console.log(a,b); 1 23.var arr = [1,2,3];var [a, ,c] = arr;console.log(a,c); 1 34.var arr = [1,2,3];var [a,b,c,d] = arr;console.log(a,b,c,d); 1 2 3 undefined5.var arr = [1,2,3];var [a,b,c,d=20] = arr;console.log(a,b,c,d); 1 2 3 206.交换两个变量的值var a = 10;var b = 20;var [a,b] = [b,a];console.log(a,b); 5.3.2 对象的解构赋值1234567891011121314151617写法一：1.var per = &#123; name: &apos;哈哈哈&apos;， age:19&#125;var &#123;name,age&#125; = per;console.log(name,age); 哈哈哈 192.对象的结构赋值与参数的顺序无关，但参数名必须一样。 var &#123;age,name&#125; = per; 正确 var &#123;xxx,age&#125; = per; 错误3.写法二：给每个key起一个新名字var per = &#123; name: &apos;小四&apos;, age: 20&#125;;var &#123;name:newname, age:newage&#125; = per;console.log(newname,newage); 小四 20 6. ES6字符串新特性6.1 新增API1234567891011121.startsWith()判断字符串是不是以形参的字符串开始，返回值是boolean类型var bool = &quot;abc&quot;.startsWith(&apos;ab&apos;);console.log(bool); true2.endsWith();判断字符串是不是以形参的字符串结尾，返回值是boolean类型var result = &quot;abc&quot;.endsWith(&apos;c&apos;);console.log(result);3.includes();判断字符串是不是包含形参字符，返回值是boolean类型var result = &quot;abc&quot;.includes(&apos;b&apos;);console.log(result); 6.2 模板字符串12345678910111.模板字符串使用的是反引号： 1旁边的符号2.模板用 $&#123;&#125;来填充3.支持换行var per = &#123; name: &apos;哈哈哈&apos;, age:18&#125;;var strHtml = `我的名字是$&#123;per.name&#125;,年龄是$&#123;per.age&#125;`;console.log(strHtml); 7. 函数新特性=&gt;箭头函数7.1 新特性=&gt;形参123456789101112131415161718192021222324252627282930313233343536373839404142431.函数参数可以指定默认值function fn1()&#123; x = x||10; return x;&#125;console.log(fn1());2.函数如果给定了实参，则使用实参，否则的话使用默认值。function fn(x=10)&#123; return x;&#125;console.log(fn());function fn(x=10,y)&#123; return x+y;&#125;console.log(fn(1,2)); 3 3.函数形参可以和数组解构赋值连用function fn2([x,y])&#123; return x+y;&#125;var arr = [10,20];console.log(fn2(arr));4.函数参数 剩余参数...rest ...参数名 相当于argumentsrest 是形参名...rest 保存函数的剩余参数rest是数组...rest 取代arguments 1)function fn3(x,...rest)&#123; console.log(x,rest); &#125; fn3(1,2,3,5); 1 [2,3,5] 2)function fn3(...rest)&#123; console.log(rest); &#125; fn3(1,2,3,5); [1,2,3,5] 3)不能这样写 剩余参数必须写在参数列表的末尾，不能写在首位 function fn4(...rest,x)&#123; &#125; fn4(1,2,3,4); 7.2 新特性=&gt;箭头函数7.2.1 箭头函数=&gt;形参123456789101112131415161718192021222324252627var 函数名 = 形参 =&gt; &#123;函数体&#125;var fn1 = (x) =&gt; &#123; return x;&#125;console.log(fn1(10));1.箭头函数=&gt;形参的不同情况1)没有形参 ()不能省略 var fn = () =&gt; &#123; console.log(10); &#125; fn();2)一个形参,括号可以省略 写法一： var fn = (x) =&gt; &#123; console.log(x); &#125; fn(10); 写法二：一个形参，括号可以省略 var fn = x =&gt; &#123; console.log(x); &#125; fn(10);3)多个形参 ()号不能省略var fn3 = (x,y) =&gt; &#123; console.log(x+y);&#125;fn3(10,20); 7.3.2 箭头函数=&gt;函数体12345678910111.只有一句函数体,&#123;&#125;可以省略,默认返回，相当于前面有returnvar fn = (x) =&gt; x;=&gt; 等价于 var fn = (x) =&gt; &#123;return x;&#125;;console.log(fn(10));2.函数体有多行,&#123;&#125;不能省略var fn = (x) =&gt; &#123; x++; return x;&#125;var result = fn(10);console.log(result); 7.3.3 箭头函数=&gt;this问题1234567891011121314151617181920212223242526272829303132333435361.对象中的thisvar per = &#123; name: &apos;哈哈哈&apos;, sayHi: function()&#123; setTimeout(function()&#123; console.log(this.name); //undefined &#125;,1000); &#125; 改为箭头函数 sayHi: () =&gt; &#123; setTimeout(function()&#123; console.log(this.name); //undefined &#125;,1000); &#125; 改为箭头函数,箭头函数中没有自己的this sayHi: () =&gt; &#123; console.log(this); &#123;&#125; 空对象 setTimeout(() =&gt; &#123; console.log(this); &#123;&#125;空对象 ？？？？？？？？？？？？？？？？？？ console.log(this.name); //undefined &#125;,1000); &#125;&#125;2.箭头函数var per = &#123; name: &apos;哈哈哈&apos;, // 改为箭头函数,箭头函数中没有自己的this sayHi: function() &#123; 此时this是per对象 上级作用域:当前对象 setTimeout(() =&gt; &#123; console.log(this.name); //哈哈哈 &#125;,1000); &#125;&#125;per.sayHi(); 123456注意： 1.箭头函数中没有自己的this 2.会逐层向上一级作用域找this 3.箭头函数不可以用于构造函数，因为没有this 4.箭头函数通常用于匿名函数，在写匿名函数时，最好变成箭头函数，好处是：不需要关心this的指向变来变去，会自动找this的产生效应的位置。 定时器 8. 导出模块成员的几种写法12345678910写法1: 导出多个成员b.jsvar num = 100;var add = function()&#123;&#125;module.exports.num = num;module.exports.add = add;a.jsvar model = require(&apos;./b.js&apos;);console.log(model); 123456789写法2：导出多个成员exports相当于module.exports别名var num = 100;var add = function()&#123;&#125;console.log(exports); //&#123;&#125;exports.num = num;exports.add = add;console.log(exports); &#123;num:100,add:fun&#125;console.log(module.exports === exports); true 12345678910写法3:导出一个成员var num = 100;var add = function()&#123;&#125;module.exports = &#123; num: num, add: add&#125;;module.exports = 100;如果只导出一个成员，不能使用exports,使用的是module.exports。如果使用exports导出一个成员，在另一个页面导入后，为&#123;&#125;空对象。 12345678910111213每个模块末尾默认导出的是module.exports；return module.exports;如果只导出一个成员，不能使用exports。解释： 原来 module.exports = &#123;&#125;; module.exports = exports; exports = &#123;&#125;; 如果只导出一个成员,那么 exports = &#123; name:&apos;&apos;, fn:function()&#123;&#125; &#125;; 相当于给exports重新赋值,改变this的指向 123451.导出多个成员时 module.exports.成员= 值2.导出多个成员时 exports.成员= 值3.导出一个成员时 module.exports = 成员每个模块最终导出的是module.exports，而不是exports当导出一个成员时,使用exports不可以。 9. express9.1 express介绍及安装123456789express是基于node.js平台开发出来的一个框架。可以搭建服务器express官方文档： expressjs.com中文网: www.expressjs.com.cn安装express npm i express package.json：文件中会多一个express配置项使用express需要先导入 var obj = require(&apos;express&apos;); 9.2 体验express代码1234567891011121314151617181920使用express提供的API快速搭建服务器1.使用node2.使用express 1)导包 const express = require(&apos;express&apos;); express是一个对象，同时自带一个方法，express中的所有方法，都需要express方法的返回值去调用。 2）实例化app const app = express(); 3)配置路由 监听客户端请求 请求方式是get 请求标识是/ 服务端要做处理 app.get(请求标识，callback(req,res)); app.get(&apos;/&apos;,function(req,res)&#123; res.write(&quot;asfsdaf----&quot;); res.end(); &#125;); 4)监听端口 app.listen(端口,函数); app.listen(12345，function()&#123; console.log(&quot;run it=----&quot;); &#125;); 9.3 express路由123456789101112131415161718路由配置|路由分发：根据客户端不同的请求（请求方式、请求标识），服务端去做不同的处理app.get(&apos;/&apos;,(req,res)=&gt;&#123; res.write(&apos;dfd&apos;); res.end();&#125;);app.get(&apos;/login&apos;,(req,res)=&gt;&#123; res.write(&apos;sdafsaf&apos;); res.end();&#125;);app.post(&apos;login&apos;,(req,res)=&gt;&#123; res.write(&apos;ssdafafsaf&apos;); res.end();&#125;);注意：res.write(&apos;ssdafafsaf&apos;);res.end();这两个方法可以简化为res.send(&apos;sfad&apos;); 9.4 返回字符串到页面1234567891011121)导包const express = require(&apos;express&apos;);2）实例化const app = express();3）配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.send(&apos;&lt;p&gt;我是p标签&lt;/p&gt;&apos;);&#125;);4）监听端口app.listen(12345,()=&gt;&#123; console.log(&apos;run it as localhost&apos;);&#125;); 1234567891011121314151617181920const fs = require(&apos;fs&apos;);const express = require(&apos;express);const app = express();app.get(&apos;/&apos;,(req,res) =&gt; &#123; 读取页面文件 编码格式 fs.readFile(&apos;./login.html&apos;,(err,data) =&gt; &#123; 把十六进制转化为字符串 data = data.toString(); res.send(data); &#125;);&#125;);app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localost&apos;);&#125;);如果不使用toString()方法，则需要在参数中添加一个utf8格式fs.readFile(&apos;./login.html&apos;, &quot;utf8&quot;, (err,data) =&gt; &#123; res.send(data);&#125;） 10. 留言板案例10.1 案例说明和准备1234567目的： 练习express中的常用API 熟悉ES6中的新特性: const 箭头函数()=&gt;&#123;&#125; 使用常用的第三方包,如mysql express-art-template介绍： 留言板列表页 新增页面 10.2 搭建服务器123456789101112131415161718191.创建一个空文件夹 先初始化文件: npm init -y 安装express包: npm i express2.新建一个js文件app.js// 搭建服务器// 导包const express = require(&apos;express&apos;);const app = express();// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; // res.write(&apos;sfafsaklf&apos;); // res.end(); res.send(&apos;/////&apos;);&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 10.3 服务端渲染列表页123456789101112131415161718app.js// 搭建服务器// 导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const app = express();// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; // res.write(&apos;sfafsaklf&apos;); // res.end(); fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; res.send(data); &#125;);&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 12345678910111213141516171819202122232425262728293031323334353637383940index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;留言板列表&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; a &#123; display: block; margin: 20px; &#125; ul &#123; margin-left: 20px; list-style: none; &#125; li &#123; height: 30px; line-height: 30px; &#125; .name &#123; padding: 0 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;留言板案例&lt;/h1&gt; &lt;a href=&quot;/publish&quot;&gt;发布留言&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;小宝&lt;/span&gt;&lt;span&gt;hahhhhahhahh&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 10.4 模板引擎渲染页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601.使用假数据操作数据库=&gt;获取数据 const list = &#123; items: [&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;, &#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aa.com&apos;, content: &apos;aaaaaaaaaaaa&apos; &#125;] &#125;2.下载模板引擎 官方文档: http://aui.github.io/art-template/zh-cn/docs/syntax.html npm install art-template 下载包之后,在package.json文件中配置项中会增加art-template 1)导包 const template = require(&apos;art-template&apos;); 2)使用方法 在渲染页面的同时把数据添加进去 template.render(source,data,options); source:页面字符串 data:该页面要使用的数据 要求类型是：&#123;&#125;对象 options:可选项 返回值: 携带了数据的页面字符串 3）配置路由 app.get(&apos;/&apos;,(req,res) =&gt; &#123; // res.write(&apos;sfafsaklf&apos;); // res.end(); fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; 模板引擎 var strHtmlWithData = template.render(data,&#123; items: list.items &#125;); res.send(strHtmlWithData); &#125;); &#125;); 4）渲染页面 &lt;ul&gt; &#123;&#123;each items&#125;&#125; &lt;li&gt;&lt;span class=&apos;name&apos;&gt;&#123;&#123;$value.name&#125;&#125;&lt;/span&gt;&lt;span&gt;&#123;&#123;$value.content&#125;&#125;&lt;/span&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; 10.5 编辑页面搭建1234567891011121314151617181920212223242526272829303132333435363738394041publish.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;编辑页面&lt;/title&gt; &lt;style&gt; label &#123; display: inline-block; width: 80px; text-align: right; &#125; .box &#123; margin-top: 10px; &#125; #btn &#123; margin-left: 85px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;添加留言&lt;/h1&gt; &lt;form action=&quot;/publish&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;label for=&quot;&quot;&gt;名字:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&apos;名字&apos;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;label for=&quot;&quot;&gt;邮箱:&lt;/label&gt; &lt;input type=&quot;url&quot; name=&quot;email&quot; value=&apos;邮箱&apos;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;label for=&quot;&quot;&gt;评论内容:&lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&apos;btn&apos;&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 10.6 服务端渲染编辑页面123456781.列表页 &lt;a href=&apos;/publish&apos;&gt;&lt;/a&gt;2.http.js文件中 配置路由 app.get(&apos;/publish&apos;,(req,res) =&gt; &#123; fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; res.send(data); &#125;); &#125;); 10.7 第三方包-express-art-template123456789101112131415161718192021222324使用第三方包简化配置路由的代码: express-art-template1.安装包: npm i express-art-template 使用express-art-template包时,需要下载包art-template，依赖此包 npm install --save art-template npm install --save express-art-template2.配置express-art-template包并且导入包 当渲染后缀是html的文件时 使用express-art-template进行渲染 结果是res对象增加一个方法render() res.render();原来没有这个方法，是配置并引入express-art-template包之后增加的方法 app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));3.配置路由简化代码app.get(&apos;/&apos;, function (req, res) &#123; res.render(参数1，参数2); 参数1：要渲染的文件的名字 自动的去文件夹名为views的下面去找文件后缀为html的文件， 文件夹名必须为views,不能任意命名 参数2：类型为对象 该文件要用的数据 res.render(&apos;index.html&apos;, &#123; items: list.items &#125;);&#125;);4. res.render()方法内部做的事 1)fs读文件 2)使用模板引擎处理数据 3)发送页面字符串并且结束响应 12345678910111213141516171819202122232425262728293031323334353637383940414243简化后的代码// 搭建服务器// 导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const template = require(&apos;art-template&apos;);const app = express();// 第一步：配置并导入包// 结果是为res对象添加了一个方法 render();app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));const list = &#123; items: [&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;,&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;]&#125;;// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.render(&apos;index.html&apos;,&#123; items: list.items &#125;); // fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // var strHtmlWithData = template.render(data,&#123; // items: list.items // &#125;); // res.send(strHtmlWithData); // &#125;);&#125;);app.get(&apos;/publish&apos;,(req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); // fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // res.send(data); // &#125;);&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 10.8 获取表单post请求的表单数据req1234567891011121314151617增加第三方包给req请求对象增加一个body属性来获取表单数据// post请求的数据 隐藏在请求的请求体中// 通过第三方包body-parser 给req增加属性 body -&gt; 请求体数据// req.body就是post请求中的表单数据 &#123;&#125;1.安装包 npm i body-parser2.导包 var bodyParser = require(&apos;body-parser&apos;);3.配置body-parser app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); app.use(bodyParser.json());4.获取表单数据 app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; req.body就是post请求中的表单数据 console.log(req.body); //&#123; name: &apos;dg&apos;, email: &apos;saf&apos;, content: &apos;safdafafs&apos; &#125; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445表单&lt;form action=&quot;/publish&quot; method=&apos;post&apos;&gt;&lt;/form&gt;// 搭建服务器// 导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const template = require(&apos;art-template&apos;);// 给req增加一个body属性来获取表单中的数据const bodyParser = require(&apos;body-parser&apos;);const app = express();// 配置body-parserapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 第一步：配置并导入包// 结果是为res对象添加了一个方法 render();app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));const list = &#123; items: [&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;,&#123; name: &apos;aaa&apos;, eamil: &apos;aaa@aaa.com&apos;, content: &apos;aaaaaaaaa&apos; &#125;]&#125;;// 配置路由app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.render(&apos;index.html&apos;,&#123; items: list.items &#125;);&#125;);app.get(&apos;/publish&apos;,(req,res) =&gt; &#123; res.render(&apos;publish.html&apos;);&#125;);app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; console.log(req.body); //获取表单请求体中的数据&#125;);// 监听端口app.listen(12345,() =&gt; &#123; console.log(&apos;run it as localhost:12345&apos;);&#125;); 10.9 编辑页—更新数据12345678获取表单数据 =&gt; post请求 =&gt; 请求体里 =&gt; body-parser =&gt; req.body =&gt; &#123;&#125;获取到表单数据 =&gt; 将数据添加到items对象中app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; // console.log(req.body); const body = req.body; list.items.unshift(body); console.log(list);&#125;); 10.10 编辑页—重定向到列表页12345在list数组数据变化之后，回到列表页将/publish的标识改为/由于服务端没有BOM和DOM,所以不能使用window.location.href = &apos;/&apos;;使用服务端重定向的方法,将/publish的标识改为/,跳转到列表页res.redirect(&quot;/&quot;); 根据/表示发送的请求，重新渲染页面 1234567app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; // console.log(req.body); const body = req.body; list.items.unshift(body); 页面重定向 res.redirect(&quot;/&quot;);&#125;); 11. 数据持久化-本地文件11.1 数据持久化-本地文件-列表数据1234567每次重新启动服务器，之前添加的数据都没有了数据持久化1.本地文件保存数据2.操作数据库步骤: 1.把数据保存在data.json文件中 2.读取文件中的数据,把字符串转化为json对象 12345678910111213141516171819202122232425262728293031data.jsonjson文件中，key和value都必须使用双引号包裹&#123; &quot;items&quot;: [ &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125;, &#123; &quot;name&quot;: &quot;aaa&quot;, &quot;eamil&quot;: &quot;aaa@aaa.com&quot;, &quot;content&quot;: &quot;aaaaaaaaa&quot; &#125; ]&#125; 123456789101112http.jsapp.get(&apos;/&apos;,(req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;);&#125;); 11.2 数据持久化-本地文件-编辑数据123456789101112131415161718192021如果要写入数据，先把文件中的数据拿出来app.post(&apos;/publish&apos;,(req,res) =&gt; &#123; 通过第三方包获取表单数据 body-parser 0.获取表单数据 const body = req.body; 1.读文件 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; 2.把读取文件中的字符串转化为json对象 data = JSON.parse(data); 3.把获取的表单的数据添加到json对象中 data.items.unshift(body); 5.将json对象转化为json字符串 data = JSON.stringify(data); 4.写入文件 参数: 文件名字 要写入的数据（类型是字符串） 回调函数 fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; 6.页面重定向 res.redirect(&apos;/&apos;); &#125;); &#125;);&#125;); 11.3 请求样式文件的处理123456789101112131415161718192021引入css文件&lt;link rel=&quot;stylesheet&quot; href=&quot;../css/common.css&quot;&gt;1.由于引入文件common.css文件,页面请求的是http://localhost:12345/css/common.css,而服务器并没有对标识为/css/common.css的文件做对应的处理，所以不能访问，客户端请求失败2.在路由配置中，配置对/css/common.css文件的发送请求的处理// 读取样式文件app.get(&apos;/css/common.css&apos;,(req,res) =&gt; &#123; // 当客户端请求这个文件时,服务器读取文件中的内容，将内容响应给客户端 2.1 读取样式文件 fs.readFile(&apos;./css/common.css&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // console.log(data); // 将获取到的内容发送给客户端，由于默认的返回客户端的响应类型为 text/html,所以没有效果 // 将响应类型设置为text/css 2.2 修改返回给客户端的内容的响应类型 res.setHeader(&apos;Content-Type&apos;,&apos;text/css&apos;); // 返回相应 2.2 返回给客户端 res.send(data); &#125;);&#125;);以上方法，可以处理css样式文件，但是对于处理多个样式文件，这样写起来比较麻烦 11.4 统一处理静态资源(样式文件)12345678910静态资源 样式文件、图片、字体1.使用express的方法来处理 const app = express();2.统一处理所有静态资源文件 static(静态资源文件路径); app.use(express.static(&quot;./css&quot;)); 公开暴露css文件夹的所有静态资源3.在引入静态资源文件时，直接写文件名即可 &lt;link rel=&quot;stylesheet&quot; href=&quot;/common.css&quot;&gt;4.使用此方法，不需要在路由配置中，对静态文件分别处理 11.5 统一处理第三方资源123456789第一种:app.use(只写一个参数);1.安装第三方文件资源 npm i bootstrap2.公开暴露node_modules文件夹下的资源文件 app.use(express.static(&apos;./node_modules&apos;));3.引入样式文件时 &lt;!-- 引入第三方资源文件,直接引入node_modules文件夹下的资源文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/bootstrap/dist/css/bootstrap.css&quot;&gt; 1234567第二种:限定请求的前缀2.公开暴露node_modules文件夹下的资源文件当请求标识是以/abc开始的,暴露node_modules文件夹下的资源文件app.use(&apos;/abc&apos;,express.static(&apos;./node_modules&apos;));3.引入样式文件时 &lt;!-- 引入第三方资源文件,资源文件的标识是/abc --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/abc/bootstrap/dist/css/bootstrap.css&quot;&gt; 123公开根目录下的所有资源文件app.use(express.static(&apos;./&apos;));但是不要这么些，不安全 11.6 统一处理静态资源-小结123456789101112配置包//处理资源 // 1. 自己静态资源app.use(express.static(&quot;./public&quot;))// app.use(&quot;/abc&quot;, express.static(&quot;./public&quot;))// app.use(&quot;/public&quot;, express.static(&quot;./public&quot;))// 2. 第三方资源// app.use(express.static(&quot;./node_modules&quot;))app.use(&quot;/node_modules&quot;, express.static(&quot;./node_modules&quot;))// 3. 统一配置// app.use(express.static(&quot;./&quot;)); 12345678对应的客户端代码1.自己静态资源&lt;link rel=&quot;stylesheet&quot; href=&quot;/base.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/abc/main.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/main.css&quot;&gt; 2.第三方资源&lt;link rel=&quot;stylesheet&quot; href=&quot;/bootstrap/dist/css/bootstrap.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&gt; 11.7 提取路由模块123456789101112131415161718192021222324252627282930313233343536373839http.js 是一个程序入口文件入口文件作用：监听端口 启动服务1.将文件中配置路由的代码提取出来封装成一个模块模块是具有独立功能的js文件2.提取路由模块 router.js 配置路由 1) 导包 const fs = require(&apos;fs&apos;); const express = require(&apos;express&apos;); 2) 实例化路由router const router = express.Router(); 3) 配置路由 router.get(&apos;/&apos;,(req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;); &#125;); router.get(&apos;/publish&apos;,(req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); &#125;); router.post(&apos;/publish&apos;,(req,res) =&gt; &#123; // console.log(req.body); const body = req.body; fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; data = JSON.parse(data); data.items.unshift(body); data = JSON.stringify(data); fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; res.redirect(&apos;/&apos;); &#125;); &#125;); &#125;); 4) 导出router对象 module.exports = router; 1234567在程序入口文件中导入1.导包const router = require(&apos;./router&apos;);2.配置3.使用路由app.use(router);4.监听端口 注意 12345fs的导入包的位置要修改app.use(router);代码位置放在配置包的后面 (先配置包,再使用包)入口程序模块: 监听端口启动服务配置路由模块：具有独立功能的js文件路由模块文件：监听请求 并且找到对应的处理函数 11.8 提取处理函数模块1把路由router.js模块中处理函数的具体实现的代码提取出来放在一个单独的模块中 router01.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950导出方法，封装在函数中// 1.导包const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);const router = express.Router();// 2.配置路由模块// 封装函数处理的具体代码// 渲染列表页const showList = (req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;); // fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // var strHtmlWithData = template.render(data,&#123; // items: list.items // &#125;); // res.send(strHtmlWithData); // &#125;);&#125;;// 编辑页const edit = (req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); // fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // res.send(data); // &#125;);&#125;;// 从编辑页跳转到列表页const editList = (req,res) =&gt; &#123; // console.log(req.body); const body = req.body; fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; data = JSON.parse(data); data.items.unshift(body); data = JSON.stringify(data); fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; res.redirect(&apos;/&apos;); &#125;); &#125;);&#125;;router.get(&apos;/&apos;,showList);router.get(&apos;/publish&apos;,edit);router.post(&apos;/publish&apos;,editList);// 3.导出模块成员module.exports = router; router02.js 12345678910111213导出方法，将封装的函数放在另一个模块中,并在此模块中引入// 1.导包const fun = require(&apos;./fun&apos;);const express = require(&apos;express&apos;);const router = express.Router();// 2.配置路由模块// 封装函数处理的具体代码// 渲染列表页router.get(&apos;/&apos;,fun.showList);router.get(&apos;/publish&apos;,fun.edit);router.post(&apos;/publish&apos;,fun.editList);// 3.导出模块成员module.exports = router; fun02.js 12345678910111213141516171819202122232425262728293031323334353637383940// 1.导包const fs = require(&apos;fs&apos;);// 2.导出模块成员module.exports.showList = (req,res) =&gt; &#123; // 从文件中读取数据 fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error, data) =&gt; &#123; // 从文件中读取出来的是json字符串 // JSON.parse(data); 将字符串转化为json对象 data = JSON.parse(data); res.render(&apos;index.html&apos;,&#123; items: data.items &#125;); &#125;); // fs.readFile(&apos;./index.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // var strHtmlWithData = template.render(data,&#123; // items: list.items // &#125;); // res.send(strHtmlWithData); // &#125;);&#125;;// 编辑页module.exports.edit = (req,res) =&gt; &#123; res.render(&apos;publish.html&apos;); // fs.readFile(&apos;./publish.html&apos;,&quot;utf8&quot;,(error,data) =&gt; &#123; // res.send(data); // &#125;);&#125;;// 从编辑页跳转到列表页module.exports.editList = (req,res) =&gt; &#123; // console.log(req.body); const body = req.body; fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; data = JSON.parse(data); data.items.unshift(body); data = JSON.stringify(data); fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; res.redirect(&apos;/&apos;); &#125;); &#125;);&#125;; 12. 数据持久化-mysql操作数据库12.1 数据持久化-mysql包体验-配置123456789101112131415161718192021222324252627282930在node中操作数据库实现数据持久化使用第三方包 mysql:在node环境下操作mysql数据库文档参考:https://www.npmjs.com/package/mysql1.安装mysql包 npm install mysql2.配置mysql文档 // 1.导包 var mysql = require(&apos;mysql&apos;); // 2.配置mysql var connection = mysql.createConnection(&#123; //主机 host : &apos;localhost&apos;, //用户名 user : &apos;root&apos;, //密码 password : &apos;root&apos;, //数据库名 database : &apos;message&apos; &#125;); // 3.开启链接 connection.connect(); // 4.执行sql语句 connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123; if (error) throw error; console.log(&apos;The solution is: &apos;, results[0].solution); &#125;); fields:可选参数 // 5.关闭数据库连接 connection.end(); 3.必须开启mysql服务 12.2 mysql-查询12345678910111213141516171819202122sql语句: var str = &quot;select * from `posts`&quot;;如果添加了反引号,就算字符串之间紧挨着也能识别是表名。// 4.执行sql语句// 1.返回结果 results是数组，数组里面是对象 每个对象是一条数据// var sqlStr = &quot;select * from `posts`&quot;;// 2.返回结果results 是数组 数组里面是满足条件的数据 对象// var sqlStr = &quot;select * from `posts` where id=1&quot;;// 3.sql语句中的？是一个占位符 ，相当于是形参，在query方法中的第二个参数是？号处的值 ？号是mysql包给我们提供的// const ID = 1;// var sqlStr = &quot;select * from `posts` where id=?&quot;;// connection.query(sqlStr,ID, function (error, results) &#123;// if (error) throw error;// console.log(results);// &#125;);// 4.sql语句中查询的是多个条件 query函数中，第二个参数传入的是数组var name=&apos;abc&apos;;var content = &apos;ss&apos;;var sqlStr = &quot;select * from `posts` where name = ? and content = ?&quot;;connection.query(sqlStr,[name,content], function (error, results) &#123; if (error) throw error; console.log(results);&#125;); 12.3 mysql-插入、增加1234567891011121314mysql中，除了查询返回的是数组，其他都是对象。对象中的key是字段名，不可以乱写添加使用关键字 setresults:返回的是对象const item = &#123; name:&apos;chengsong&apos;, content:&apos;tama&apos;, mail:&apos;ccc@ccc.com&apos;, date: &apos;2014-11-11&apos;&#125;const sqlStr = &apos;insert into `posts` set ?&apos;;connection.query(sqlStr,item,(err,results) =&gt; &#123; consoel.log(results);&#125;); 结果 12345678910OkPacket &#123; fieldCount: 0, affectedRows: 1, insertId: 259, serverStatus: 2, warningCount: 0, message: &apos;&apos;, protocol41: true, changedRows: 0 &#125; 12.4 mysql-修改和删除12345678修改: 修改id为1的数据 把name改为xxx const ID = 1; const name = &apos;xxx&apos;; const sqlStr = &apos;update `posts` set name = ? where id = ?&apos;; connection.query(sqlStr,[name,ID],(error,results) =&gt; &#123; console.log(results); &#125;); 1234567删除: 删除数据id=257的数据 const id = 257; const sqlStr = &apos;delete from `posts` where id = ?&apos;; connection.query(sqlStr,[id],(error,results)=&gt;&#123; console.log(results); &#125;); 123总结： 查询返回的是数组 增删改返回的是对象 13. 全局命令行工具的使用-nodemon1234安装全局的包，每次修改代码后不需要重启服务器，会自动重启。安装全局的包: nodemon npm i nodemon -g使用 nodemon 文件名 的方式自动重启服务器 13.1 全局命令行工具12345678910111213npm git:在任意路径下都可以使用/全局安装/指令操作1.nodemon:自动重新执行文件 全局安装 npm i nodemon -g 运行: nodemon 文件名2.http-server:快速开启本地服务器 把一个文件夹变成服务器的根目录,同时启动该服务 安装: npm i http-server -g 指令: http-server 启动服务器 http-server -o 启动服务器的同时打开浏览器 http-server -o -p 8081 启动服务器的同时打开浏览器并修改端口3.查看全局命令行工具安装的位置 npm root -g 13.2 自定义指令123456789自定义指令：把很长的指令简化为一个简单的指令npm提供的功能1.在package.json文件中: 修改script键中的值： &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node app.js&quot; &#125;2.在npm中运行 npm run build相当于是运行node app.js 14. 留言板数据持久化-mysql14.1 mysql-列表数据fun.js 123456789101112131415161718192021222324252627282930// 1.导包const mysql = require(&apos;mysql&apos;);// 2.配置mysqlconst connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;message&apos;&#125;);// 3.开启链接connection.connect();// 2.导出模块成员module.exports.showList = (req,res) =&gt; &#123; // 从数据库中读取文件 // 4.执行sql语句 const sqlStr = &apos;select * from `posts` order by id desc&apos;; connection.query(sqlStr,(error,results) =&gt; &#123; if(error)&#123; throw error; &#125; // console.log(results); // 将数据通过模板引擎渲染到页面上 res.render(&apos;index.html&apos;,&#123; items: results &#125;); &#125;);&#125;;最后不能关闭数据库 14.2 mysql-编辑数据12345678910111213141516171819202122232425262728293031// 从编辑页跳转到列表页module.exports.editList = (req,res) =&gt; &#123; // console.log(req.body); const body = req.body; body.date = new Date(); //body对象的key必须和数据库字段一样 // mysql增加mysql语句 const sqlStr = &apos;insert into `posts` set ?&apos;; connection.query(sqlStr,body,(error,results) =&gt; &#123; if(error) &#123; throw error; &#125; // console.log(results); res.redirect(&apos;/&apos;); &#125;); // fs.readFile(&apos;./data.json&apos;,&apos;utf8&apos;,(error,data) =&gt; &#123; // data = JSON.parse(data); // data.items.unshift(body); // data = JSON.stringify(data); // fs.writeFile(&apos;./data.json&apos;,data,(error) =&gt; &#123; // res.redirect(&apos;/&apos;); // &#125;); // &#125;);&#125;;最后不能关闭数据库 14.3 mysql使用注意123数据库操作是异步操作：后面的代码不等待前面的代码执行完就继续执行 最后不能关闭数据库常见异步操作: ajax 事件 定时器 数据库操作 15. 文件分析12345app.js 程序入口函数router.js 路由配置(监听请求)handle.js 实现处理函数views/ 视图 html文件public/ 静态资源文件 16. 回调函数16.1 回调函数-基本使用123456789101112131415需求场景:想在函数外部 获取到函数内部异步操作里面的结果解决方法:在异步操作有结果的位置，调用函数，把结果以实参方式进行传递function add(x,y，fn)&#123; console.log(1); setTimeout(function()&#123; var temp = x+y; fn(temp); &#125;,1000); console.log(2);&#125;add(5,7,function(x)&#123; console.log(x);&#125;);结果为: 1 2 12 16.2 回调函数-应用-封装ajax1234567891011function get(url,callback)&#123; var xhr = new XMLHttpRequest(); xhr.onload = function()&#123; callback(responseText); &#125; hr.open(&apos;get&apos;,url); xhr.send();&#125;get(&apos;index.js&apos;,function(data)&#123; console.log(data);&#125;); 扩展思路12345678910先用express搭建服务器： 下载-&gt;导包-&gt;实例化-&gt;配置路由(根据不同请求标识,服务端做不同处理)-&gt;监听端口 渲染列表页：文件模块读取文件，并将返回的结果渲染渲染到页面 模板引擎渲染列表数据 编辑页面搭建 在app.js文件中 根据不同的标识 服务端做不同处理 下载express-art-template包，可以解决： 文件读取、模板引擎渲染、结束服务器响应等问题 编辑页面post请求,安装包body-parser为req增加body属性，获取请求的数据统一处理所有的静态资源： app.use(express.static(&quot;./css&quot;)); 统一暴露css文件夹下所有的静态资源文件 闭包1避免全局变量被污染 改变this的指向的方法1234567891011121314151)通过变量，将this的值指向该变量2）通过bind(),apply(),call()来改变this的指向 var per = &#123; name: &apos;sfdsa&apos;, sayHai: function()&#123; console.log(this.name); &#125; &#125;; per.sayHai.call(null); per.sayHai.call(obj); 将this的指向改变为obj per.sayHai.call(obj,num1,num2); 将this的指向改变为obj per.sayHai.apply(obj,[num1,num2]); setTimeout(function()&#123; console.log(this.name); &#125;.bind(this),1000); 箭头函数this的指向 问题1234567891011var per = &#123; name: &apos;哈哈哈&apos;, sayHi: () =&gt; &#123; console.log(this); &#123;&#125; setTimeout(() =&gt; &#123; console.log(this); &#123;&#125; console.log(this.name); //undefined &#125;,1000); &#125;&#125;per.sayHi(); npm上下载包名12https://www.npmjs.com搜索包名=&gt;下载 文档链接12345678910npm https://www.npmjs.comexpress中文文档 http://www.expressjs.com.cn/en/guide/routing.htmlexpress英文文档 http://expressjs.com/en/guide/routing.htmlnodejs.cn node中文网https://nodejs.org/en 英文网node社区: https://cnodejs.orgnpm网站找包（模块） https://www.npmjs.com/ npmjs官网express官方文档： expressjs.com中文网: www.expressjs.com.cnnpm模板引擎官方文档: http://aui.github.io/art-template/zh-cn/docs/syntax.html 定时器异步加载123456789101112131415161718192021222324251.function add(x,y)&#123; console.log(1); setTimeout(function()&#123; console.log(3); return x+y; &#125;,1000); console.log(2);&#125;var result = add(1,3);console.log(result);12undefined3由于定时器异步加载,定时器还没执行完代码已经执行完毕了,所以result的结果为undefined。2.function add(x,y)&#123; var temp; setTimeout(function()&#123; temp = x+y; &#125;,1000); return temp;&#125;var result = add(1,3);console.log(result);结果为undefined,原因是定时器异步加载]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动web]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2F%E7%A7%BB%E5%8A%A8web%2F</url>
    <content type="text"><![CDATA[移动web1. 视口123456789101112131415161718192021viewport: meta:vp&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;width:设置宽度等于设备宽度user-scalable:设置是否允许用户自行缩放 yes or noinitial-scale:设置缩放比例maximum-scale:设置最大缩放比例minimum-scale:设置最小缩放比例获取屏幕的设备大小 var screenWidth = window.screen.width; var screenHeight = window.screen.height; 像素问题： pc设备下 1pt/dp(独立像素) = 1px(物理像素) iPhone5/6/7/8 1pt/dp(独立像素) = 2px(物理像素) iPhone6/7/8plus/x 1pt/dp(独立像素) = 3px(物理像素) 如果你是一个 android 程序员 在编写代码使用 dp 如果你是一个 ios 程序员 在编写代码使用 pt 如果你是一个 前程 序员 在编写代码使用 px(css长度单位) 1px(css) = 1px(物理) 1px(css) = 2px(物理) 1px(css) = 3px(物理) 2. 京东页面公共样式123456789101112131415161718192021222324252627282930313233343536373839404142434445*,::before,::after&#123; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent;/*去除移动端特有的点击高亮效果，清除点击默认的高亮效果*/ -webkit-box-sizing: border-box;/*以你的border开始计算你的宽度*/&#125;body&#123; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;,sans-serif;/*第二个是手机的一个默认的字体*/ color: #000;&#125;a&#123; text-decoration: none; color: #000;&#125;ul&#123; list-style: none;&#125;input,textarea&#123; border: none; resize: none; outline: none;/*清除选中效果*/ -webkit-appearance: none;/*清楚浏览器默认的样式*/&#125;img &#123; 解决图片底部3像素问题 vertical-align:middle; // display:block;&#125;/*清除浮动*/.clearfix::before,.clearfix::after&#123; content: &quot;.&quot;; display: block; height: 0; line-height: 0; visibility: hidden; clear: both;&#125;[class^=&quot;icon_&quot;]&#123; background: url(&quot;../images/sprites.png&quot;) no-repeat; background-size: 200px 200px;&#125; 3. 固定导航栏布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801)使用伸缩布局2）使用margin：0 auto； logo和登录使用相对定位来布局3）padding: 0px 100px; 双飞翼布局&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .container &#123; width: 1140px; height: 10000px; margin: 0 auto; background: yellowgreen; max-width: 640px; min-width: 320px; &#125; .container .logo &#123; width: 100%; height: 50px; max-width: 640px; min-width: 320px; background: rgba(0, 0, 0, 0.5); position: fixed; &#125; .container .logo .logo-left &#123; width: 100px; height: 50px; position: absolute; top: 0; left: 0; background: green; &#125; .container .logo form &#123; width: 100%; height: 50px; padding: 0 100px; /* background: yellow; */ /* position: absolute; z-index: 99; */ &#125; /* .container .logo form input &#123; width: 300px; height: 60px; &#125; */ .container .logo .logo-right &#123; width: 100px; height: 50px; position: absolute; top: 0; right: 0; background: green; &#125; .bottom &#123; width: 100%; height: 800px; background: red; border: 1px solid #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;logo&quot;&gt; &lt;div class=&quot;logo-left&quot;&gt;sfskaf&lt;/div&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;&quot;&gt; &lt;/form&gt; &lt;div class=&quot;logo-right&quot;&gt;登录&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. 移动端二倍图设置123background:url(../image/sprite.png);background-size:200px 200px; 缩小二倍图background-position: 0 -120px; 5.京东首页搜索块js效果121)设置默认搜索栏的背景色为rgba(0,0,0,0.85);2)判断页面向上滚动的距离与轮播图高度的大小，如果大于，则设置搜索栏的透明度为固定值0.85，否则的话透明度随着高德的变化而变化 6. 京东倒计时效果121)使用定时器2)最后判断倒计时的值是不是小于0，如果小于0，则设置为00：00：00,清理定时器。 7. 京东轮播图7.1 使用js实现轮播图布局效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/*1.设置修改轮播图的页面结构* a.在开始位置添加原始的最后一张图片* b.在结束位置添加原始的第一张图片*//*1.1.获取轮播图结构*/ var banner=document.querySelector(&quot;.jd_banner&quot;);/*1.2.获取图片容器*/ var imgBox=banner.querySelector(&quot;ul:first-of-type&quot;);/*1.3.获取原始的第一张图片*/ var first=imgBox.querySelector(&quot;li:first-of-type&quot;);/*1.4.获取原始的最后一张图片*/ var last=imgBox.querySelector(&quot;li:last-of-type&quot;);/*1.5.在首尾插入两张图片 cloneNode:复制一个dom元素*/ imgBox.appendChild(first.cloneNode(true));/*insertBefore(需要插入的dom元素，位置)*/ imgBox.insertBefore(last.cloneNode(true),imgBox.firstChild);/*2.设置对应的样式*//*2.1获取所有li元素*/ var lis=imgBox.querySelectorAll(&quot;li&quot;);/*2.2 获取li元素的数量*/ var count=lis.length;/*2.3.获取banner的宽度*/ var bannerWidth=banner.offsetWidth;/*2.4 设置图片盒子的宽度*/ imgBox.style.width=count*bannerWidth+&quot;px&quot;;/*2.5 设置每一个li(图片)元素的宽度*/ for(var i=0;i&lt;lis.length;i++)&#123; lis[i].style.width=bannerWidth+&quot;px&quot;; &#125;/*3.设置默认的偏移*/ imgBox.style.left=-bannerWidth+&quot;px&quot;;/*定义图片索引:图片已经有一个宽度的默认偏移*/ var index=1;/*4.当屏幕变化的时候，重新计算宽度*/ window.onresize=function()&#123; /*4.1.获取banner的宽度,覆盖全局的宽度值*/ bannerWidth=banner.offsetWidth; /*4.2 设置图片盒子的宽度*/ imgBox.style.width=count*bannerWidth+&quot;px&quot;; /*4.3设置每一个li(图片)元素的宽度*/ for(var i=0;i&lt;lis.length;i++)&#123; lis[i].style.width=bannerWidth+&quot;px&quot;; &#125; /*4.4重新设置定位值*/ imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; var timerId; /*5.实现自动轮播*/ var startTime=function()&#123; timerId=setInterval(function()&#123; /*5.1 变换索引*/ index++; /*5.2.添加过渡效果*/ imgBox.style.transition=&quot;left 0.5s ease-in-out&quot;; /*5.3 设置偏移*/ imgBox.style.left=(-index*bannerWidth)+&quot;px&quot;; /*5.4 判断是否到最后一张，如果是则*/ setTimeout(function()&#123; if(index==count-1)&#123; console.log(index); index=1; /*如果一个元素的某个属性之前添加过过渡效果，那么过渡属性会一直存在，如果不想要，则需要清除过渡效果*/ /*关闭过渡效果*/ imgBox.style.transition=&quot;none&quot;; /*偏移到指定的位置*/ imgBox.style.left=(-index*bannerWidth)+&quot;px&quot;; &#125; &#125;,500); &#125;,2000); &#125; startTime(); /*6.实现手动轮播*/ var startX,moveX,distanceX; /*为图片添加触摸事件--触摸开始*/ imgBox.addEventListener(&quot;touchstart&quot;,function(e)&#123; /*清除定时器*/ clearInterval(timerId); /*获取当前手指的起始位置*/ startX= e.targetTouches[0].clientX; &#125;); /*为图片添加触摸事件--滑动过程*/ imgBox.addEventListener(&quot;touchmove&quot;,function(e)&#123; /*记录手指在滑动过程中的位置*/ moveX= e.targetTouches[0].clientX; /*计算坐标的差异*/ distanceX=moveX-startX; /*为了保证效果正常，将之前可能添加的过渡样式清除*/ imgBox.style.transition=&quot;none&quot;; /*实现元素的偏移 left参照最原始的坐标 * 重大细节：本次的滑动操作应该基于之前轮播图已经偏移的距离*/ imgBox.style.left=(-index*bannerWidth + distanceX)+&quot;px&quot;; &#125;); /*添加触摸结束事件*/ /*touchend:松开手指触发*/ imgBox.addEventListener(&quot;touchend&quot;,function(e)&#123; /*获取当前滑动的距离，判断距离是否超出指定的范围 100px*/ if(Math.abs(distanceX) &gt; 100)&#123; /*判断滑动的方向*/ if(distanceX &gt; 0)&#123;//上一张 index--; &#125; else&#123; //下一张 index++; &#125; /*翻页*/ imgBox.style.transition=&quot;left 0.5s ease-in-out&quot;; imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; else if(Math.abs(distanceX) &gt; 0)&#123; //得保证用户确实进行过滑动操作 /*回弹*/ imgBox.style.transition=&quot;left 0.5s ease-in-out&quot;; imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; //重新开启定时器 startTime(); &#125;); /*webkitTransitionEnd:可以监听当前元素的过渡效果执行完毕，当一个元素的过渡效果执行完毕的时候，会触发这个事件*/ imgBox.addEventListener(&quot;webkitTransitionEnd&quot;,function()&#123; /*如果到了最后一张(count-1)，回到索引1*/ /*如果到了第一张(0)，回到索引count-2*/ if(index==count-1)&#123; index=1; /*清除过渡*/ imgBox.style.transition=&quot;none&quot;; /*设置偏移*/ imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; else if(index==0)&#123; index=count-2; /*清除过渡*/ imgBox.style.transition=&quot;none&quot;; /*设置偏移*/ imgBox.style.left=-index*bannerWidth+&quot;px&quot;; &#125; &#125;); 8. 移动端项目1231)设置项目结构 css font js image index.html2)添加viewport,引入页面样式文件3）写布局 8.1 touch事件1234567891011121314151617181920212223242526272829301.移动端添加事件使用addEventListener来添加： touchstart:手指触摸屏幕时触发 touchmove:手指在屏幕上移动时触发 touchend:手指离开屏幕时触发 touchcancle:触摸意外中断事件 /*添加开始触摸事件：当手指触摸到屏幕时触发*/ div.addEventListener(&quot;touchstart&quot;,function()&#123; console.log(&quot;touchstart&quot;); &#125;); /*添加手指滑动事件，当手指在屏幕上滑动时触发:move事件是持续触发*/ div.addEventListener(&quot;touchmove&quot;,function()&#123; console.log(&quot;touchmove&quot;); &#125;); /*添加触摸结束事件：当手指离开屏幕时触发*/ div.addEventListener(&quot;touchend&quot;,function()&#123; console.log(&quot;touchend&quot;); &#125;); /*添加触摸意外中断事件*/ div.addEventListener(&quot;touchcancel&quot;,function()&#123; &#125;);2.事件源参数对象： touches:当前屏幕上所有的触摸对象 targetTouches:当前元素上的触摸对象 changedTouches:当前屏幕上变换的触摸对象3.触摸对象的坐标值： clientX|clientY:可视区域(相对于当前视口)的横纵坐标 pageX|pageY：相对于文档的坐标 screenX|screenY:相对于屏幕的坐标 e.targetTouches[0].clientX; 8.2 分类页1231.全屏页面的制作 - 伸缩盒子的特点2.回顾touch事件,使用touch事件实现左侧栏的滑动,同时使用touch事件来实现移动端的点击事件3.使用第三方插件来实现右侧商品信息快的滚动操作 1234567891011121314布局: 上面：双飞翼布局 div.header width: 100%; height: 50px; border-bottom: 1px solid #ccc; position: absolute; a form&gt;input a 下面：高度 100% padding-top=上面盒子的高度 div.content width: 100%; height: 100%; padding-top: 50px; div.left width: 100px; height: 100%; position: absolute; 此时参照父元素高度,父元素高度100%,所以会出现滚动条,所以此时使用定位是不行 div.right 方法2: 不理解 div.content width: 100%; height: 100%; padding-top: 50px; div.left width: 100px; height: 100%;float: left; div.right height: 100%; margin-left: 100px; 设置margin-left会自动占据剩余的宽度 12345678910111213141516返回按钮: .back &#123; width: 49px; height: 49px; background: url(&apos;../images/scripts.png&apos;); 二倍图 background-size: 200px 200px; background-position: -20px 0; padding: 14px; background-origin: content-box; 设置裁切，控制显示 background-clip: content-box; position: absolute; top: 0; left: 0; &#125; 9. 媒体查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651.媒体类型 all:用于所有设备 print:用于打印机和打印预览 screen:用于电脑屏幕，平板电脑，智能手机等 超小屏幕: &lt; 768px 小屏设备: 768px -992px 中等屏幕: 992px -1200px 大屏设备: 1200px以上2.媒体特性 width height max-width min-width max-height min-heightd等等3.关键字 关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件 and:可以将多个媒体特性连接到一起，相当于&quot;且&quot;的意思 not:排除某个媒体类型，相当于&quot;非&quot;,可以省略 only:指定某个特定的媒体类型，可以省略 @meida only screen and (max-width:640px)&#123; .container &#123; width:1170px; &#125; &#125; 案例： 默认背景颜色 red,小屏绿色 body &#123; background: red; &#125; 屏幕最大宽度是768px，背景色为绿色 @media screen and (max-width : 768px) &#123; body &#123; background: green; &#125; &#125; @media screen and (min-width : 768px) and (max-width : 992px)&#123; body &#123; background: yellow; &#125; &#125;4.引入方式 1)第一种方式： 使用link方式引入媒体查询 &lt;link rel=&apos;stylesheet&apos; media=&apos;only screen and (max-width:768px)&apos; href=&apos;./blue.css&apos;&gt; 2)第二种方式：css中使用@media min:判断条件一定是从小到大的，css代码从上到下执行 max:判断条件是从大到小 1)第一种 only可省 @media only screen and (min-width:1200px)&#123; .container &#123; width:1170px; &#125; &#125; 2）第二种 @media (mix-width:768px;)&#123; .container &#123; width:750px; &#125;5.媒体特性 width:指的是视口的宽度 @media only screen and (width:375px) &#123; body &#123; background-color:pink; &#125; &#125; width/height:完全等于视口的宽度|高度 max-width|max-height:小于等于视口 min-width|min-height:大于等于视口 device-width|device-height:完全等于屏幕 orientation:portrait|landscape 肖像(竖屏)|全景模式 案例.html 123456789101112131415161718192021body &#123; background: red;&#125;@media screen and (min-width: 768px) &#123; body &#123; background: green; &#125;&#125;@media screen and (min-width: 992px) &#123; body &#123; background: yellow; &#125;&#125;@media screen and (min-width: 1200px) &#123; body &#123; background: greenyellow; &#125;&#125;书写建议: 如果判断最小值,那么就应该从小到大写 如果判断最大值,那么就应该从大到小写 10. less12345678910111213141516171819202122232425262728293031323334353637383940414243444546运行在node环境下,所以需要安装node运行less文件, lessc xxx.less xxx.css使用: 定义变量: @color: #ccc; @变量名:值; div &#123; color: @color; &#125; 混入:将一个定义好的样式引入另一个样式中 .border_radius &#123; border-radius: 10px; -webkit-border-radius: 10px; &#125; 使用: div &#123; width: 200px; height: 200px; 引入样式: .border_radius; &#125; 传参： 默认值: @r:10px .border_radius(@r) &#123; border-radius: @r; -webkit-border-radius: @r; &#125; 使用: div &#123; width: 200px; height: 200px; 引入样式: .border_radius(10px); &#125; 嵌套: .container &#123; div &#123; height: 100%; &gt; a &#123; div&gt;a &#123;&#125; color: #000; &amp;:hover &#123; a:hover &#123;&#125; color: #ccc; &#125; &#125; &amp;::before &#123; div::before &#123;&#125; content: &apos;&apos;; &#125; &#125; &#125; 11. 响应式布局123456- jQuery Bootstrap框架中的所有JS组件都依赖于jQuery实现- html5shiv(https://github.com/aFarkas/html5shiv) 让低版本浏览器可以识别HTML5的新标签，如header、footer、section等- respond(https://github.com/scottjehl/Respond) 让低版本浏览器可以支持CSS媒体查询功能 12. 响应式轮播图1234567做响应式轮播图: width &lt; 768px：图片会随着屏幕的缩小自动适应 img的宽度为100%，通过img标签来实现 width &gt;= 768px: 图片作为背景，当宽度变化的时候，会显示更多的图片的两边区域 background-image: 添加图片 background-position: center center; background-size: cover; 轮播图插件Carousel 123456789101112131415161718192021222324252627282930313233343536373839移动端:img &#123; width: 100%;&#125;&lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- Indicators --&gt; &lt;!-- 指示器 --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;3&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;image/1.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;image/2.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;image/3.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;image/4.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;!-- 左右箭头 --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 轮播图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- 非移动端轮播图 --&gt;&lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;3&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;a href=&quot;#&quot; class=&apos;picImg&apos;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot; class=&apos;picImg&apos;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot; class=&apos;picImg&apos;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot; class=&apos;picImg&apos;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;样式: &lt;style&gt; .carousel-inner .item .picImg &#123; display: block; width: 100%; height: 250px; background-image: url(image/1.jpg); background-position: center center; background-size: cover; &#125; &lt;/style&gt; 响应式轮播图 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 轮播图 --&gt;&lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;3&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;mobileImg hidden-sm hidden-md hidden-lg&quot;&gt;&lt;img src=&quot;image/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&apos;picImg hidden-xs&apos; style=&quot;background-image: url(&apos;image/1.jpg)&quot;;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;mobileImg hidden-sm hidden-md hidden-lg&quot;&gt;&lt;img src=&quot;image/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&apos;picImg hidden-xs&apos; style=&quot;background-image: url(&apos;image/2.jpg)&quot;;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;mobileImg hidden-sm hidden-md hidden-lg&quot;&gt;&lt;img src=&quot;image/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&apos;picImg hidden-xs&apos; style=&quot;background-image: url(&apos;image/3.jpg)&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;mobileImg hidden-sm hidden-md hidden-lg&quot;&gt;&lt;img src=&quot;image/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&apos;picImg hidden-xs&apos; style=&quot;background-image: url(&apos;image/4.jpg)&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;由于这种方式不论在移动端还是PC端都会请求所有的图片,所以需要按需加载所需图片 js根据屏幕大小动态获取图片+ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$(function()&#123; /*获取当前所有item*/ var items=$(&quot;.carousel-inner .item&quot;); /*监听屏幕的大小改变*/ $(window).on(&quot;resize&quot;,function()&#123; /*1.获取当前屏幕的宽度*/ var width=$(window).width(); /*2.判断屏幕的宽度*/ if(width&gt;=768)&#123;/*说明非移动端*/ /*为每一个item添加子元素--遍历*/ $(items).each(function(index,value)&#123; var item=$(this); /*当前自定义属性中 存储的图片路径*/ /*获取自定义属性中的值 html页面中通过自定义属性存储图片路径 &lt;div data-large-image=&apos;./image/slide_01_200*410.jpg&apos;&gt;*/ var imgSrc=item.data(&quot;largeImage&quot;); console.log(imgSrc); /*添加非移动端的子元素*/ item.html($(&apos;&lt;a href=&quot;javascript:;&quot; class=&quot;pcImg&quot;&gt;&lt;/a&gt;&apos;).css(&quot;backgroundImage&quot;,&quot;url(&apos;&quot;+imgSrc+&quot;&apos;)&quot;)); &#125;); &#125; else&#123; $(items).each(function(index,value)&#123; var item=$(this); var imgSrc=item.data(&quot;smallImage&quot;); item.html(&apos;&lt;a href=&quot;javascript:;&quot; class=&quot;mobileImg&quot;&gt;&lt;img src=&quot;&apos;+imgSrc+&apos;&quot; alt=&quot;...&quot;&gt;&lt;/a&gt;&apos;); &#125;); &#125; &#125;).trigger(&quot;resize&quot;); /*添加移动端的滑动操作*/ var startX,endX; var carousel_inner=$(&quot;.carousel-inner&quot;)[0]; /*获取当前轮播图*/ var carousel=$(&quot;.carousel&quot;); carousel_inner.addEventListener(&quot;touchstart&quot;,function(e)&#123; startX= e.targetTouches[0].clientX; &#125;); carousel_inner.addEventListener(&quot;touchend&quot;,function(e)&#123; endX= e.changedTouches[0].clientX; if(endX-startX &gt; 0)&#123; /*上一张*/ bootstrap的事件:carousel(&apos;prev&apos;); carousel.carousel(&apos;prev&apos;); &#125; else if(endX-startX &lt; 0)&#123; /*下一张*/ carousel.carousel(&apos;next&apos;); &#125; &#125;);&#125;); 13. 标签页123tab栏切换工具提示类列嵌套 14. bootstrap12345678910111213141516171819202122类名： .container: 版心 .container-fluid:流式布局 .row : 行 默认12列 .col-lg-6:占几列 lg: 大屏 col-xs-6 col-sm-4 col-md-3 col-lg-2 md:中屏 sm:小屏 xs:超小屏 offset:偏移 col-xs-offset-2 偏移两列 通过margin-left来实现 push:推 col-xs-push-2 往后退2个 通过定位实现 不会影响其他元素，可能与其他元素重叠 pull:拉 col-xs-pull-2 往前拉2个 通过定位实现 hidden: hidden-xs hidden-sm hidden-md hidden-lg visible: 导航栏： navbar-nav navbar-default:默认 navbar-right ：导航条右浮动 navbar-inverse:反色 样式工具： hidden-lg:在哪个屏隐藏 visible-lg:在哪个屏显示 15. fullpage插件案例12345678910111213141516171819202122232425262728291.fullpage插件的使用 引入jquery.js文件 引入fullpage.js文件 使用样式： $(&apos;.fullpage&apos;).fullpage(&#123; 配置每一屏的选择器： 默认是.section sectionSelector: &apos;.page&apos;, 设置每屏的颜色 sectionsColor: [&apos;&apos;,&apos;&apos;,&apos;&apos;], 当每一屏滚动完成会执行 参数Index是从1开始的 afterLoad:function(item,index)&#123; $(&apos;.section&apos;).removeClass(&apos;current&apos;); $(&apos;.section&apos;).eq(index-1).addClass(&apos;current&apos;); &#125; &#125;);2.快捷键使用img[src=&quot;./images/text_$.png&quot;]*83.由于网页加载太快，第一屏在出来的时候已经加载完毕，所以需要延迟动画开始执行的时间，可以通过定时器来实现（setTimeout）或者通过动画来实现。4.第二屏使用 通过伸缩盒子来实现页面布局 注意： 1）使用fullpage会给section自动添加一个子元素div,所以在指定伸缩盒子的时候不能给section指定,而是给section&gt;div来指定display:flex; .three&gt;div &#123; display:flex; justify-content:space-between; 水平方向对齐方式 align-items:center; 垂直方向对齐方式居中 &#125; 2）盾牌效果实现时，中间有很大的缝隙，通过指定font-size:0;来修改或者通过将图片转换为块级元素来实现(需要通过浮动来实现); 16. rem123456789101112131415161718192021222324252627282930313233em和rem的区别: em: 是参照当前元素的字号,如果没有设置,就参照父容器或者当前浏览器的默认字号 rem: 是参照根元素的字号 假设将每个不同宽度的屏幕都分为20份,则计算出每份为多少像素 通过媒体查询的方式来实现rem布局 body &#123; margin: 0; padding: 0; &#125; @media screen and (device-width: 320px) &#123; html &#123; font-size: 16px; 320/20份 &#125; &#125; @media screen and (device-width: 360px) &#123; html &#123; font-size: 18px; 320/20份 &#125; &#125; @media screen and (device-width: 375px) &#123; html &#123; font-size: 18.75px; 375/20份 &#125; &#125; @media screen and (device-width: 414px) &#123; html &#123; font-size: 20.07px; 414/20份 &#125; &#125; div &#123; 在设计稿宽度为640px下,div的宽度为320px, 320/(640/20)=10rem width: 10rem; &#125; 封装 12把媒体查询实现适配的代码放在一个less文件中,并在index.less文件中引入@import &apos;adapter.less&apos;; base.less 1234567891011121314151617181920body, ul, li, h3, h4, h2, h1 &#123; margin: 0; padding: 0;&#125;body &#123; background-color: #ccc;&#125;a &#123; text-decoration: none;&#125;.layout &#123; 如果参考的设计稿是640px max-width: 640px; margin: 0 auto;&#125;在index.css文件中设置样式时需要用量取得元素除以每份的像素div &#123; width: 320px/32 rem;&#125; 17. zepto库的使用12轻量级的针对移动端的js库,类似于jquery的APIzepto.js文件只包含 Core、ajax、Event、Form、IE 5个模块,如果需要使用其他模块,需要单独引入其他模块. 17.1 使用zepto来实现轮播图12345671.引入zepto.js文件2.完成轮播图的布局3.添加首尾两张图片,第一张添加到最后面,最后一张添加到最前面4.重新设置图片盒子的宽度,和每一张图片的宽度,如果布局使用流式布局的话需要设置5.开启定时器实现自动轮播6.添加移动端的滑动事件,实现手动轮播7.实现过渡之后的监听,如果是最后一张,则清除过渡,直接跳转到第一张,反之亦然。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273zepto也有入口函数$(function()&#123; 1.轮播前准备 获取轮播图元素 var banner = $(&apos;.jd_banner&apos;); 获取轮播图元素的宽度 var bannerWidth = banner.width(); 获取图片盒子 var imgBox = banner.find(&apos;ul:first-of-type&apos;); 获取点标记 var indicatiors = banner.find(&apos;ul:eq(1)&apos;); 使用索引来获取元素默认会报错,如果想使用索引来获取元素,需要引入模块selector.js 获取首尾两张图片 var first = imgBox.find(&apos;li:first-of-type&apos;); var last = imgBox.find(&apos;li:last-of-type&apos;); 将两张图片添加到首尾位置 imgBox.append(first.clone()); 将第一张图片复制并将复制的元素添加到最后 last.clone().insertBefore(first); 将最后一张图片复制并插入到第一张前面 设置图片盒子的宽度和li标签的宽度 先获取所有的li标签 var lis = imgBox.find(&apos;li&apos;); var count = lis.length; imgBox.width(count*bannerWidth); 设置所有li元素的宽度 lis.each(function(index,item)&#123; $(lis[index]).width(bannerWidth); &#125;); 设置默认偏移,在第一张前面添加了最后一张图片之后,显示的不是第一张 imgBox.css(&quot;left&quot;: -bannerWidth); 2.开启定时器 定义图片索引 var index = 1; var timeId = setInterval(function()&#123; index++; 如果要使用zepto的动画属性,需要先引入模块fx.js animate:4个参数对象 animate(对象,执行时间,动画类型,动画完成之后的回调函数) imgBox.animate(&#123;&quot;left&quot;: -index*bannerWidth&#125;, 200, &quot;ease-in-out&quot;, imgAnimation()); &#125;,2000); 3.图片滑动时候 tap模块中通过 swipe swipeLeft swipeRight swipeUp swipeDown 当元素被划过时触发,添加以上事件使用on 和off 添加滑动事件 引入touch.js文件模块 左滑动 imgBox.on(&quot;swipeLeft&quot;,function()&#123; 先清理定时器 clearInterval(timerId); index++; 执行动画代码 imgAnimation(); &#125;); 右滑动 imgBox.on(&quot;swipeRight&quot;,function()&#123; 先清理定时器 clearInterval(timerId); index--; imgAnimation(); &#125;); 4. 封装动画移动的代码 var imgAnimation = function()&#123; 动画执行完毕之后的回调函数,判断当前是否是最后一张或者是第一张(个人想法觉得第一张没用,因为定时器控制的话，只能向右滑动) if(index == count-1)&#123; index = 1; imgBox.css(&quot;left&quot;,&quot;-index*bannerWidth&quot;); &#125; else if(index == 0) &#123; index = count-2; imgBox.css(&quot;left&quot;,&quot;-index*bannerWidth&quot;); &#125; 设置点标记 indicatiors.removeClass(&quot;active&quot;).eq(index-1).addClass(&quot;active&quot;); &#125;&#125;); 123456animate： 参数一: 需要添加动画的效果样式 参数二: 动画耗时 参数三: 动画速度函数 ease 参数四: 动画完成之后的回调函数使用animate方法需要引入fx.js文件 12touch模块: 滑动事件 在谷歌浏览器的模拟器里面无法触发zepto的相关滑动事件,但是可以触发tap事件 扩展修改图片底色123456781）将图片拉入ps中2）点击右下角新建图层3）按ctrl+backspace键填充颜色，图片底色改变，原来内容消失4）将上面的图层拉到下面（ps右下角图层面板），内容即可显示快捷键：ctrl+r：显示标尺 百分比12341)如果padding设置的是百分比的话，那么上下左右的值全是改盒子的宽度*百分比得到的值。也就是说百分比参照的是该盒子的宽度，与高度无关。2）设置margin时如果设置的值是百分比的话，百分比也是参照该盒子的宽度3）边框不能使用百分比设置，不支持百分比 清除浮动的4种方式1234567891011121314151617181920212223242526272829301.额外标签法 在最后一个浮动元素的后面添加空标签，设置样式为 &lt;div class=&apos;clearfix&apos;&gt;&lt;/div&gt; .clearfix &#123; clear:both; &#125;2.使用伪元素清除浮动 .clearfix::after &#123; conrtent:&apos;&apos;; display:block; height:0; line-height:0; clear:both; visibility:hidden; &#125; .clearfix &#123; *zoom:1; &#125;3.双伪元素清除浮动(代码待验证) .clearfix::before, .clearfix::after &#123; content:&apos;&apos;; display:table; &#125; .clearfix::after &#123; clear:both; &#125; .clearfix &#123; *zoom:1; &#125;4.触发BFC模式 给父元素添加overflow:hidden;来清除浮动 布局方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051两种布局方式实现效果相似，只是实现方式有点点不一样，都是两侧宽度固定，中间自适应的布局1.圣杯布局&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; width: 1100px; margin: 0 auto; background: red; height: 600px; &#125; .main &#123; float: left; width: 100%; height: 200px; background: green; padding: 0 100px; box-sizing: border-box; &#125; .left &#123; float: left; margin-left: -1100px; width: 100px; height: 200px; background: yellowgreen; &#125; .right &#123; float: left; margin-left: -100px; width: 100px; height: 200px; background: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt; sadfjaklfjklsajfl;sajfk;lsdjfkaljfkldajf; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;三个盒子都浮动，然后最后两个盒子设置margin值2.双飞翼布局 3个盒子浮动，最后两个margin，给第一个盒子里面添加一个盒子，给盒子设置margin即可。 logo优化123456789101112131415&lt;div class=&apos;logo&apos;&gt; &lt;h1&gt; 提高访问的权重 &lt;a href=&apos;haha.html&apos; title=&apos;嘻嘻&apos;&gt;哈哈&lt;/a&gt; &lt;/h1&gt;&lt;/div&gt;&lt;style&gt; a &#123; width:100px; height:100px; display:block; background:url(logo.png) no-repreat; text-indent: -2000em; &#125;&lt;/style&gt; 网站后台布局123456789101112131415161718192021222324252627左边宽度固定,右边宽度自适应1.第一种左边盒子宽度固定并设置浮动,右边盒子宽度100%,设置margin-left为左边盒子的宽度.left &#123; width: 200px; height: 300px; float: left;&#125;.right &#123; width: 100%; height: 600px; margin-left: 200px;&#125;2.第二种左边盒子宽度固定并设置为固定定位,因为固定定位是参考浏览器的高度的,设置左边盒子的高度为100%,右边盒子设置margin-left为左边盒子的宽度.left &#123; width: 200px; height: 100%; position:fixed; left: 0; top: 0;&#125;.right &#123; width: 100%; height: 600px; margin-left: 200px;&#125; 使用less完成网站后台页面布局1234567891011121.引入less.js文件 在使用link标签引入less文件时 &lt;link rel=&apos;stylesheet/less&apos; href=&apos;./css/index.less&apos;&gt;2.在index.less文件中 引入base.less@import &apos;./base.less&apos;开启服务器3.引入bootstrap基础模板4.布局div.left div.image img+span div.nav 框架1231.bootstrap2.Amaze UI3.Framework7]]></content>
  </entry>
  <entry>
    <title><![CDATA[jquery]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fjquery%2F</url>
    <content type="text"><![CDATA[jQueryjquery优点11. 优点: 体积小、功能强大、链式编程、隐式迭代、插件丰富、开源、免费、写得少做的多 jquery获取元素1234567891011121314151617181920$(&quot;#&quot;)$(&quot;.&quot;)$(&quot;标签&quot;)$(&quot;p, div&quot;)$(&quot;p.p1&quot;)$(&quot;div p&quot;)$(&quot;div&gt;p&quot;)$(&quot;ul li:odd&quot;)$(&quot;ul li:even&quot;)$(&quot;ul li:eq(索引值)&quot;)$(&quot;ul li&quot;).eq(索引值)获取某个元素的兄弟元素的方法 $(&quot;&quot;).children(&quot;&quot;) 子类 $(&quot;&quot;).find(&quot;&quot;) 后代 $(&quot;&quot;).siblings(&quot;&quot;) 兄弟元素 $(&quot;&quot;).parent(); 父级元素 $(&quot;&quot;).next(); 下一个 $(&quot;&quot;).prev(); 上一个 $(&quot;&quot;).nextAll(); 后面所有 $(&quot;&quot;).prevAll(); 前面所有 jQuery对象和DOM对象的区别123456789101112131415161718192021222324252627282930313233343536371. 顶级对象 jQuery: $或者Jquery js: 浏览器 window 页面: document2.注册事件 jQuery: jQuery对象.click(function()&#123;&#125;); js对象: DOM对象.onclick = function()&#123;&#125;;3.jquery与DOM对象互转 jQuery=&gt;DOM: $(&apos;&apos;)[索引值] $(&apos;&apos;).get(索引值) DOM=&gt;jQuery: $(DOM对象)4. 获取值 jQuery: 获取: 对象.val(); 设置: 对象.val(&apos;&apos;); 对象.text(); 对象.text(&apos;&apos;); 对象.css(&apos;&apos;,&apos;&apos;); 对象.css(&apos;border&apos;,&apos;1px solid red&apos;); 对象.css(&apos;border&apos;,&apos;1px solid red&apos;).css(&quot;&quot;,&quot;&quot;); 对象.css(&#123;&apos;border&apos;:&apos;1px solid red&apos;,&quot;&quot;:&quot;&quot;&#125;); 对象.addClass(&quot;类名&quot;); 对象.removeClass(&quot;类名&quot;); 对象.hasClass(&quot;类名&quot;); 对象.toggleClass(&quot;类名&quot;); 对象.html() DOM: 对象.value= &apos;&apos;; 对象.value 对象.innerText=&apos;&apos;; 对象.innerText 对象.innerHtml=&apos;&apos;; 对象.innerHtml 对象.textContent = &apos;&apos;;5.页面加载事件 jquery: $(window).load(function()&#123;&#125;); 页面内容全部加载完毕才触发 页面基本元素(所需元素加载完毕就触发) 速度快 $(document).ready(function()&#123;&#125;); $(function()&#123;&#125;); jquery(function()&#123;&#125;); DOM: window.onload= function()&#123;&#125; 区别: DOM加载事件只能有一个,否则就会被覆盖,DOM加载速度慢 链式编程断链修复1在哪断开在哪使用end(); 方法修复 动画的相关方法123456789101112131415161718192021222324hide(时间,回调函数); 隐藏show(时间,回调函数); 显示toggle(); 切换显示隐藏slideDown(时间,回调函数); 滑出slideUp(时间,回调函数); 滑入slideToggle(时间,回调函数); 切换滑入滑出fadeIn(时间,回调函数); 淡入fadeOut(时间,回调函数); 淡出fadeToggle(时间,回调函数); 切换fadeTo(时间,透明度);参数1: 动画执行时间(单位: 毫秒)参数2: 回调函数自定义动画 jQuery.animate(&#123;&#125;,时间,执行效果,回调函数); // &#123;params&#125;：要执行动画的CSS属性，带数字（必选） // speed：执行动画时长（可选） // easing:执行效果，默认为swing（缓动） 可以是linear（匀速） // callback：动画执行完后立即执行的回调函数（可选） $(&apos;#dv&apos;).animate(&#123;&apos;&apos;:&apos;&apos;&#125;,300).animate(&#123;&apos;&apos;:&apos;&apos;&#125;,300)stop();stop方法：停止动画效果stop(clearQueue, jumpToEnd);// 第一个参数：是否清除队列// 第二个参数：是否跳转到最终效果 元素的添加、创建、删除、复制123456789101112131415161718添加:父元素.append(子级元素);子元素.appendTo(父元素);子元素.clone().appendTo(父元素);父元素.prepend(子元素); 在父元素的第一个子元素之前添加子元素.prependTo(父元素); 在父元素的第一个子元素之前添加元素.after(元素); 添加到被选元素之后元素.before(元素); 添加到被选元素之前创建: $(&apos;html代码&apos;) $(&apos;.dv&apos;).html(&apos;&apos;); 原来的内容会被覆盖移除: $(&apos;&apos;).html(&apos;&apos;); 清空 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。 $(&apos;&apos;).empty(); 清空 清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码） $(&apos;&apos;).remove(); 相当于自杀,父元素也没有了复制： 元素.clone(); 没复制事件 元素.clone(true); 事件也复制过去了 自定义属性123attr(&apos;checked&apos;,&apos;true&apos;); 设置$(&quot;&quot;).attr(&quot;checked&quot;); 如果选中了为 checked,否则是undefinedattr()方法主要操作元素的自定义属性,也可以操作元素自带的属性,但操作元素的选中问题checked不合适,推荐使用prop()方法。 下拉框选中选中的元素1234$(&quot;select option:selected&quot;)下拉列表设置第几个默认选中$(&quot;select&quot;).val(5); 将下拉列表中第5个option选中 操作元素的选中问题12设置： $(&apos;.dv&apos;).prop(&apos;checked&apos;,true);获取: $(&apos;.dv&apos;).prop(&apos;checked&apos;); 操作元素的宽和高123456789101112131415161.设置/获取: $(&apos;&apos;).css(&apos;width&apos;,&apos;&apos;); 得到的是字符串2.$(&apos;&apos;).width(); 可设置获取/数值类型 不包括内边距、边框和外边距 获取得到的是数值类型 $(&apos;&apos;).width(300); 3.获取网页可视区域的宽高 // 获取可视区宽度 $(window).width(); // 获取可视区高度 $(window).height();4. offset() 获取的是一个对象,里面有两个属性(top和left) left： left + margin-left top: top + margin-top 获取: $(&quot;&quot;).offset().top; 设置: $(&quot;&quot;).css(&quot;left&quot;, &quot;&quot;); $(&quot;&quot;).css(&#123;&quot;left&quot;: &quot;&quot;&#125;);5.获取向上向左卷曲出去的距离 $(&quot;&quot;).scrollTop(); $(&quot;&quot;).scrollLeft(); 返回的是数字类型 DOM中是属性,jquery中是方法 offset方法与position方法12345678offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素(offsetParent)的位置1.设置/获取: $(&apos;&apos;).css(&apos;left&apos;,&apos;&apos;); 得到的是字符串2.$(&apos;&apos;).offset(); 获取的是一个对象 里面有两个属性 left top 设置: $(&apos;&apos;).offset(&#123;&apos;left&apos;: &apos;&apos;,&apos;top&apos;: &apos;&apos;&#125;);3.// 获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();// 获取相对于其最近的有定位的父元素的位置。$(selector).position(); 获取向左/向上卷曲出去的距离123$(&apos;&apos;).scrollTop(); 返回的是数字类型$(&apos;&apos;).scrollLeft();没有scrollHeight属性或者方法 jQuery绑定事件123456789101112131415161718191. $().click(function()&#123;&#125;); 后添加的元素没有事件2. $().bind(&apos;事件名&apos;,function()&#123;&#125;); 后添加的元素没有事件 bind绑定多个事件 $().bind(&#123;&apos;事件名&apos;:function()&#123;&#125;, &apos;事件名&apos;:function()&#123;&#125; &#125;);3.给元素绑定多个相同事件 $().click(function()&#123;&#125;).click(function()&#123;&#125;); 都执行 $().bind(&apos;事件名&apos;,function()&#123;&#125;).bind(&apos;事件名&apos;,function()&#123;&#125;); 都执行 $().bind(&#123;&apos;事件名&apos;:function()&#123;&#125;, &apos;事件名&apos;:function()&#123;&#125; &#125;); 事件名一样的话只会执行最后一个,被覆盖了4.$().delegate(&apos;子元素&apos;,&apos;事件名&apos;,function()&#123;&#125;); 后添加的元素有事件5.$().on(&apos;事件名&apos;,&apos;子元素&apos;,function()&#123;&#125;); 后添加的元素有事件事件委托原理： // 事件委托的原理 var ul = document.querySelector(&apos;#ul&apos;); ul.onclick = function (e) &#123; // console.log(e.target.tagName); if (e.target.tagName.toLowerCase() === &apos;li&apos;) &#123; console.log(e.target); &#125; &#125; jQuery解绑事件12345678910111. $().unbind(); 该元素的所有事件全部解绑 $().unbind(&apos;click&apos;); 该元素的所有点击事件全部解绑 $().unbind(&apos;click mouseenter&apos;); 该元素的所有事件全部解绑2.$().undelegate(); 子元素事件没有了,父元素事件还在 $().undelegate(&apos;p&apos;); 不会解绑事件 $().undelegate(&apos;p&apos;，&apos;click&apos;); 解绑p元素的点击事件3.$().off(); 父元素和子元素的所有事件全部解除 $().off(&apos;click&apos;); 父元素和子元素的所有点击事件全部解除 $().off(&apos;click&apos;,&apos;p&apos;); 解绑p的所有点击事件 $().off(&apos;&apos;,&apos;p&apos;); 解绑p的所有事件 $().off(&apos;click&apos;,&apos;**&apos;); 解绑所有子元素的点击事件 事件触发12345$(&apos;&apos;).focus(); 获取焦点的时候触发$(&apos;&apos;).trigger(&apos;事件名&apos;);$(&apos;&apos;).triggerHandle(&apos;focus&apos;); 可以触发事件,不能触发浏览器默认行为$(selector).click(); // 触发 click事件 事件参数e12345678910111213141516鼠标按键的值: e.buttone.altKey e.shiftKey e.ctrlKeye.target 触发该事件的目标元素e.currentTarget 触发该事件的当前元素e.delegateTarget 代理的这个元素e.screenX e.screenY 鼠标相对于屏幕的X y,不是浏览器阻止默认事件: e.preventDefault();阻止事件冒泡: e.stopPropagation();阻止事件冒泡和阻止浏览器默认行为: return false;// screenX和screenY 对应屏幕最左上角的值// clientX和clientY 距离页面左上角的位置（忽视滚动条） 可视区域// offsetX和offsetY 鼠标在元素中的位置// pageX和pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离） 相对于文档// event.keyCode 按下的键盘代码// event.data 存储绑定事件时传递的附加数据 each方法1234遍历jquery对象$(&apos;&apos;).each(function(index,item)&#123; &#125;); 多库共存问题($的控制权)123$冲突调用 $.noconflict()方法释放Jquery中$的权利var a = $.noConflict(); 包装集1234判断某个元素是否存在,通过包装集的.length来判断if($(&apos;.dv&apos;).length != 0)&#123; 说明存在&#125; innerWidth/innerHeight/outerWidth/outerHeight123456innerWidth(); 返回元素的宽高,有内边距,无边框innerHeight();outerWidth(); 返回元素的宽高+有内边距有边框边框outerHeight();outerWidth(true); 返回元素的宽高+内边距+边框+外边距outerHeight(true); mouseenter和mouseover12mouseenter: 进入被选的元素才会触发mouseover: 不论进入被选元素还是子元素,都会触发 hover方法12345678$(&quot;&quot;).hover(fnEnter, fnout);相当于$(&quot;&quot;).mouseenter(fn).mouseout(fn);$(&quot;&quot;).hover(function()&#123; 鼠标进入执行&#125;,function()&#123; 鼠标离开执行&#125;); jQuery操作样式CSS操作12345// name：需要设置的样式名称// value：对应的样式值$obj.css(name, value);// 使用案例$('#one').css('background','gray');// 将背景色修改为灰色 设置多个样式 12345678// 参数是一个对象，对象中包含了需要设置的样式名和样式值$obj.css(obj);// 使用案例$('#one').css(&#123; 'background':'gray', 'width':'400px', 'height':'200px'&#125;); 获取样式 1234// name:需要获取的样式名称$obj.css(name);// 案例$('div').css('background-color'); 注意：获取样式操作只会返回第一个元素对应的样式值。 隐式迭代： 设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。 class操作 添加样式类 1234// name：需要添加的样式类名，注意参数不要带点.$obj.addClass(name);// 例子,给所有的div添加one的样式。$('div').addClass('one'); 移除样式类 1234// name:需要移除的样式类名$obj.removeClass('name');// 例子，移除div中one的样式类名$('div').removeClass('one'); 判断是否有某个样式类 1234// name:用于判断的样式类名，返回值为true false$obj.hasClass(name)// 例子，判断第一个div是否有one的样式类$('div').hasClass('one'); 切换样式类 1234// name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。$obj.toggleClass(name);// 例子$('div').toggleClass('one'); jQuery操作自定义属性attr操作 设置单个属性 123456// 第一个参数：需要设置的属性名// 第二个参数：对应的属性值$obj.attr(name, value);// 用法举例$('img').attr('title','哎哟，不错哦');$('img').attr('alt','哎哟，不错哦'); 设置多个属性 12345678// 参数是一个对象，包含了需要设置的属性名和属性值$obj.attr(obj)// 用法举例$('img').attr(&#123; title:'哎哟，不错哦', alt:'哎哟，不错哦', style:'opacity:.5'&#125;); 获取属性 12345// 传需要获取的属性名称，返回对应的属性值$obj.attr(name)// 用法举例var oTitle = $('img').attr('title');alert(oTitle); 移除属性 1234// 参数：需要移除的属性名，$obj.removeAttr(name);// 用法举例$('img').removeAttr('title'); prop操作 在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。 1234// 设置属性$(':checked').prop('checked',true);// 获取属性$(':checked').prop('checked');// 返回true或者false val()/text/()html()123$obj.val() 获取或者设置表单元素的value属性的值$obj.html() 对应innerHTML$obj.text() 对应innerText/textContent，处理了浏览器的兼容性 插件常用插件 弹出层插件 layer layer插件 放大镜插件 jQuery.zoom 轮播图插件 http://sorgalla.com/jcarousel/ https://github.com/OwlCarousel2/OwlCarousel2 图片懒加载插件 jQuery.lazyload jQueryUI 常用的2-3个功能演示 查看jQuery插件的源码 瀑布流插件(masonry) 堆糖网站 自己探索插件 artDialog 图片放大 github上搜索]]></content>
  </entry>
  <entry>
    <title><![CDATA[js高级]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fjs%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[JavaScript 高级JavaScript 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object、Array、Date、RegExp、Function| 。 基本包装类型: Boolean、String、Number 类型检测 typeof instanceof Object.prototype.toString.call() 创建对象1. 直接通过 new Object() 创建：1234567var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 2. 对象字面量来创建：1234567var person = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 3. 构造函数12345678910111213function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person('Jack', 18)p1.sayName() // =&gt; Jackvar p2 = new Person('Mike', 23)p2.sayName() // =&gt; Mike 使用 new 操作符调用构造函数会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码 返回新对象 构造函数和实例对象的关系使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。在每一个实例对象中的__proto__中同时有一个 constructor 属性，该属性指向创建该实例的构造函数： 123console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true 对象的 constructor 属性最初是用来标识对象类型的，但是，如果要检测对象的类型，还是使用 instanceof 操作符更可靠一些： 12console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true 继承构造函数的属性继承：借用构造函数12345678910111213function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;function Student (name, age) &#123; // 借用构造函数继承属性成员 Person.call(this, name, age)&#125;var s1 = Student('张三', 18)console.log(s1.type, s1.name, s1.age) // =&gt; human 张三 18 构造函数的原型方法继承：拷贝继承（for-in）12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 原型对象拷贝继承原型对象成员for(var key in Person.prototype) &#123; Student.prototype[key] = Person.prototype[key]&#125;var s1 = Student('张三', 18)s1.sayName() // =&gt; hello 张三 另一种继承方式：原型继承12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 利用原型的特性实现继承Student.prototype = new Person()var s1 = Student('张三', 18)console.log(s1.type) // =&gt; humans1.sayName() // =&gt; hello 张三 call、apply、bind那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。这就是接下来我们要学习的 call、apply、bind 三个函数方法。 callcall() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 在 fun 函数运行时指定的 this 值 如果指定了 null 或者 undefined 则内部 this 指向 window arg1, arg2, ... 指定的参数列表 applyapply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：该方法的作用和 call() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.apply(thisArg, [argsArray]) 参数： thisArg argsArray apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数列表。例如： 1fun.apply(this, ['eat', 'bananas']) bindbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值： 返回由指定的this值和初始化参数改造的原函数拷贝。 示例1： 123456789101112131415this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 示例2： 12345678910111213141516function LateBloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// Declare bloom after a delay of 1 secondLateBloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 1000);&#125;;LateBloomer.prototype.declare = function() &#123; console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');&#125;;var flower = new LateBloomer();flower.bloom(); // 一秒钟后, 调用'declare'方法 小结 call 和 apply 特性一样 都是用来调用函数，而且是立即调用 但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向 call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可 apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递 如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window bind 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数 它和 call、apply 最大的区别是：bind 不会调用 bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递 在 bind 的同时，以参数列表的形式进行传递 在调用的时候，以参数列表的形式进行传递 那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部 函数的其它成员 arguments 实参集合 caller 函数的调用者 length 形参的个数 name 函数的名称 12345678910111213function fn(x, y, z) &#123; console.log(fn.length) // =&gt; 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // =&gt; 函数的名字&#125;function f() &#123; fn(10, 20, 30)&#125;f() 高阶函数 函数可以作为参数 函数可以作为返回值 作为参数12345678910function eat (callback) &#123; setTimeout(function () &#123; console.log('吃完了') callback() &#125;, 1000)&#125;eat(function () &#123; console.log('去唱歌')&#125;) 作为返回值1234567891011function genFun (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === type &#125;&#125;var isArray = genFun('[object Array]')var isObject = genFun('[object Object]')console.log(isArray([])) // =&gt; trueconsole.log(isArray(&#123;&#125;)) // =&gt; true 函数闭包1234567891011121314151617function fn () &#123; var count = 0 return &#123; getCount: function () &#123; console.log(count) &#125;, setCount: function () &#123; count++ &#125; &#125;&#125;var fns = fn()fns.getCount() // =&gt; 0fns.setCount()fns.getCount() // =&gt; 1 作用域、作用域链、预解析 全局作用域 函数作用域 没有块级作用域 12345678910&#123; var foo = 'bar'&#125;console.log(foo)if (true) &#123; var a = 123&#125;console.log(a) 作用域链示例代码： 123456789101112131415161718var a = 10function fn () &#123; var b = 20 function fn1 () &#123; var c = 30 console.log(a + b + c) &#125; function fn2 () &#123; var d = 40 console.log(c + d) &#125; fn1() fn2()&#125; 内层作用域可以访问外层作用域，反之不行 什么是闭包闭包就是能够读取其他函数内部变量的函数，由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 可以在函数外部读取函数内部成员 让函数内成员始终存活在内存中 一些关于闭包的例子示例1： 123456var arr = [10, 20, 30]for(var i = 0; i &lt; arr.length; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;&#125; 示例2： 12345678console.log(111)for(var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 0)&#125;console.log(222) 示例3：投票 示例4：判断类型 示例5：沙箱模式 闭包的思考题思考题 1： 1234567891011var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 思考题 2： 1234567891011var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function () &#123; var that = this; return function () &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 小结函数递归递归执行模型123456789101112131415161718192021222324function fn1 () &#123; console.log(111) fn2() console.log('fn1')&#125;function fn2 () &#123; console.log(222) fn3() console.log('fn2')&#125;function fn3 () &#123; console.log(333) fn4() console.log('fn3')&#125;function fn4 () &#123; console.log(444) console.log('fn4')&#125;fn1() 举个栗子：计算阶乘的递归函数1234567function factorial (num) &#123; if (num &lt;= 1) &#123; return 1 &#125; else &#123; return num * factorial(num - 1) &#125;&#125; 递归应用场景 深拷贝 菜单树 遍历 DOM 树 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ 验证邮编： 1^\d&#123;6&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn： 1^\w+@\w+\.\w+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;\(.\d&#123;1,3&#125;)&#123;3&#125;$ JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\d', 'i');var reg = new Regex('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr));]]></content>
  </entry>
  <entry>
    <title><![CDATA[webAPI]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2FwebAPI%2F</url>
    <content type="text"><![CDATA[Web APIAPI的概念API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) web API：操作浏览器 和 网页的一套==工具库== （ BOM 和 DOM ） 掌握常见的浏览器的API的调用方式MDN-Web API 认识文档树123456+ DOM，文档对象模型，又称为文档树模型。 浏览器在加载页面时， 会把html文档解析成一系列的对象。再由这些对象组成 树状结构。存入内存。+ 这些对象对外都提供了 属性和方法。我们可以 通过调用对象的属性和方法来操作网页。+ 节点对象的分类： ==文档对象==、==元素对象==、属性对象、文本对象 + 小结：文档树：本质就是浏览器把文档、文档中标签、标签属性以及标签文本转换成对象，按照嵌套关系以树状结构 存放这一组对象，并放入内存中。 JavaScript的组成 ECMAScript 核心语法 BOM 浏览器对象模型 DOM 文档对象模型 ECMAScript - JavaScript的核心定义了javascript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 BOMBOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window注意：window下一个特殊的属性 window.name 对话框 window.alert() window.prompt() 有提示信息的对话框 window.confirm( ) 有确认、取消按钮 console.log(); 控制台 页面加载事件 onload 1234window.onload = function () &#123; // 当页面加载完成执行 // 当页面完全加载所有内容（包括内容、标签、属性、图像、脚本文件、CSS 文件等）执行&#125; onunload 1234浏览器关闭才触发的事件 IE8支持window.onunload = function () &#123; // 当用户退出页面时执行&#125; onbeforeunload 关闭页面之前触发 123window.onbeforeunload = function()&#123; alert(&apos;hshd&apos;);&#125; 定时器注意：定时器产生和定时器执行是两会事。定时器中的函数体里的代码一定是在非定时器代码执行完最后执行的 setTimeout(fn,毫秒数)和clearTimeout(定时器id值) :一次性定时器在指定的毫秒数到达之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒后执行，返回定时器的标示var timerId = setTimeout(function () &#123; console.log('Hello World');&#125;, 1000);// 取消定时器的执行clearTimeout(timerId); setInterval(fn,毫秒数)和clearInterval(定时器id值)页面加载完毕后，每过多少时间执行一次，返回值就是定时器的id值 12345678// 创建一个定时器，每隔1秒调用一次var timerId = window.setInterval(function () &#123; var date = new Date(); console.log(date.toLocaleTimeString());&#125;, 1000);// 取消定时器的执行window.clearInterval(timerId); location对象location对象是window对象下的一个属性，时候的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL location对象 123456789101112window.location.hash:地址栏上#号后面的内容window.location.host:主机及端口号window.location.hostname:主机名window.location.port:端口号window.location.protocol:协议window.location.search:搜索的内容window.location.pathname:文件路径// 设置跳转的页面的地址location.href=&quot;http://www.jd.com&quot;;//属性-----------------&gt;必须记住location.assign(&quot;http://www.jd.com&quot;);//方法location.reload();//重新加载--刷新location.replace(&quot;http://www.jd.com&quot;);//没有历史记录 URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 12345678910111213scheme://host:port/path?query#fragmentscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个&apos;/&apos;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用&apos;&amp;&apos;符号隔开，每个参数的名和值用&apos;=&apos;符号隔开。例如：name=zsfragment:信息片断 字符串，锚点. location有哪些成员？ 使用chrome的控制台查看 查MDN MDN 成员 assign()/reload()/replace() hash/host/hostname/search/href…… 案例解析URL中的query，并返回对象的形式 1234567891011121314151617function getQuery(queryStr) &#123; var query = &#123;&#125;; if (queryStr.indexOf('?') &gt; -1) &#123; var index = queryStr.indexOf('?'); queryStr = queryStr.substr(index + 1); var array = queryStr.split('&amp;'); for (var i = 0; i &lt; array.length; i++) &#123; var tmpArr = array[i].split('='); if (tmpArr.length === 2) &#123; query[tmpArr[0]] = tmpArr[1]; &#125; &#125; &#125; return query;&#125;console.log(getQuery(location.search));console.log(getQuery(location.href)); history对象 window.history.back():返回 window.history.forward()：前进 window.history.go(1) 前进 window.history.go(-1) 后退 navigator对象 window.navigation.userAgent 通过userAgent可以判断用户浏览器的类型 window.navigation.platform 通过platform可以判断浏览器所在的系统平台类型. DOMDOM的概念文档对象模型（Document Object Model，简称DOM）， DOM又称为文档树模型 文档：一个网页可以称为文档 节点：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 模拟文档树结构 12345678910111213141516171819202122232425262728293031323334353637383940function Element(option) &#123; this.id = option.id || ''; this.nodeName = option.nodeName || ''; this.nodeValue = option.nodeValue || ''; this.nodeType = 1; this.children = option.children || [];&#125;var doc = new Element(&#123; nodeName: 'html'&#125;);var head = new Element(&#123; nodeName: 'head'&#125;);var body = new Element(&#123; nodeName: 'body'&#125;)doc.children.push(head);doc.children.push(body);var div = new Element(&#123; nodeName: 'div', nodeValue: 'haha',&#125;);var p = new Element(&#123; nodeName: 'p', nodeValue: '段落'&#125;)body.children.push(div);body.children.push(p);function getChildren(ele) &#123; for(var i = 0; i &lt; ele.children.length; i++) &#123; var child = ele.children[i]; console.log(child.nodeName); getChildren(child); &#125;&#125;getChildren(doc); 获取页面元素为什么要获取页面元素例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作 获取元素的方式12345678910111213141516通过id获取:document.getElementById(&apos;id名&apos;); 返回一个对象，没有返回null通过类名获取：document.getElementsByClassName(&apos;cls&apos;) 返回一个数组通过标签名获取：document.getElementsByTagName(&apos;li&apos;) 返回一个数组根据name获取：document.getElementsByName(&apos;li&apos;) 返回一个数组根据选择器获取：document.querySelector(&apos;.cls&apos;) 返回一个对象根据选择器获取：document.querySelectorAll(&apos;li&apos;) 返回一个数组通过选择器获取选中的元素[伪类选择器],获取已经被选中的input元素 input:checkedinput:checked &#123; width: 100px; height: 100px;&#125;获取已经选中的下拉框中的选项 下拉框选中的选项使用option：checked来选择 var options = document.querySelectorAll(&apos;#sel1 option:checked&apos;); 千万不要使用:selected html5标签属性：multiple 作用：让下拉框可以实现多选 12345678910111213141516171819202122232425262728293031323334353637获取已经选中的下拉框中的选项 下拉框选中的选项使用option：checked来选择&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; select &#123; width: 100px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html5标签属性：multiple 作用：让下拉框可以实现多选 --&gt; &lt;select id=&quot;sel1&quot; multiple&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;sh&quot; selected&gt;上海&lt;/option&gt; &lt;option value=&quot;nj&quot; selected&gt;南京&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;script&gt; // 获取所有的option var options = document.querySelectorAll(&apos;#sel1 option&apos;); console.log(options); // 获取已经选中的option var options = document.querySelectorAll(&apos;#sel1 option:checked&apos;); // 注意：千万不要使用:selected console.log(options); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件事件三要素事件源、触发和响应 事件源:触发(被)事件的元素 事件类型:事件的触发方式(例如鼠标点击或键盘点击) 事件处理程序:事件触发后要执行的代码(函数形式) 事件处理程序的本质：其实就是元素中的一个方法而已。 事件的基本使用1234var box = document.getElementById('box');box.onclick = function() &#123; console.log('代码会在box被点击后执行'); &#125;; 案例 点击按钮弹出提示框 123btn.onclick = function()&#123; alert(&apos;哈哈&apos;);&#125; 点击按钮修改元素的样式 123btn.onclick = function()&#123; dv.style.width = &apos;300px&apos;;&#125; 点击按钮修改超链接的地址和热点文字 12345btn.onclick = function()&#123; var link = document.getElementById(&apos;link&apos;); link.href = &apos;1.html&apos;; link.title = &apos;热点文字&apos;;&#125; 点击按钮显示哈哈(排他功能) 点击按钮显示和隐藏div 1234567891011121314151617181920第一种：btn.onclick = function()&#123; if(this.value == &apos;隐藏&apos;)&#123; dv.style.display = &apos;none&apos;; this.value = &apos;显示&apos;; &#125;else&#123; dv.style.display = &apos;block&apos;; this.value = &apos;隐藏&apos;; &#125;&#125;第二种：btn.onclick = function()&#123; if(dv.className != &apos;cls&apos;)&#123; dv.className = &apos;cls&apos;; this.value = &apos;显示&apos;; &#125;else&#123; dv.className= &apos;&apos;; this.value = &apos;隐藏&apos;; &#125;&#125; 显示和隐藏二维码 点击按钮修改所有p标签内容 123456btn.onclick = function()&#123; var plist = document.getElementsByTagName(&apos;p&apos;); for(var i = 0; i &lt; plist.length; i++)&#123; plist[i].innerText = &apos;sdaf &apos;; &#125;&#125; 点击按钮修改所有input文本框内容 12345678btn.onclick = function()&#123; var inputlist = document.getElementsByTagName('input'); for(var i = 0; i &lt; inputlist.length; i++)&#123; if(inputlist[i].type != 'button')&#123; inputlist[i].value = 'hsh'; &#125; &#125;&#125; 点击按钮切换图片 案例的排他功能 12345678for(var i = 0; i &lt; btnlist.length; i++)&#123; btnlist[i].onclick = function()&#123; for(var j= 0; j &lt; btnlist.length; j++)&#123; btnlist[j].value = &apos;无&apos;; &#125; this.value = &apos;有&apos;; &#125;&#125; 点击小图显示大图 美女相册 点击按钮选中性别和兴趣 属性操作非表单元素的属性innerHTML和innerText12345var box = document.getElementById('box');box.innerHTML = '我是文本&lt;p&gt;我会生成为标签&lt;/p&gt;';console.log(box.innerHTML);box.innerText = '我是文本&lt;p&gt;我不会生成为标签&lt;/p&gt;';console.log(box.innerText); 操作非表单元素对象属性 元素对象.calssName 作用：操作元素的类名 元素对象.innerHTML 作用：操作元素的内容 元素对象.innerText 作用：操作元素的内容 兼容性好 元素对象.textContent 标准属性 在IE低版本浏览器中有兼容性问题 数组和伪数组的区别 相同点 数组中的数据都是有序的 都有length属性 不同点 伪数组无法使用数组的方法 script标签位置1因为浏览器加载网页或执行代码时,顺序是从上到下执行的,执行到js代码时,还没有获取到按钮标签，还没有把按钮变成对象放到DOM树上，所以无法获取。所以得到的是null. 表单元素属性 value 用于大部分表单元素的内容获取(option除外) type 可以获取input标签的类型(输入框或复选框等) disabled 禁用属性 checked 复选框选中属性 selected 下拉菜单选中属性 元素.value 获取和设置 元素.checked 是否选中 元素.disabled 是否禁用 元素.readyonly 只读 元素.selected 下拉框选中 自定义属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 与element.属性的区别: 上述三个方法用于获取任意的行内属性。 获取：元素.getAttribute(‘属性名’) 设置： 元素.setAttribute(‘属性名’,’属性值’) 删除：元素.removeAttribute(‘属性名’) 操作元素样式 通过元素的style属性来设置样式 1234var box = document.getElementById('box');box.style.width = '100px';box.style.height = '100px';box.style.backgroundColor = 'red'; 通过类名className属性设置样式 123var box = document.getElementById('box');box.className = 'clearfix';先获取后替换再赋值 案例 开关灯 点击按钮变色 图片切换二维码案例 当前输入的文本框高亮显示 点击按钮改变div的大小和位置 列表隔行变色、高亮显示 京东商品展示 tab选项卡切换 给文本框赋值，获取文本框的值 点击按钮禁用文本框 搜索文本框 检测用户名是否是3-6位，密码是否是6-8位，如果不满足要求高亮显示文本框 设置下拉框中的选中项 全选反选 登录验证 同意协议可以注册 选餐 动态创建表格【数据、删除（事件委托）】 权限案例 百度案例 创建元素的三种方式document.write()12document.write('新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;');如果在页面加载完创建元素，页面中的内容会消失 元素.innerHTML=’内容’1234567var box = document.getElementById('box');box.innerHTML = '新内容&lt;p&gt;新标签&lt;/p&gt;';缺点：会覆盖部分网页元素及事件 通过拼接来解决元素覆盖问题 会覆盖前面的内容,先获取原来的内容，再拼接。 原来的事件也会消失 相当于赋值 document.createElement(‘标签名’)12345678创建元素var div = document.createElement('div');设置内容div.innerText = '啊哈哈';添加到父元素父元素.appendChild(div);优点：不会覆盖原有内容和事件缺点：后添加的事件没有事件【新添加的元素再设置一个事件】:如果后添加的元素没有设置事件，只添加元素，后来的是没有事件的，如果添加事件后再添加，可以有事件。 性能问题 innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。 可以借助字符串或数组的方式进行替换，再设置给innerHTML 优化后与document.createElement性能相近 12345- innerHTML 会产生字符串解析，由于字符串的不可变性，尽量避免大量的拼接，否则消耗内存，影响性能。- document.createElement(&apos;标签&apos;)创建的性能要比innerHTML要高，但是若涉及到多层嵌套内容时，代码操作麻烦。- 所以，一般情况下,两者配合使用较多 - document.createElement用来创建元素 - innerHTML可以设置元素中的内容（元素内部的标签或文本） 1234567总结：innerHTML:往页面中添加元素时，会把页面中原来的元素覆盖掉使用innerHTML添加元素，页面中如果有事件，原来的事件也会消失 ① 重新设置ul的innerHTML时，若不拼接，则会覆盖原有的内容。 ② 会覆盖之前原有的子元素的是事件解决：用第二种创建方式通过document.createElement创建元素，原来的元素的事件存在，后来添加的元素没有事件，除非给新元素添加事件。 案例 动态创建列表，高亮显示 根据数据动态创建表格 模拟百度搜索文本框 点击按钮创建一个li追加到ul中 遍历一组对象 根据一组数据，动态生成表格，并实现删除功能。 把一个下拉列表中所有的option移动的另一个下拉列表中 获取已经选中的option 权限选择 节点操作追加、删除，插入、替换节点123456789++ 追加元素 父节点.appendChild(子元素)++ 删除元素 父节点.removeChild(子元素)++ 插入元素 父元素.insertBefore(新的节点，旧的节点) 将一个新的节点插入到父节点中的某个子节点的前面++ 替换元素 父节点.replaceChild(新的子节点,旧的子节点) 节点层级获取重点讲父子属性，兄弟属性画图讲解 12345678910111213141516box.parentElement 获取当前节点的父级元素box.parentNode 获取一个节点的父节点box.childNodes 获取子节点box.children 获取子元素box.nextSibling 获取下一个兄弟节点box.nextElementSibling 获取下一个兄弟元素box.previousSibling 获取上一个兄弟节点box.previousElementSibling; 获取第一个孩子元素box.firstChild 获取第一个孩子节点box.firstElementChild 获取第一个孩子元素box.lastChild 获取最后一个孩子节点box.lastElementChild 获取最后一个孩子元素在IE8中： 子节点是子元素，子元素是undefined 谷歌、火狐都支持 注意 childNodes和children的区别，childNodes获取的是子节点，children获取的是子元素 nextSibling和previousSibling获取的是节点，获取元素对应的属性是nextElementSibling和previousElementSibling获取的是元素 ​ nextElementSibling和previousElementSibling有兼容性问题，IE9以后才支持 总结 1234567891011节点操作，方法 appendChild() insertBefore() removeChild() replaceChild()节点层次，属性 parentNode childNodes children nextSibling/previousSibling firstChild/lastChild 节点nodeType、nodeName、nodeValue123nodeType：标签→1 属性：2 文本→3nodeValue：标签→null 属性：属性值 文本：文本值-nodeName含义：标签：大写 属性：小写 文本：#text 案例案例1：点击按钮创建一个li追加到ul中 案例2：遍历一组对象。 案例3：根据一组数据，动态生成表格，并实现删除功能。 案例5：把一个下拉列表中所有的option移动的另一个下拉列表中 案例6：获取已经选中的option 案例7：权限选择 事件监听事件监听可以给元素绑定多个事件处理程序。在实际开发中， 便于对事件程序的功能扩展。 事件目标：也被称为 事件源，指的是要注册事件的那个元素节点。 事件类型：指的是什么样的行为，如：鼠标点击、鼠标移入和移出、鼠标移动、键盘按下等等。 onclick 鼠标点击事件 onchange 表单元素内容方式改变时→ 下拉框 onfocus 文本框获取焦点事件 onblur 文本框失去焦点事件 onmouseover 鼠标进入 onmouseout 鼠标离开 onkeyup 键盘抬起 onmousemove鼠标移动 onscroll 滚动事件 onmousedown 鼠标按下事件 onmouseenter 鼠标进入元素事件 onmouseleave 鼠标离开元素事件 oninput 输入框输入事件→ 文本框、文本域 事件处理程序：事件触发后要执行的代码，用 函数表示。函数体中的代码，在事件触发后执行。 注册/移除事件的三种方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var box = document.getElementById('box');第一种注册事件的方式box.onclick = function () &#123; console.log('点击后执行');&#125;;缺点： - 如果使用onclick来注册多个事件，后面的事件会 把原来的事件覆盖掉 - 解决方案：使用时间监听来注册事件第一种移除事件的方式box.onclick = null;第二种注册事件方式：事件监听注册事件/* IE8不支持，谷歌、火狐支持 功能：给元素注册事件 参数： 事件类型 字符串 注意：事件名不加on 如 'click' 事件处理程序 函数 是否捕获：可选，默认为false ， true表示启用捕获 false表示启用冒泡*/事件目标.addEventListener(事件类型【没有on】,事件处理程序,是否捕获);box.addEventListener('click', eventCode, false);addEventListener注册事件不会覆盖，只会在原有事件上添加新的功能，不会覆盖。第二种移除事件的方式：/* 功能：移除元素的指定事件程序 参数： 事件类型 字符串 注意：事件名不加on 如：'click' 事件处理程序：函数 注意：这里要把函数名传入过来*/事件目标.removeEventListener(事件类型【没有on】,事件处理程序名称,false);box.removeEventListener('click', eventCode, false);第三种注册事件的方式：/* 谷歌、火狐不支持，IE8支持 功能：给元素注册事件 参数： 事件类型 字符串 注意：事件名加on 如 'onclick' 事件处理程序 函数*/事件目标.attachEvent(事件类型,事件处理程序);box.attachEvent('onclick', eventCode);第二种移除事件的方式：/* 功能：移除元素的指定事件程序 参数： 事件类型 字符串 注意：事件名加on 如：'click' 事件处理程序：函数 注意：这里要把函数名传入过来*/事件目标.detachEvent(事件类型,事件处理程序名称);box.detachEvent('onclick', eventCode); 为元素绑定事件的兼容代码12345678910111213141516171819function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent)&#123; element.attachEvent('on' + type,fn); &#125; else &#123; element['on'+type] = fn; &#125;&#125;function removeEventListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, fn); &#125; else &#123; element['on'+type] = null; &#125;&#125; 面试绑定事件的区别123456789相同点： 都可以为元素绑定事件不同点： 方法名不同 参数个数不同 浏览器支持不同 事件类型：事件名不同（有on无on） this不同：addEventListener：当前绑定事件的对象 attachEvent：window 事件的三个阶段 事件捕获阶段 从外到里 true 事件目标阶段 事件冒泡阶段 从里到外 false 事件对象.eventPhase属性可以查看事件触发时所处的阶段 面试：事件几个阶段 分别是 绑定事件3种方式 特点 事件对象的属性和方法 event.type 获取事件类型 clientX/clientY 可视区域的横纵坐标 offsetX/offsetY 鼠标在指定的元素的区域中的坐标 pageX/pageY 获取鼠标在整个文档区域中的坐标 pageX/pageY IE8以前不支持，页面位置 event.target || event.srcElement 用于获取触发事件的元素 event.preventDefault() 阻止默认事件 return false 阻止事件冒泡 e.stopPropagation(); window.event.cancelBubble = true; 案例 跟着鼠标飞的天使 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; width: 200px; position: absolute; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;bird.png&quot; alt=&quot;&quot;&gt; &lt;script&gt; var im = document.querySelector(&quot;img&quot;); document.onmousemove = function(e)&#123; im.style.left = e.clientX -100 + &quot;px&quot;; im.style.top = e.clientY -100+ &quot;px&quot;; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 鼠标点哪图片飞到哪里 获取鼠标在div内的坐标 冒泡事件多个元素嵌套，有层次关系，这些元素都注册了相同事件，如果里面的事件触发，外面的事件也会触发 阻止事件传播的方式 标准方式 event.stopPropagation(); 谷歌、火狐支持 IE低版本 window.event.cancelBubble = true; 标准中已废弃 谷歌、IE8支持,火狐不支持 常用的鼠标和键盘事件 onmouseup 鼠标按键放开时触发 onmousedown 鼠标按键按下触发 onmousemove 鼠标移动触发 onkeyup 键盘按键按下触发 onkeydown 键盘按键抬起触发 键盘事件对象的属性 事件对象.altKey 作用：检测是否按下键盘上的 Alt键。 按下返回 true 代码： 123document.onkeydown = function (e) &#123; alert(e.altKey); // 按下alt键，返回true &#125; 事件对象.ctrlKey 作用：检测是否按下键盘上的 Ctrl键。 按下返回 true 代码： 12document.onkeydown = function (e) &#123; alert(e.ctrlKey); // 按下Ctrl键，返回true 事件对象.shiftKey 作用：检测是否按下键盘上的 Shift键。 按下返回 true 代码： 123document.onkeydown = function (e) &#123; alert(e.shiftKey); // 按下shift键，返回true &#125; *事件对象.keyCode** 作用：返回被敲击的键生成的 Unicode 字符码(ascii码) 代码： 123document.onkeydown = function (e) &#123; alert(e.keyCode); // 返回ascii码表对应的十进制的数字 &#125; 兼容问题获取事件对象 标准方式： 事件处理程序函数的第一个参数 e IE低版本方式：window.event 兼容处理： 1234document.onclick = function (e) &#123; // 事件对象的兼容处理 var _event = e || window.event; &#125;; 为同一个元素绑定多个事件执行同一个事件处理函数12345678910111213141516btn.onclick = f1;btn.onmouseover = f1;btn.onmouseout = f1;function f1(e)&#123; switch(e.type)&#123; case &apos;click&apos;: alert(&apos;sdaf&apos;); break; case &apos;mouseenter&apos;: alert(&apos;sdaf&apos;); break; case &apos;mouseout&apos;: alert(&apos;sdaf&apos;); break; &#125;&#125; 案例案例1：鼠标跟着图片走 案例2：拖拽 123456789101112131415161718192021222324252627282930313233343536373839404142按下div onmousedown 在文档中移动 document.onmousemove 在div中弹起 onmouseup document.onmousemove事件解绑 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 80px; line-height: 80px; text-align: center; background: red; border: 1px solid skyblue; position: absolute; user-select: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;webqianduan&lt;/div&gt; &lt;script&gt; var dv = document.querySelector(&quot;div&quot;); dv.onmousedown = function(e)&#123; var spaceX = e.offsetX; var spaceY = e.offsetY; document.onmousemove = function(e)&#123; dv.style.left = e.clientX - spaceX+ &quot;px&quot;; dv.style.top = e.clientY - spaceY + &quot;px&quot;; console.log(e.offsetX); console.log(e.offsetY); &#125; &#125; dv.onmouseup = function(e)&#123; document.onmousemove = null; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 案例3：获取元素样式属性的left和top值 案例4：愤怒的小鸟，键盘控制 特效偏移量 offsetParent用于获取定位的父级元素 offsetParent和parentNode的区别 123456var box = document.getElementById('box');console.log(box.offsetParent);console.log(box.offsetLeft);console.log(box.offsetTop);console.log(box.offsetWidth);console.log(box.offsetHeight); 客户区大小12345var box = document.getElementById('box');console.log(box.clientLeft);console.log(box.clientTop);console.log(box.clientWidth);console.log(box.clientHeight); 滚动偏移12345var box = document.getElementById('box');console.log(box.scrollLeft)console.log(box.scrollTop)console.log(box.scrollWidth)console.log(box.scrollHeight) 案例 匀速动画函数 变速动画函数 回到顶部 无缝轮播图 模拟滚动条 拖拽案例 放大镜案例 附录元素的类型 关于性能1.精灵图2.document.createElement的执行速度比innerHTML快 兄弟选择器1234最终美化的是li,但是条件是li之前必须有一个同级的兄弟也是li.不包括第一个。li + li &#123; margin-top: 10px;&#125; for循环 和 for-in循环的区别 for循环：一般用来遍历数组或伪数组。 for-in循环：用来遍历对象。 注意：对象不能用for循环遍历，因为对象中的数据是无序的。 12345678910111213var obj = &#123; pid: 10001, pName: &apos;自行车&apos;, price: 100, count: 10 &#125;; /* // key表示对象中的某一个属性名→键名→字符串 for(var key in 对象) &#123; // 循环体 // 对象[&apos;键名&apos;] // 对象[key]; 取出属性对应的值 !!!注意：千万不要用 对象.key &#125; */ for(var key in obj) &#123; // console.log(obj.key); // undefined console.log(obj[key]); // 正确方式 输入框输入事件123456789101112oninput事件 ，用户输入时的一个行为会被检测一般设置给文本框或文本域输入框输入事件&lt;input type=&quot;text&quot;&gt;&lt;script&gt; var input =document.querySelector(&apos;input&apos;); // 注册事件 input.oninput = function() &#123; // this → 输入框 console.log(this.value); &#125;;&lt;/script&gt; 属性：用户不能选中文字1user-select:none; 轮播图简单轮播图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261.//封装动画函数----匀速的// 封装动画函数var timeId;function move(element,target)&#123; clearInterval(timeId); timeId = setInterval(function()&#123; // 获取当前的位置 var current = element.offsetLeft; var step = (target - current)/10; step = target - current &gt; 0 ? Math.ceil(step): Math.floor(step); if(Math.abs(current - target) &gt; Math.abs(step) )&#123; element.style.left = (current + step) + &apos;px&apos;; &#125;else &#123; element.style.left = target + &apos;px&apos;; clearInterval(timeId); &#125; &#125;,50);&#125;2.简单轮播图实现&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; text-decoration: none; &#125; #dv &#123; width: 730px; height: 454px; margin: 20px auto; overflow: hidden; position: relative; &#125; .img &#123; width: 600%; position: absolute; &#125; .img li &#123; float: left; list-style: none; &#125; .circle &#123; position: absolute; bottom: 10px; left: 50%; margin-left: -100px; width: 200px; height: 30px; background: rgba(255,255,255, 0.5); &#125; .circle li &#123; width: 20px; height: 20px; background: #000; float: left; margin: 5px 6px 0; border-radius: 50%; &#125; li.current &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&apos;dv&apos;&gt; &lt;ul class=&apos;img&apos;&gt; &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;circle&quot;&gt; &lt;li class=&apos;current&apos;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; 获取移动的ul var ulimg = document.getElementsByClassName(&apos;img&apos;)[0]; 获取div的宽度（一张图片的宽度） var imgWidth = document.getElementById(&apos;dv&apos;).offsetWidth; // 获取小圆点 var list = document.querySelectorAll(&apos;.circle li&apos;); for(var i = 0; i &lt; list.length; i++)&#123; list[i].index = i; list[i].onmouseenter = function()&#123; for(var j = 0; j &lt; list.length; j++)&#123; list[j].className = &apos;&apos;; &#125; this.className = &apos;current&apos;; // 获取对应的索引 var index = this.index; move(ulimg, -index*imgWidth); &#125; &#125; // 封装动画函数 var timeId; function move(element,target)&#123; clearInterval(timeId); timeId = setInterval(function()&#123; // 获取当前的位置 var current = element.offsetLeft; var step = (target - current)/10; step = target - current &gt; 0 ? Math.ceil(step): Math.floor(step); if(Math.abs(current - target) &gt; Math.abs(step) )&#123; element.style.left = (current + step) + &apos;px&apos;; &#125;else &#123; element.style.left = target + &apos;px&apos;; clearInterval(timeId); &#125; &#125;,50); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 左右焦点轮播图1234567891011121314点击右边的按钮var index = 0;right.onclick = function()&#123; if(index &lt; lilist.length - 1)&#123; index++; animation(ulimg,-index.imgWidth); &#125;&#125;left.onclick = function()&#123; if(index &gt; 0)&#123; index--; animation(ulimg,-index.imgWidth); &#125;&#125; 无缝连接的轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; img &#123; vertical-align: top; &#125; /*取消图片底部3像素距离*/ .box &#123; width: 300px; height: 200px; margin: 100px auto; background-color: pink; border: 1px solid red; position: relative; overflow: hidden; &#125; .box ul li &#123; float: left; &#125; .box ul &#123; width: 1500px; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot; id=&quot;screen&quot;&gt; &lt;ul&gt; &lt;li id=&quot;li1&quot;&gt;&lt;img src=&quot;imagess/01.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/02.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/03.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/04.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;imagess/01.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function animate(element,target) &#123; clearInterval(element.setId); element.setId=setInterval(function () &#123; //获取元素的当前的位置 var current=element.offsetLeft;//数字类型的 //每次移动的步数 var step=10; step=current&lt;target?step:-step; //设置当前位置的值 current+=step; if(Math.abs(current-target)&gt;Math.abs(step))&#123; element.style.left=current+&quot;px&quot;; &#125;else&#123; element.style.left=target+&quot;px&quot;; //到达目标,清理计时器 clearInterval(element.setId); &#125; &#125;,10); &#125; var ulObj=my$(&quot;screen&quot;).children[0]; function f1() &#123; //当前位置 var current=ulObj.offsetLeft; current-=10;//每次移动后的位置 if(current&lt;-1200)&#123;//判断界限 ulObj.style.left=&quot;0px&quot;; &#125;else&#123; ulObj.style.left=current+&quot;px&quot;; &#125; &#125; var timeId=setInterval(f1,10); my$(&quot;screen&quot;).onmouseover=function () &#123; clearInterval(timeId); &#125;; my$(&quot;screen&quot;).onmouseout=function () &#123; timeId=setInterval(f1,10); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 鸠摩搜索 javascript王者归来Day01JavaScript组成ECMAscript:JS的基础语法 DOM: document oject model 文档对象模型 操作页面元素 BOM:browser object model 浏览器对象模型 操作浏览器元素 节点：页面中所有的内容都是节点，标签、属性和文本 innerText和textContent凡是成对的标签，中间的文本设置的时候都使用innerText这个属性的方式 css属性是多个单词的写法，在js中DOM操作时，去掉-,后面单词大写即可。 background-color: backgroundColor 1234567891011121314151617181920设置任意标签中间的任意内容function setInnerText(ele,text)&#123; if(typeof ele.textContent == &apos;undefined&apos;)&#123; ele.innerText = text; &#125;else&#123; ele.textContent = text; &#125;&#125;获取任意标签中间的任意内容function getInnerText(ele)&#123; if(typeof ele.textContent == &apos;undefined&apos;)&#123; return ele.innerText; &#125;else&#123; return ele.textContent; &#125;&#125;①设置标签中的内容，使用textContent属性，谷歌、火狐支持，IE8不支持②设置标签中的内容，使用innerText属性，谷歌、火狐、IE8都支持③如果这个属性在浏览器中不支持，那么这个属性的类型为undefined innerText和innerHTML1234561)使用innerText主要设置文本，设置标签内容，没有标签效果2）使用innerHTML可以设置标签，可以设置文本，3）innerHTML:都支持4）总结： 设置文本：innerText textContent innerHTML 设置标签：innerHTML 封装节点兼容代码案例模拟搜索框tab栏切换123456789101112131415161718192021222324252627// 1. 获取一组livar lis = document.querySelectorAll(&apos;.tab-control li&apos;);// 2. 获取一组div显示项var divs = document.querySelectorAll(&apos;.tab-content-item&apos;);// 3. for循环遍历给每一个li注册一个点击事件，给每一个li添加一个index属性，表示li的下标for (var i = 0; i &lt; lis.length; i++) &#123; // 3.1 给每一个li添加一个index属性 lis[i].index = i; // 3.2 注册事件 lis[i].onclick = function () &#123; // this 当前触发的li， // alert(this.index); // 4. 在事件处理程序中，① 切换li ② 切换div // 4.1 循环遍历去掉所有li 和 所有div的类名active for (var j = 0; j &lt; lis.length; j++) &#123; lis[j].className = &apos;&apos;; divs[j].className = &apos;tab-content-item&apos;; &#125; // 4.2 给当前点击的li添加类名active this.className = &apos;active&apos;; // 4.3 获取当前点击的li的下标 var num = this.index; // 找到对应的div项，显示 divs[num].className = &apos;tab-content-item active&apos;; &#125;;&#125; 案例全选和全不选123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; id=&quot;j_cbAll&quot; /&gt; &lt;/th&gt; &lt;th&gt;商品&lt;/th&gt; &lt;th&gt;价钱&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;j_tb&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;iPhone8&lt;/td&gt; &lt;td&gt;8000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;iPad Pro&lt;/td&gt; &lt;td&gt;5000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;iPad Air&lt;/td&gt; &lt;td&gt;2000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;Apple Watch&lt;/td&gt; &lt;td&gt;2000&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;input type=&quot;button&quot; value=&quot; 反 选 &quot; id=&quot;btn&quot;&gt; &lt;/div&gt; &lt;!-- 引入js --&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;index.css* &#123; padding: 0; margin: 0;&#125;.wrap &#123; width: 300px; margin: 100px auto 0;&#125;table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 300px;&#125;th,td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px;&#125;th &#123; background-color: #09c; font: bold 16px &quot;微软雅黑&quot;; color: #fff;&#125;td &#123; font: 14px &quot;微软雅黑&quot;;&#125;tbody tr &#123; background-color: #f0f0f0;&#125;tbody tr:hover &#123; cursor: pointer; background-color: #fafafa;&#125;index.js// 1. 获取thead中的多选框var ck = document.querySelector(&apos;thead input&apos;);// 2. 获取tbody中的一组多选框var cks = document.querySelectorAll(&apos;tbody input&apos;);// 3. 获取反选按钮var btn = document.querySelector(&apos;#btn&apos;);//【功能1：点击thead中的多选框控制tbody中的一组多选框状态】// 1.1 给ck注册点击事件ck.onclick = function () &#123; // 1.2 在事件处理程序中，获取ck的checked var flag = this.checked; // 1.3 循环遍历cks中的每一个多选框，把ck的checked值覆盖给每一个 for (var i = 0; i &lt; cks.length; i++) &#123; cks[i].checked = flag; &#125;&#125;;//【功能2：点击反选按钮控制tbody中的一组多选框，选中的变为不选中，不选中的变为选中】// 1. 给反选按钮注册事件btn.onclick = function () &#123; // 2. 循环遍历cks中每一个多选框 for (var i = 0; i &lt; cks.length; i++) &#123; // 3. 取出每一个多选框的checked值取反，然后再重新赋值给每一个多选框的checked var flag = cks[i].checked; cks[i].checked = !flag; &#125; // 检测 check();&#125;;//【功能3：点击tbody中的某一个多选框时，检测并控制thead中的多选框是否选中】// 1. 循环遍历给tbody中每一个多选框注册点击事件for (var i = 0; i &lt; cks.length; i++) &#123; cks[i].onclick = function () &#123; // 检测 check(); &#125;;&#125;// 封装检测thead多选框是否选中function check() &#123; // 2. 在事件处理程序中，获取已经选中的多选框的个数 var len1 = document.querySelectorAll(&apos;tbody input:checked&apos;).length; // 3. 获取tbody中所有的多选框的个数 var len2 = cks.length; // 4. 比较是否相等，相等则设置ck的checked为true，否则为false if (len1 == len2) &#123; ck.checked = true; &#125; else &#123; ck.checked = false; &#125;&#125;; 百度大项目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #box &#123; width: 450px; margin: 200px auto; &#125; #txt &#123; width: 350px; &#125; #pop &#123; width: 350px; border: 1px solid red; &#125; #pop ul &#123; margin: 10px; padding: 0px; width: 200px; list-style-type: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot; value=&quot;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索&quot; id=&quot;btn&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var keyWords = [&quot;小杨才是最纯洁的&quot;, &quot;小杨才是最帅的&quot;, &quot;小段是最猥琐的&quot;, &quot;小超是最龌龊的&quot;, &quot;传智播客是一个培训机构&quot;, &quot;传说在传智有个很帅很纯洁的小杨&quot;, &quot;苹果好吃&quot;, &quot;苹果此次召回还是没有中国&quot;]; //获取文本框注册键盘抬起事件 my$(&quot;txt&quot;).onkeyup = function () &#123; //每一次的键盘抬起都判断页面中有没有这个div if(my$(&quot;dv&quot;))&#123; //删除一次 my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;)); &#125; //获取文本框输入的内容 var text = this.value; //临时数组--空数组-------&gt;存放对应上的数据 var tempArr = []; //把文本框输入的内容和数组中的每个数据对比 for (var i = 0; i &lt; keyWords.length; i++) &#123; //是否是最开始出现的 if (keyWords[i].indexOf(text) == 0) &#123; tempArr.push(keyWords[i]);//追加 &#125; &#125; //如果文本框是空的,临时数组是空的,不用创建div if (this.value.length == 0 || tempArr.length == 0) &#123; //如果页面中有这个div,删除这个div if (my$(&quot;dv&quot;)) &#123; my$(&quot;box&quot;).removeChild(my$(&quot;dv&quot;)); &#125; return; &#125; //创建div,把div加入id为box的div中 var dvObj = document.createElement(&quot;div&quot;); my$(&quot;box&quot;).appendChild(dvObj); dvObj.id = &quot;dv&quot;; dvObj.style.width = &quot;350px&quot;; //dvObj.style.height=&quot;100px&quot;;//肯定是不需要的------ dvObj.style.border = &quot;1px solid green&quot;; //循环遍历临时数组,创建对应的p标签 for (var i = 0; i &lt; tempArr.length; i++) &#123; //创建p标签 var pObj = document.createElement(&quot;p&quot;); //把p加到div中 dvObj.appendChild(pObj); setInnerText(pObj, tempArr[i]); pObj.style.margin = 0; pObj.style.padding = 0; pObj.style.cursor = &quot;pointer&quot;; pObj.style.marginTop = &quot;5px&quot;; pObj.style.marginLeft = &quot;5px&quot;; //鼠标进入 pObj.onmouseover = function () &#123; this.style.backgroundColor = &quot;yellow&quot;; &#125;; //鼠标离开 pObj.onmouseout = function () &#123; this.style.backgroundColor = &quot;&quot;; &#125;; &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 放大镜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;base.css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;fdj&quot;&gt; &lt;!-- 左侧 --&gt; &lt;div class=&quot;leftBox&quot; id=&quot;_leftBox&quot;&gt; &lt;!-- 小图 --&gt; &lt;img src=&quot;img/m.jpg&quot; alt=&quot;&quot;/&gt; &lt;!-- 小黄盒子 --&gt; &lt;div class=&quot;tool&quot; id=&quot;_tool&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 右侧 --&gt; &lt;div class=&quot;rightBox&quot; id=&quot;_rightBox&quot;&gt; &lt;img id=&quot;_bImg&quot; src=&quot;img/b.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 引入的外部js程序文件 --&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;index.css* &#123; margin:0; padding:0;&#125;.w &#123; width: 1190px; margin: 0 auto;&#125;.fdj &#123; margin-top: 20px;&#125;.fdj .leftBox &#123; width: 400px; height: 400px; border: 1px solid #ccc; float: left; position: relative; overflow: hidden;&#125;.fdj .tool &#123; width: 250px; height: 250px; background:gold; opacity:.5; position: absolute; top:0; left: 0; cursor: move; /* 默认隐藏 */ display: none;&#125;/* 给小黄加上active 就会显示 */.fdj .tool.active &#123; display: block;&#125;.fdj .rightBox &#123; width: 500px; height: 500px; border:1px solid #ccc; float: left; overflow: hidden; /* 隐藏 */ display: none; position: relative;&#125;/* 加上active表示显示 */.fdj .rightBox.active &#123; display: block;&#125;.fdj .rightBox img &#123; position: absolute;&#125;index.js 定时器案例1234567891011121314151617181920212223242526272829function getTime(d1,d2)&#123; var time = d2-d1; var hour = parseInt(time/1000/60/60); var minu = parseInt(time/1000/60%60); var second = parseInt(time/1000%60); hour = hour &lt; 10 ? &quot;0&quot;+hour:hour; minu = minu &lt; 10 ? &quot;0&quot;+minu:minu; second = second &lt; 10 ? &quot;0&quot;+second :second; return &#123; hour:hour, minu:minu, second:second &#125;;&#125; function getDate()&#123; var d1 = new Date(); var d2 = new Date(&quot;2018/9/19 10:30:00&quot;); var time = getTime(d1,d2); span1.innerText = time.hour; span2.innerText = time.minu; span3.innerText = time.second; &#125; getDate(); var num = setInterval(function()&#123; getDate(); if(time.hour==&quot;00&quot;&amp;&amp;time.minu==&quot;00&quot;&amp;&amp;time.second==&quot;00&quot;)&#123; clearInterval(num); &#125; &#125;,1000); 固定导航栏回到顶部轮播图获取样式121)如果样式的代码是在style标签中设置的，外面获取不到。2）如果样式的代码是在style的属性中设置的，外面可以获取到 动画函数：任意一个元素移动到指定位置123456789101112131415function animation (element,target)&#123; clearInterval(element.timeId); element.timeId = setInterval(function()&#123; var current = element.offsetLeft; var step = 10; step = current &lt; target ? step:-step; current += step; if(Math.abs(target-current) &gt; Math.abs(step))&#123; element.style.left = current + &apos;px&apos;; &#125;else&#123; clearInterval(element.timeId); element.style.left = target + &apos;px&apos;; &#125; &#125;,20);&#125; 变速动画函数封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function animation (element,target)&#123; clearInterval(element.timeId); element.timeId = setInterval(function()&#123; var current = element.offsetLeft; var step = (target - current)/10; step = step &gt; 0? Math.ceil(step):Math.floor(step); current += step; if(Math.abs(target-current) &gt; Math.abs(step))&#123; element.style.left = current + &apos;px&apos;; &#125;else&#123; clearInterval(element.timeId); element.style.left = target + &apos;px&apos;; &#125; &#125;,20);&#125;第二种：思想相同function move(element, targetValue, speed) &#123; // 3.1 清除旧的定时器 clearInterval(num); // 4. 时间控制：产生一个定时器 num = setInterval(function () &#123; // 4.1 获取div原有的left值 var v = element.offsetLeft; // 4.1.1 判断是否到达目标 if (v == targetValue) &#123; // 4.1.2 清除定时器 clearInterval(num); // 4.1.2 结束本次函数的执行 return; &#125; // 4.2 在原有基础上+speed或-speed if (Math.abs(targetValue - v) &lt; speed) &#123; // 是最后一步 element.style.left = targetValue + &apos;px&apos;; &#125; else &#123; // 不是最后一步 if (targetValue &gt; v) &#123; v = v + speed; &#125; else &#123; v = v - speed; &#125; // 4.3 重新赋值给div的left样式属性 element.style.left = v + &apos;px&apos;; &#125; &#125;, 10);&#125;; 新版动画函数封装123456789101112131415161718192021222324252627282930313233/* 功能：动画 参数： element 要运动的元素 元素对象 targetValue 目标值 数字 speed 速度（步长） 数字*/function move(element, targetValue) &#123; // 3.1 清除旧的定时器 clearInterval(element.num); // 4. 时间控制：产生一个定时器 element.num = setInterval(function () &#123; // 4.1 获取div原有的left值 var v = element.offsetLeft; // 4.1.1 判断是否到达目标 if (v == targetValue) &#123; // 4.1.2 清除定时器 clearInterval(element.num); // 4.1.2 结束本次函数的执行 return; &#125; // 缓冲的公式 var speed = (targetValue - v) / 10; // 检测方向 if (targetValue &gt; v) &#123; speed = Math.ceil(speed); &#125; else &#123; speed = Math.floor(speed); &#125; //设置物体的位置 element.style.left = v + speed + &apos;px&apos;; &#125;, 10);&#125;; 获取元素计算后的样式属性值12345678910111213获取任意一个元素的任意一个样式属性值的当前值function getStyle(element,attr)&#123; 判断浏览器是否支持这个方法 if(window.getComputedStyle)&#123; return window.getComputedStyle(element,null)[attr]; &#125;else&#123; return element.currentStyle[attr]; &#125;&#125;function getStyle(element,attr)&#123; return window.getComputedStyle?window.ComputedStyle(element,null)[attr]:element.currentStyle[attr]||0;&#125; 封装动画函数增加任意一个属性123456789101112131415161718192021//获取任意的一个属性的当前的属性值: left---&gt;此时的left属性的值,width---当前的元素的宽function getStyle(element,attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr];&#125;function animate(element,attr ,target) &#123; //清理定时器 clearInterval(element.timeId); element.timeId = setInterval(function () &#123; //获取元素的当前位置 var current = parseInt(getStyle(element,attr));//数字类型//== //移动的步数 var step = (target-current)/10; step = step&gt;0?Math.ceil(step):Math.floor(step); current += step; element.style[attr] = current + &quot;px&quot;; if(current==target) &#123; //清理定时器 clearInterval(element.timeId); &#125;&#125; 封装动画函数增加任意多个属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin-top: 30px; width: 200px; height: 100px; background-color: green; position: absolute; left:0; top:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;移动到400px&quot; id=&quot;btn1&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //点击按钮,改变宽度到达一个目标值,高度到达一个目标值 //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值 function getStyle(element,attr) &#123; return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr]||0; &#125; function animate(element,json) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; var flag=true;//默认,假设,全部到达目标 for(var attr in json)&#123; //获取元素这个属性的当前的值 var current=parseInt(getStyle(element,attr)); //当前的属性对应的目标值 var target=json[attr]; //移动的步数 var step=(target-current)/10; step=step&gt;0?Math.ceil(step):Math.floor(step); current+=step;//移动后的值 element.style[attr]=current+&quot;px&quot;; if(current!=target)&#123; flag=false; &#125; &#125; if(flag)&#123; //清理定时器 clearInterval(element.timeId); &#125; //测试代码 console.log(&quot;目标:&quot;+target+&quot;,当前:&quot;+current+&quot;,每次的移动步数:&quot;+step); &#125;,20); &#125; my$(&quot;btn1&quot;).onclick=function () &#123; animate(my$(&quot;dv&quot;),&#123;&quot;width&quot;:400,&quot;height&quot;:500,&quot;left&quot;:500,&quot;top&quot;:80&#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装动画函数增加任意多个属性和回调函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; margin-top: 30px; width: 200px; height: 100px; background-color: green; position: absolute; left:0; top:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;移动到400px&quot; id=&quot;btn1&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //点击按钮,改变宽度到达一个目标值,高度到达一个目标值 //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值 function getStyle(element,attr) &#123; return window.getComputedStyle? window.getComputedStyle(element,null)[attr]:element.currentStyle[attr]||0; &#125; //element---元素 //json---对象---多个属性及多个目标值 //fn---函数 function animate(element,json,fn) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; var flag=true;//默认,假设,全部到达目标 for(var attr in json)&#123; //获取元素这个属性的当前的值 var current=parseInt(getStyle(element,attr)); //当前的属性对应的目标值 var target=json[attr]; //移动的步数 var step=(target-current)/10; step=step&gt;0?Math.ceil(step):Math.floor(step); current+=step;//移动后的值 element.style[attr]=current+&quot;px&quot;; if(current!=target)&#123; flag=false; &#125; &#125; if(flag)&#123; //清理定时器 clearInterval(element.timeId); //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数 if(fn)&#123; fn(); &#125; &#125; //测试代码 console.log(&quot;目标:&quot;+target+&quot;,当前:&quot;+current+&quot;,每次的移动步数:&quot;+step); &#125;,20); &#125; my$(&quot;btn1&quot;).onclick=function () &#123; var json1=&#123;&quot;width&quot;:400,&quot;height&quot;:500,&quot;left&quot;:500,&quot;top&quot;:80&#125;; animate(my$(&quot;dv&quot;),json1,function () &#123; var json2=&#123;&quot;width&quot;:40,&quot;height&quot;:50,&quot;left&quot;:50,&quot;top&quot;:800&#125;; animate(my$(&quot;dv&quot;),json2,function () &#123; var json3=&#123;&quot;width&quot;:450,&quot;height&quot;:550,&quot;left&quot;:550,&quot;top&quot;:600&#125;; animate(my$(&quot;dv&quot;),json3); &#125;); &#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装动画函数增加任意多个属性和回调函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 200px; height: 100px; background-color: green; position: absolute; left: 0; top: 0; &#125; input &#123; z-index: 10; position: absolute; left: 0; top: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;移动到400px&quot; id=&quot;btn1&quot;/&gt;&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //点击按钮,改变宽度到达一个目标值,高度到达一个目标值 //获取任意一个元素的任意一个属性的当前的值---当前属性的位置值 function getStyle(element, attr) &#123; return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr] || 0; &#125; function animate(element, json, fn) &#123; clearInterval(element.timeId);//清理定时器 //定时器,返回的是定时器的id element.timeId = setInterval(function () &#123; var flag = true;//默认,假设,全部到达目标 //遍历json对象中的每个属性还有属性对应的目标值 for (var attr in json) &#123; //判断这个属性attr中是不是opacity if (attr == &quot;opacity&quot;) &#123; //获取元素的当前的透明度,当前的透明度放大100倍 var current = getStyle(element, attr) * 100; //目标的透明度放大100倍 var target = json[attr] * 100; var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step;//移动后的值 element.style[attr] = current / 100; &#125; else if (attr == &quot;zIndex&quot;) &#123; //判断这个属性attr中是不是zIndex //层级改变就是直接改变这个属性的值 element.style[attr] = json[attr]; &#125; else &#123; //普通的属性 //获取元素这个属性的当前的值 var current = parseInt(getStyle(element, attr)); //当前的属性对应的目标值 var target = json[attr]; //移动的步数 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step;//移动后的值 element.style[attr] = current + &quot;px&quot;; &#125; //是否到达目标 if (current != target) &#123; flag = false; &#125; &#125; if (flag) &#123; //清理定时器 clearInterval(element.timeId); //所有的属性到达目标才能使用这个函数,前提是用户传入了这个函数 if (fn) &#123; fn(); &#125; &#125; //测试代码 console.log(&quot;目标:&quot; + target + &quot;,当前:&quot; + current + &quot;,每次的移动步数:&quot; + step); &#125;, 20); &#125; //zIndex:1000 //透明度: 数字类型----小数---放大100倍 my$(&quot;btn1&quot;).onclick = function () &#123; var json1 = &#123;&quot;width&quot;: 400, &quot;height&quot;: 500, &quot;left&quot;: 500, &quot;top&quot;: 80, &quot;opacity&quot;: 0.2&#125;; animate(my$(&quot;dv&quot;), json1, function () &#123; animate(my$(&quot;dv&quot;), &#123;&quot;width&quot;: 40, &quot;height&quot;: 50, &quot;left&quot;: 0, &quot;top&quot;: 0, &quot;opacity&quot;: 1, &quot;zIndex&quot;: 1000&#125;); &#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动画函数封装注意问题1234567891011121314// 问题1：多次点击按钮时，盒子的运动节奏混乱（加快）。// 原因：每次点击按钮会产生一个定时器操作div,多次点击会产生多个定时器操作div，速度会叠加。// 解决：保证始终只有一个定时器操作元素// 问题2：盒子无休止的运动。// 原因： 因为没有设置目标值// 解决：在+10之前，应该判断是否到达目标，若到达目标，则先清除定时器，而且要结束本次函数的执行。//问题3：盒子反方向运动解决：判断当前值与目标值：当前值&gt;目标值 - ，反之，+//问题4：判断是不是最后一步解决：判断当前值-目标值的绝对值 是不是大于每次增加的步数 三大系列offset系列:返回数字，不含单位1234567offsetWidth:获取元素的宽度(有边框) 内容宽度+padding+borderoffsetHeight:获取元素的高度（有边框）offsetLeft: 不脱标情况下：包括父级元素的margin+padding+border+自己的margin 脱标情况下：与父级元素没有关系（只是相对于父级元素）,只与自己的margin有关系offsetTop:同上offsetParent:获取元素的最近定位的上级元素，如果没有定位的上级元素，获取body scroll系列1234scrollWidth:元素中内容的实际的宽(没有边框),如果没有内容就是元素的宽 内容+padding,返回数字，没有单位scrollHeight:元素中内容的实际的高(没有边框),如果没有内容就是元素的高scrollTop:向上卷曲出去的距离scrollLeft:向左卷曲出去的距离 client系列1234clientWidth:可视区域的宽高（没有边框）:width + padding(左右) ;clientHeight:clientLeft:左边|上边边框的宽度clientTop: 封装getScroll函数12345678910function scroll()&#123; return &#123; left:window.pageXoffset||document.documentElement.scrollLeft||document.body.scrollLeft||0, top:window.pageYoffset||document.documentElement.scrollTop||document.body.scrollTop||0 &#125;;&#125;测试：window.onscroll = function()&#123; console.log(scroll().top);&#125; 通过document获取元素1234获取body：document.body 获取的是元素、标签获取title:document.title 获取的是标签中的值 修改title中的值：document.title = &apos;士大夫&apos;；获取html:document.documentElement 案例图片跟着鼠标飞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; height: 2000px; &#125; img&#123; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;images/bird.png&quot; alt=&quot;&quot; id=&quot;im&quot; /&gt;&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //图片跟着鼠标飞,可以在任何的浏览器中实现 //window.event和事件参数对象e的兼容 //clientX和clientY单独的使用的兼容代码 //scrollLeft和scrollTop的兼容代码 //pageX,pageY和clientX+scrollLeft 和clientY+scrollTop //把代码放在一个对象中 var evt=&#123; //window.event和事件参数对象e的兼容 getEvent:function (evt) &#123; return window.event||evt; &#125;, //可视区域的横坐标的兼容代码 getClientX:function (evt) &#123; return this.getEvent(evt).clientX; &#125;, //可视区域的纵坐标的兼容代码 getClientY:function (evt) &#123; return this.getEvent(evt).clientY; &#125;, //页面向左卷曲出去的横坐标 getScrollLeft:function () &#123; return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0; &#125;, //页面向上卷曲出去的纵坐标 getScrollTop:function () &#123; return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0; &#125;, //相对于页面的横坐标(pageX或者是clientX+scrollLeft) getPageX:function (evt) &#123; return this.getEvent(evt).pageX? this.getEvent(evt).pageX:this.getClientX(evt)+this.getScrollLeft(); &#125;, //相对于页面的纵坐标(pageY或者是clientY+scrollTop) getPageY:function (evt) &#123; return this.getEvent(evt).pageY?this.getEvent(evt).pageY:this.getClientY(evt)+this.getScrollTop(); &#125; &#125;; //最终的代码 document.onmousemove=function (e) &#123; my$(&quot;im&quot;).style.left=evt.getPageX(e)+&quot;px&quot;; my$(&quot;im&quot;).style.top=evt.getPageY(e)+&quot;px&quot;; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 元素的不同隐藏方式123display:none; 不占位置visibility:hidden; 占位置opacity:0; 不占位置 用户选择 能不能选择文字1user-select:none; onmouseenter和onmouseover的区别 以及onmouseleave和onmouseout的区别12345- 相同点： - 都是鼠标进入或离开事件，功能一致。- 不同点： - onmouseenter和onmouseleave不冒泡 - onmouseover和onmouseout会冒泡 定时器注意事项1注意：定时器产生和定时器执行是两会事。定时器中的函数体里的代码一定是在非定时器代码执行完最后执行的 common.js格式化时间、获取指定标签对象、设置/获取任意元素的任意内容、绑定和解绑事件的兼容代码 面试：12345678910111213141516171819202122232425262728293031321）定时器： id号 = setInterval（fn,时间（毫秒数））； clearInterval(id号); setTimeout(fn,时间（毫秒数）); clearTimeout(id号);2）创建对象的3个方法document.write(); 页面加载完成后添加元素，原来的内容会消失元素.innerHTML(); 会发生覆盖，原来页面内容会消失对象.createElement(&apos;li);3)innerText\textContent和innerHTMLinnerText:非标准属性，都支持，没有标签效果textContent:标准属性，低版本IE不支持，不支持标签效果innerHTML:都支持，支持标签效果innerText和textContent兼容代码4）封装节点兼容代码firstChild firstElementChild5)绑定事件和解绑事件元素.onclick = fn;元素.addEventLiatener(&apos;无on的事件类型&apos;，fn,false);元素.attachEvent(&apos;有on的事件类型&apos;，fn);元素.onclick = null;,false元素.removeEventListener(&apos;无on的事件类型&apos;,fn,false);元素.detachEvent(&apos;有on的事件类型&apos;,fn);6)事件3个阶段7）事件冒泡阻止事件冒泡： e.stopPropagation(); 谷歌、火狐 window.event.cancelBubble = true; 谷歌、IE88）动画函数封装9)轮播图10）三大系列11）封装getScroll函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F18%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Javascript基础1. JavaScript和HTML、CSS的区别1231. HTML：提供网页的结构，提供网页中的内容2. CSS: 用来美化网页3. JavaScript: 可以用来控制网页内容，给网页增加动态的效果 2. js组成123456 ☞ ECMASCRIPT 定义了javascript的语法规范,描述了语言的基本语法和数据类型 ☞ BOM （Browser Object Model） 即浏览器对象模型。浏览器对象模型,一套操作浏览器功能的API,通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 ☞ DOM (Document Object Model) 文档对象模型,一套操作页面元素的API,DOM可以把HTML看做是文档树，通过 DOM提供的API可以对树上的节点进行操作 【js+HTMl+css】 2.1 ECMAScript - JavaScript的核心1JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 2.2 BOM - 浏览器对象模型12一套操作浏览器功能的API通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 2.3 DOM - 文档对象模型12一套操作页面元素的APIDOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 3.变量3.1 什么是变量 什么是变量 变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量 使用变量可以方便的获取或者修改内存中的数据 3.2 如何使用变量12声明变量用var，可以同时声明多个变量var age; 3.3 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，例如：for、while。 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 4. 数据类型4.1 简单数据类型12345Number、String、Boolean、Undefined、NullNaN与任何值都不相等，包括它本身1. undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined2. null表示一个空，变量的值如果想为null，必须手动设置获取变量的类型： typeof str 4.2 转换成字符串类型1231. str.toString(); undefined和null没有这个2. String(num);3.拼接字符串 str +&apos;&apos; 4.3 转换成数值类型12341) Number(str)2) parseInt(str)3) parseFloat(str)4) 隐式转换 + -0 4.4 转换成布尔类型12Boolean()取反 4.5 运算符的优先级12345678优先级从高到底 1. () 优先级最高 2. 一元运算符 ++ -- ! 3. 算数运算符 先* / % 后 + - 4. 关系运算符 &gt; &gt;= &lt; &lt;= 5. 相等运算符 == != === !== 6. 逻辑运算符 先&amp;&amp; 后|| 7. 赋值运算符 5. 对象创建方式 对象字面量 12345678var o = &#123; name: 'zs', age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; new Object()创建对象 1234567var person = new Object(); person.name = 'lisi'; person.age = 35; person.job = 'actor'; person.sayHi = function()&#123; console.log('Hello,everyBody');&#125; 工厂函数创建对象 1234567891011function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log('Hello,everyBody'); &#125; return person;&#125;var p1 = createPerson('张三', 22, 'actor'); 自定义构造函数 123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayHi = function()&#123; console.log('Hello,everyBody'); &#125;&#125;var p1 = new Person('张三', 22, 'actor'); 5.1 new在执行时会做四件事情1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 5.2 遍历对象的属性 通过for..in语法可以遍历一个对象 1234567var obj = &#123;&#125;;for (var i = 0; i &lt; 10; i++) &#123; obj[i] = i * 2;&#125;for(var key in obj) &#123; console.log(key + "==" + obj[key]);&#125; 5.3 删除对象的属性1234567function fun() &#123; this.name = 'mm';&#125;var obj = new fun(); console.log(obj.name); // mm delete obj.name;console.log(obj.name); // undefined 6. 内置对象6.1 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 演示：Math.PI、Math.random()、Math.floor()/Math.ceil()、Math.round()、Math.abs() 、Math.max() 123456789Math.PI // 圆周率Math.random() // 生成随机数Math.floor()/Math.ceil() // 向下取整/向上取整Math.round() // 取整，四舍五入Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值Math.sin()/Math.cos() // 正弦/余弦Math.power()/Math.sqrt() // 求指数次幂/求平方根 案例123- 求10-20之间的随机数- 随机生成颜色RGB- 模拟实现max()/min() 6.2 Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 12345678// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数Date构造函数的参数1. 毫秒数 1498099000356 new Date(1498099000356)2. 日期格式字符串 '2015-5-1' new Date('2015-5-1')3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 123456789var now = new Date();// valueOf用于获取对象的原始值console.log(date.valueOf()) // HTML5中提供的方法，有兼容性问题var now = Date.now(); // 不支持HTML5的浏览器，可以用下面这种方式var now = + new Date(); // 调用 Date对象的valueOf() 日期格式化方法 1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分 123456789getTime() // 返回毫秒数和valueOf()结果一样，valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718function formatDate(d) &#123; //如果date不是日期对象，返回 if (!date instanceof Date) &#123; return; &#125; var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? '0' + month : month; date = date &lt; 10 ? '0' + date : date; hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute:minute; second = second &lt; 10 ? '0' + second:second; return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125; 计算时间差，返回相差的天/时/分/秒 123456789101112131415function getInterval(start, end) &#123; var day, hour, minute, second, interval; interval = end - start; interval /= 1000; day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125; 6.3 Array对象 创建数组对象的两种方式 字面量方式 new Array() 1234567891011121314// 1. 使用构造函数创建数组对象// 创建了一个空数组var arr = new Array();// 创建了一个数组，里面存放了3个字符串var arr = new Array('zs', 'ls', 'ww');// 创建了一个数组，里面存放了4个数字var arr = new Array(1, 2, 3, 4);// 2. 使用字面量创建数组对象var arr = [1, 2, 3];// 获取数组中元素的个数console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()/valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组对象本身 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() 123456789101112131415161718192021// 1 栈操作(先进后出)push()pop() //取出数组中的最后一项，修改length属性// 2 队列操作(先进先出)push()shift() //取出数组中的第一个元素，修改length属性unshift() //在数组最前面插入项，返回数组的长度// 3 排序方法reverse() //翻转数组sort(); //即使是数组sort也是根据字符，从小到大排序// 带参数的sort是如何实现的？// 4 操作方法concat() //把参数拼接到当前数组slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目)// 5 位置方法indexOf()、lastIndexOf() //如果没找到返回-1// 6 迭代方法 不会修改原数组(可选)every()、filter()、forEach()、map()、some()// 7 方法将数组的所有元素连接到一个字符串中。join() 清空数组 123456// 方式1 推荐 arr = [];// 方式2 arr.length = 0;// 方式3arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 12345678910111213141516function myJoin(array, seperator) &#123; seperator = seperator || ','; array = array || []; if (array.length == 0)&#123; return ''; &#125; var str = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; str += seperator + array[i]; &#125; return str;&#125;var array = [6, 3, 5, 6, 7, 8, 0];console.log(myJoin(array, '-'));console.log(array.join('-')) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 123456789101112131415161718// 方式1var array = [1500,1200,2000,2100,1800];var tmpArray = [];for (var i = 0; i &lt; array.length; i++) &#123; if(array[i] &lt; 2000) &#123; tmpArray.push(array[i]); &#125;&#125;console.log(tmpArray);// 方式2var array = [1500, 1200, 2000, 2100, 1800];array = array.filter(function (item, index) &#123; if (item &lt; 2000) &#123; return true; &#125; return false;&#125;);console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 1234567var array = ['c', 'a', 'z', 'a', 'x', 'a'];do &#123; var index = array.indexOf('a',index + 1); if (index != -1)&#123; console.log(index); &#125;&#125; while (index &gt; 0); 编写一个方法去掉一个数组的重复元素 12345678910111213141516171819202122232425var array = ['c', 'a', 'z', 'a', 'x', 'a'];function clear() &#123; var o = &#123;&#125;; for (var i = 0; i &lt; array.length; i++) &#123; var item = array[i]; if (o[item]) &#123; o[item]++; &#125;else&#123; o[item] = 1; &#125; &#125; var tmpArray = []; for(var key in o) &#123; if (o[key] == 1) &#123; tmpArray.push(key); &#125;else&#123; if(tmpArray.indexOf(key) == -1)&#123; tmpArray.push(key); &#125; &#125; &#125; returm tmpArray;&#125;console.log(clear(array)); 7. 基本包装类型为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean 123456789// 下面代码的问题？// s1是基本类型，基本类型是没有方法的var s1 = 'zhangsan';var s2 = s1.substring(5);// 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于：var s1 = new String('zhangsan');var s2 = s1.substring(5);s1 = null; 1234567// 创建基本包装类型的对象var num = 18; //数值，基本类型var num = Number('18'); //类型转换var num = new Number(18); //基本包装类型，对象// Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如：var b1 = new Boolean(false);var b2 = b1 &amp;&amp; true; // 结果是什么 8. String对象 字符串的不可变 12345var str = 'abc';str = 'hello';// 当重新给str赋值的时候，常量'abc'不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 1234var str = new String('Hello World');// 获取字符串中字符的个数console.log(str.length); 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 1234567891011121314151617181920212223// 1 字符方法charAt() //获取指定位置处字符charCodeAt() //获取指定位置处字符的ASCII码str[0] //HTML5，IE8+支持 和charAt()等效// 2 字符串操作方法concat() //拼接字符串，等效于+，+更常用slice() //从start位置开始，截取到end位置，end取不到substring() //从start位置开始，截取到end位置，end取不到substr() //从start位置开始，截取length个字符// 3 位置方法indexOf() //返回指定内容在元字符串中的位置lastIndexOf() //从后往前找，只找第一个匹配的// 4 去除空白 trim() //只能去除字符串前后的空白// 5 大小写转换方法to(Locale)UpperCase() //转换大写to(Locale)LowerCase() //转换小写// 6 其它search()replace()split()fromCharCode()// String.fromCharCode(101, 102, 103); //把ASCII码转换成字符串 案例 截取字符串”我爱中华人民共和国”，中的”中华” 123var s = "我爱中华人民共和国";s = s.substr(2,2);console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 123456789var s = 'abcoefoxyozzopp';var array = [];do &#123; var index = s.indexOf('o', index + 1); if (index != -1) &#123; array.push(index); &#125;&#125; while (index &gt; -1);console.log(array); 把字符串中所有的o替换成! 1234567var s = 'abcoefoxyozzopp';do &#123; s = s.replace('o', '');&#125; while (s.indexOf('o') &gt; -1);console.log(s);console.log(s.replace(/o/ig, '')); 判断一个字符串中出现次数最多的字符，统计这个次数 1234567891011121314151617181920212223var s = 'abcoefoxyozzopp';var o = &#123;&#125;;for (var i = 0; i &lt; s.length; i++) &#123; var item = s.charAt(i); if (o[item]) &#123; o[item] ++; &#125;else&#123; o[item] = 1; &#125;&#125;var max = 0;var char ;for(var key in o) &#123; if (max &lt; o[key]) &#123; max = o[key]; char = key; &#125;&#125;console.log(max);console.log(char); 作业12345678给定一个字符串如：“abaasdffggghhjjkkgfddsssss3444343”问题如下： 1、 字符串的长度 2、 取出指定位置的字符，如：0,3,5,9等 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法 5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数 7、 遍历字符串，并将遍历出的字符两头添加符号“@”输出至当前的文档页面。 9.Math对象1234567891011121314151617181920☞ 提供了一系列与数学相关的方法或属性 ( 静态 | 实例)☞ Math.PI 获取圆周率【属性】 ☞ Math.random() 返回大于等于0小于1之间的随机数☞ Math.floor() 向下取整，返回一个小于当前数字的整数☞ Math.ceil() 向上取整，返回一个大于当前数字的整数☞ Math.round() 四舍五入（小数如果小于0.5,返回小于当前数字的整数，如果小数部分大于0.5返回大于当前数字的一个整数）☞ Math.abs() 取绝对值（返回当前数字的绝对值，正整数）☞ Math.max() 返回一组数中的最大值 （可以设置多个参数，返回其中最大值，参数不可以是数组）☞ Math.min() 返回一组数中的最小值 （可以同时设置多个参数，与最大值效果一样）☞ Math.sin(x) 返回一个正弦的三角函数 ( 注意： x 是一个以弧度为单位的角度)☞ Math.cos(x) 返回一个余弦的三角函数 （注意： x 参数是一个以弧度为单位的角度）☞ Math.pow(x,y) 返回x的y次幂 10. Date对象123456789101112131415161718192021☞ Date是一个构造函数，必须通过 new Date() 创建一个实例成员才能使用☞ 用法一：空构造函数 var d = new Date(); ☞GMT 格林威治时间（0时区）☞ 用法二：在构造函数中传入毫秒值 var d = new Date(d.valueOf());☞ 用法三： 传入日期格式的字符串 var d = new Date("1988-8-8")☞ 用法四： 传入数字 var d = new Date(year, month[,day,time,second]); //必须设置年和月 备注： 月份从0 开始， 0 代表1月☞ 获取当前时间的毫秒值： d.valueOf() d.getTime() // 推荐使用 Date.now() //H5 新方法 有兼容信息 11. Date中的方法1234567891011121314151617☞ 日期格式化方法var d = new Date(); d.toString(); //转化成字符串 d.toDateString(); //转换成日期字符串 d.toTimeString(); //转换成时间字符串 d.toLocaleDateString(); //返回本地的日期格式 （不同浏览器不同效果） d.toLocaleTimeString(); //返回本地的时间格式 （不同浏览器不同效果）☞ 获取日期其他部分 d.getSeconds() //获取秒 d.getMinutes() //获取分钟 d.getHours() //获取小时 d.getDay() //返回周几 （0表示周日） d.getDate() //返回当前月的第几天 d.getMonth() //返回月份 （从0开始） d.getFullYear() //返回年份 12. Date案例123☞ 写一个函数，格式化日期对象，返回 yyyy-mm-dd HH:mm：ss 形式☞ 写一个函数计算时间差，返回相差的天/时/分/秒 【求 2008年8月8日到今天】 13. 数组中常用的方法1234567891011121314151617181920212223☞ toString() // 把数组转换为字符串，使用逗号分隔☞ valueOf() // 返回数组对象本身var ary = []; ary.toString() ary.valueOf();☞ 栈方法（先进后出） ary.push() // 该方法有一个返回值，表示数组最新的长度，该方法中可以设置多个参数 ary.pop() //返回数组中最后一个字，且会修改数组的长度☞ 队列（先进先出） ary.push() ary.shift() //取出数组中的第一个元素，修改数组的长度 ary.unshift(number) //在数组中最开始位置添加一个值☞ 排序方法 ary.reverse() // 翻转数组 ary.sort() //数组排序 默认是从字符编码排序的☞ 数组的sort方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack配置]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack配置1. webpack安装12webpack全局安装: npm i webpack -gwebpack局部安装: 在项目依赖中运行 npm i webpack --save-dev安装到项目依赖中 2. webpack的引入123Gulp:webpack: 是基于项目进行构建的webpack 要打包的文件的路径 打包好的输出文件的路径 2.1 webpack安装123456789安装webpack，首先需要安装最新版本的Node.js1.安装特定版本 npm install --save-dev webpack npm install --save-dev webpack@&lt;version&gt;2.安装webpack4+以上需要安装webpack cli npm install --save-dev webpack-cli3.对于大多数项目，我们建议本地安装4.全局安装 npm install --global webpack 2.2 隔行变色-使用webpack解析main.js123456789101112131415161718192021222324252627282930313233mian.jsimport $ from &apos;jQuery&apos;;$(function()&#123; $(&apos;li:odd&apos;).css(&apos;background&apos;,&apos;red&apos;); $(&apos;li:even&apos;).css(&apos;background&apos;,function()&#123; return &apos;#D97634&apos;; &#125;);&#125;);index.html&lt;script src=&quot;../src/main.js&quot;&gt;&lt;/script&gt;&lt;ul&gt; &lt;li&gt;这是第1个元素&lt;/li&gt; &lt;li&gt;这是第2个元素&lt;/li&gt; &lt;li&gt;这是第3个元素&lt;/li&gt; &lt;li&gt;这是第4个元素&lt;/li&gt; &lt;li&gt;这是第5个元素&lt;/li&gt; &lt;li&gt;这是第6个元素&lt;/li&gt; &lt;li&gt;这是第7个元素&lt;/li&gt; &lt;li&gt;这是第8个元素&lt;/li&gt; &lt;li&gt;这是第9个元素&lt;/li&gt; &lt;li&gt;这是第10个元素&lt;/li&gt;&lt;/ul&gt;使用npm run serve运行之后,页面中的元素出现后又闪退,控制台报错: Uncaught SyntaxError: Unexpected token import旧版本的浏览器不能识别ES6,可以首先将main.js文件解析之后,再在index.html文件中引入解析之后的文件使用wqebpack解析main.js文件解析为dist/list.js,在index.html文件中引入在index文件中引入main.js文件之后,浏览器不能识别ES6语法,控制台报错,此时需要通过webpack将main.js文件解析为浏览器可以识别的语法命令一:webpack ./main.js ./dist/bundle.js然后在index.html文件中引入bundle.js即可 2.3 webpack基本的文件配置123456789101112131415webpack.config.js配置文件const path = require(&apos;path);module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;&#125;配置文件之后,运行webpack,修改main.js文件中的代码即可实时在页面上显示出来，否则需要重新 运行 webpack ./main.js ./dist/bundle.js 2.4 webpack-dev-server的基本使用123456789101112131415161718191.配置webpack.config.js文件并配置入口、出口之后,每次修改main.js文件的的内容都需要重新运行webpack指令,所以需要优化2.使用webpack-dev-server这个工具来实现自动打包(实时打包)编译的功能 2.1运行npm i webpack-dev-serve -D把这个工具安装到项目的本地开发依赖 2.2安装完毕后,这个工具的用法和webpack命令的用法完全和webpack一样 node nodemon webpack webpack-dev-serve 2.3webpack-dev-serve是在本地安装的不能再终端直接运行 在package.json文件中,配置scripts &quot;scripts&quot;: &#123; 配置一些需要运行的命令 &quot;test&quot;:&quot;echo \&quot;Error:no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot; &#125; 2.4webpack-dev-serve这个工具,如果想要正常运行,要求,在本地项目中，必须安装webpack 2.5运行npm run dev3.在main.js文件中引入的bundle.js不是dist/bundle.js,而是npm run dev之后运行并托管在网站根目录的/bundle.js4.webpack output is served from / webpack输出文件被托管于项目根目录5.webpack-dev-server帮我们打包生成的bundle.js文件，并没有存放到实际的物理磁盘上,而是直接托管到了电脑的内存中,所以,我们在项目根目录中根本找不到这个打包好的bundle.js文件6.webpack把打包好的文件以一种虚拟的形式托管到了项目的根目录,虽然我们看不到它,但是可以认为和dist src node_modules平级,有一个看不见的文件,叫做bundle.js 2.5 webpack-dev-server的常用命令参数123456789101112131415在package.json文件中,配置scripts&quot;scripts&quot;: &#123; 配置一些需要运行的命令 &quot;test&quot;:&quot;echo \&quot;Error:no test specified\&quot; &amp;&amp; exit 1&quot;, 1)配置webpack-dev-server命令 &quot;dev&quot;:&quot;webpack-dev-server&quot;, 2)配置打包完成后自动打开浏览器 &quot;dev&quot;:&quot;webpack-dev-server --open&quot;, 3)配置打包完成后自动打开浏览器 并修改默认8080端口 &quot;dev&quot;:&quot;webpack-dev-server --open --port 3000&quot;, 4)配置打包完成后自动打开浏览器 并修改默认8080端口 打开浏览器默认显示跟路径下的文件列表,修改为显示网站首页 打开src下的index.html文件 &quot;dev&quot;:&quot;webpack-dev-server --open --port 3000 --contentBase src&quot;, 5)--hot 页面样式局部刷新 &quot;dev&quot;:&quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot;,&#125; 2.6 webpack-dev-server配置命令的第2种方法123456789101112131415161718192021222324252627282930313233第一步:package.json文件中配置&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125;第二步:在webpack.config.js文件中const path = require(&apos;path);启用热更新的第二步const webpack = require(&apos;webpack&apos;);module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;, 配置dev-server命令参数第二种方式 devServer: &#123; open: true, //自动打开浏览器 port: 3000, //设置启动时候的运行端口,默认是8080 contentBase: &apos;src&apos;, //指定托管的根目录 hot: true //启用热更新 启用热更新的第一步 &#125;, 启用热更新的第三步 plugins: [ 配置插件节点 new webpack.HotModuleReplacementPlugin() //new一个热更新的模块对象 ]&#125;第三步: 此时运行npm run server控制台会报错, Hot Module Replacement id disabled。 热更新被禁用第四步:配置热更新需要的步骤第五步:npm run dev 2.7 html-webpack-plugin的两个基本作用12345678910111213141516171819202122232425262728293031323334353637383940414243我们在浏览器打开的页面是属于物理磁盘的,而bundle.js文件是属于内存的。而我们需要把页面也放到内存中去,通过插件来实现配置启动页面:html-webpack-plugin1.安装: npm i html-webpack-plugin -D2.配置:webpack.config.js const path = require(&apos;path); 启用热更新的第二步 const webpack = require(&apos;webpack&apos;); 引入配置启动页面的插件 只要是插件,都一定要放到 plugins 节点中去 const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;, 配置dev-server命令参数第二种方式 devServer: &#123; open: true, //自动打开浏览器 port: 3000, //设置启动时候的运行端口,默认是8080 contentBase: &apos;src&apos;, //指定托管的根目录 hot: true //启用热更新 启用热更新的第一步 &#125;, 启用热更新的第三步 plugins: [ 配置插件节点 new webpack.HotModuleReplacementPlugin(), //new一个热更新的模块对象 配置启动页面的插件 new htmlWebpackPlugin(&#123; 创建一个在内存中生成html页面的插件 template: path.join(__dirname, &apos;./src/index.html&apos;) //指定模板页面,将来会根据指定的页面路径,去生成内存中的页面 filename: &apos;index.html&apos; //指定生成的页面的名称 &#125;) ] &#125;3.运行: npm run dev4.生成内存中的index.html文件,当我们使用html-webpack-plugin之后，我们不再需要手动处理bundle.js的路径,因为这个插件帮我们自动创建了一个合适的script,并且引用了正确的了路径5.html-webpack-plugin插件作用 自动在内存中根据指定页面生成一个内存中的页面 自动打包好bundle.jd追加到页面中去 2.8 loader-配置处理css样式表的第三方loader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521.如果在index.html文件中直接引入样式文件，会发起二次请求,不建议使用&lt;link rel=&apos;stylesheet&apos; href=&apos;./css/index.css&apos;&gt;2.使用import &apos;./src/index.css&apos;运行会出现错误,需要一个合适的loader来处理这种类型的文件 you can need an appropriate loader to handle this file type. li &#123; list-style: none; &#125;3.注意: webpack默认只能打包处理js类型的文件,无法处理其他非js类型的文件,如果非要处理非js类型的文件,我们需要手动安装一些合适的第三方loader加载器4.处理样式loader4.1安装 如果想要打包处理css文件,需要安装npm i style-loader css-loader -D4.2配置 webpack.config.js 在里面新增一个配置节点 module 是一个对象,在这个module对象身上,有一个rules属性,这个rules属性是个数组,这个数组中，存放了所有第三方文件的匹配和处理规则const path = require(&apos;path); 启用热更新的第二步 const webpack = require(&apos;webpack&apos;); 引入配置启动页面的插件 只要是插件,都一定要放到 plugins 节点中去 const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) module.exports = &#123; //指定入口和出口 //entry: 入口,表示要使用webpack打包哪个文件 entry: path.join(__dirname, &apos;./src/main.js&apos;), //出口 输出文件的相关配置 output: &#123; //指定打包好的文件输出到哪个文件中 path: path.join(__dirname, &apos;./dist&apos;), filename: &apos;bundle.js&apos; //指定输出的文件名称 &#125;, 配置dev-server命令参数第二种方式 devServer: &#123; open: true, //自动打开浏览器 port: 3000, //设置启动时候的运行端口,默认是8080 contentBase: &apos;src&apos;, //指定托管的根目录 hot: true //启用热更新 启用热更新的第一步 &#125;, 启用热更新的第三步 plugins: [ 配置插件节点 new webpack.HotModuleReplacementPlugin(), //new一个热更新的模块对象 配置启动页面的插件 new htmlWebpackPlugin(&#123; 创建一个在内存中生成html页面的插件 template: path.join(__dirname, &apos;./src/index.html&apos;) //指定模板页面,将来会根据指定的页面路径,去生成内存中的页面 filename: &apos;index.html&apos; //指定生成的页面的名称 &#125;) ], module: &#123; //这个节点配置所有的第三方模块的加载器 rules: [ 所有第三方模块的匹配规则 &#123;test: /\.css$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;&#125;&#125; //匹配所有以css结尾的文件,用后面的加载器来处理,先调用后面的loader，将处理的结果交给前面的loader处理 ] &#125; &#125;5.运行 npm run dev 2.9 webpack处理第三方文件类型loader的过程12341.发现这个要处理的文件不是js文件,然后就去配置文件中,查找有没有对应的第三方loader规则2.如果能找到对应的规则,就会调用对应的loader处理这种文件类型3.在调用loader的时候，是从后往前调用的4.当最后loader调用完毕后，会把处理的结果直接交给webpack进行合并,最终输出到bundle.js文件中去 2.10 配置处理less文件的loader1234567891011121314import &apos;./css/index.less&apos;报错:没有处理这种类型文件的loader1.安装 安装loader加载器 npm i less-loader -D 安装依赖项 npm i less -D 不需要显示引入,是less-loader加载器内部依赖的2.在配置文件 webpack.config.js文件中配置module: &#123; //这个节点配置所有的第三方模块的加载器 rules: [ 所有第三方模块的匹配规则 &#123;test: /\.css$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;&#125;&#125;, //匹配所有以css结尾的文件,用后面的加载器来处理,先调用后面的loader，将处理的结果交给前面的loader处理 &#123;test: /\.less$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;&#125;&#125; //配置处理.less文件的第三方loader规则 ]&#125; 2.11 配置处理scss文件的loader123456789101112131415import &apos;./css/index.scss&apos;报错:没有处理这种类型文件的loader1.安装 安装loader加载器 npm i sass-loader -D 安装依赖项 一般安装node-sass是下载不下来,需要使用cnpm来安装 cnpm i node-sass -D 不需要显示引入,是less-loader加载器内部依赖的2.在配置文件 webpack.config.js文件中配置module: &#123; //这个节点配置所有的第三方模块的加载器 rules: [ 所有第三方模块的匹配规则 &#123;test: /\.css$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;&#125;&#125;, //匹配所有以css结尾的文件,用后面的加载器来处理,先调用后面的loader，将处理的结果交给前面的loader处理 &#123;test: /\.less$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;&#125;&#125;, //配置处理.less文件的第三方loader规则 &#123;test: /\.scss$/,use:&#123;&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;&#125;&#125; //配置处理.scss文件的第三方loader规则 ]&#125; 2.12 复习webpack基本配置12345678910111213141516171819202122232425262728293031323334353637381. webpack ./src/main.js ./dist/bundle.js2.由于每次都需要配置 打包哪个文件 打包到哪个文件，所以配置webpack.config.js文件,配置入口和出口，输入webpack命令即可打包3.由于每次修改完之后，必须输入webpack命令才能打包,所以安装webpack-dev-server实时监测文件的变化,进行打包 实时打包 安装: npm i webpack-dev-server -D 安装webpack-dev-server提示需要安装 npm i webpack 配置: package.json 中配置 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot; &#125; 配置webpack.config.js 配置入口和出口 运行: npm run dev 报错: bundle.js文件报错 如果不想手动引入bundle.js,需要在内存中自动生成一个index.html文件来自动引入bundle.js4.安装 html-webpack-plugin 在内存中根据指定的模板页面，生成一份内存中的首页,同时自动把打包好的bundle.js文件注入到首页底部 安装: npm i html-webpack-plugin -D 在webpack.config.js文件中引入插件,并在plugins中配置插件 引入插件 var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); 配置插件 plugins: [ new htmlWebpackPlugin(&#123; template: path.join(__dirname,&apos;./src/index.html&apos;), 指定模板文件路径 filename: &apos;index.html&apos; 设置生成的内存页面的名称 &#125;) ]5.配置css样式文件、less文件、scss文件如果直接在main.js文件中直接引入样式文件,需要 import &apos;./src/index.css&apos;,运行命令npm run dev时,不能处理这种类型的文件，需要安装合适的加载器 安装对应的loader加载器 npm i style-loader css-loader 在webpack.config.js文件中配置 module: &#123; 配置所有第三方模块的规则 rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125;, 处理css文件的loader npm i less-loader less -D 依赖于less &#123;test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;, 处理css文件的loader npm i sass-loader node-sass -D 依赖于sass &#123;test: /\.scss$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;, 处理css文件的loader ] &#125; 2.13 webpack中url-loader的使用12345678910111213141516171819202122232425index.less html,body &#123; width: 200px; height: 200px; background: url(&apos;../images/11.png&apos;); background-size: cover; &#125;运行命令: npm run dev,控制台报错,不能处理这种类型的文件,默认情况下,webpack无法处理css文件中的url地址,不管是图片还是字体库,只要是url地址，都无法处理解决方法: 安装: npm i url-loader file-loader -D url-loader内部依赖于file-loader 配置: webpack.config.js module: &#123; 配置所有第三方模块的规则 rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125;, 处理css文件的loader npm i less-loader less -D 依赖于less &#123;test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;, 处理css文件的loader npm i sass-loader node-sass -D 依赖于sass &#123;test: /\.scss$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;, 处理css文件的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader&apos;&#125;, 处理图片路径的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&apos;&#125;, 处理图片路径的loader,当图片的字节数大于限制的大小时，不会编码 limit给定的值,是图片的大小,单位是byte,如果我们引用的图片大于或者等于给定的limit值,则不会被转为base64格式的字符串,如果图片小于给定的limit值,则会被转为base64的字符串 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[hash:8]-[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突,对于命名冲突的文件,使用[hash:8]-来解决,哈希截取8位 ] &#125; 2.14 webpack中使用url-loader处理字体文件123456789101112131415161718import &apos;Bootstrap/bootstrap.css&apos; 安装: npm i url-loader file-loader -D url-loader内部依赖于file-loader 配置: webpack.config.js module: &#123; 配置所有第三方模块的规则 rules: [ &#123;test: /\.css$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;]&#125;, 处理css文件的loader npm i less-loader less -D 依赖于less &#123;test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;, 处理css文件的loader npm i sass-loader node-sass -D 依赖于sass &#123;test: /\.scss$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;, 处理css文件的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader&apos;&#125;, 处理图片路径的loader &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&apos;&#125;, 处理图片路径的loader,当图片的字节数大于限制的大小时，不会编码 limit给定的值,是图片的大小,单位是byte,如果我们引用的图片大于或者等于给定的limit值,则不会被转为base64格式的字符串,如果图片小于给定的limit值,则会被转为base64的字符串 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突 &#123;test: /\.(jpg|gif|bmp|png|jpeg)$/, use: &apos;url-loader?limit=4562&amp;name=[hash:8]-[name].[ext]&apos;&#125;, name参数设置的是打包之后不改变图片的名称及后缀,改变名称的原因是防止图片命名冲突,对于命名冲突的文件,使用[hash:8]-来解决,哈希截取8位 &#123;test: /\.(ttf|eot|svg|woff|woff2)$/, use: &apos;url-loader&apos;&#125;, ] &#125; 2.15 webpack中babel的配置12345678910class是ES6中提供的新语法,用来实现ES6中面向对象编程的方式class Person &#123; 使用static关键字，可以定义静态属性 所谓静态属性就是可以直接通过类名,直接访问的属性 实例属性:只能通过类的实例来访问的属性 static info = &#123;name: &apos;zs&apos;,age: 20&#125;&#125;console.log(Person.info);1.在控制台运行以上代码时会报错,在webpack中,默认只能处理一部分ES6的新语法,一些跟高级的ES6语法或者ES7语法,webpack是处理不了的,这时候，就需要借助于第三方的loader来帮助webpack处理一些高级的语法,当第三方loader把高级语法转化为低级的语法之后,会把结果交给webpack去打包到bundle.js中2.通过Babel,可以帮我们把高级语法转换为低级语法 Babel配置12345678910111213141.在webpack中,可以运行如下两套命令，安装包,去安装Babel相关的loader功能 两套全部安装 第一套包: cnpm i babel-core babel-loader babel-plugin-transform-runtime -D 第二套包: cnpm i babel-preset-env babel-preset-stage-0 -D2.配置 在webpack.config.js文件中,在module节点下的rules数组中,添加一个新的匹配规则 2.1 &#123;test: /\.js$/, use: &apos;babel-loader&apos;, exclude: /node_modules/&#125; 排除node_modules中的文件 2.2 注意: 在配置babel的loader规则的时候,必须把node_modules目录,通过exclude选项排除掉 2.2.1如果不排除node_modules,则Babel会把node_modules中所有的第三方js文件都打包编译,这样会非常消耗CPU,同时，打包速度非常慢 2.2.2 如果把node_modules中的js转换完毕了,但是项目也无法正常运行3.在项目的根目录中，新建一个.babelrc 的Babel的配置文件,这个配置文件属于JSON格式,必须符合JSON规范4.在.babelrc下写如下的配置&#123; &quot;presets&quot;: [&quot;env&quot;,&quot;stage-0&quot;], 预设 语法 &quot;plugins&quot;: [&quot;transform-runtime&quot;] 插件&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue知识总结]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fvue%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[vue知识12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526612、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）钩子函数参数：el、binding14、vue-router是什么？它有哪些组件？答：vue用来写路由一个插件。router-link、router-view15、导航钩子有哪些？它们有哪些参数？答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种16、Vue的双向数据绑定原理是什么？答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体步骤：第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。17、请详细说下你对vue生命周期的理解？答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。更新前/后：当data变化时，会触发beforeUpdate和updated方法。销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在18、请说下封装 vue 组件的过程？使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。19、你是怎么认识vuex的？答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。20、vue-loader是什么？使用它的用途有哪些？答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。用途：js可以写es6、style样式可以scss或less、template可以加jade等21、请说出vue.cli项目中src目录每个文件夹和文件的用法？答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件22、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？ 答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default &#123; 第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’ 第三步：注入到vue的子组件的components属性上面,components:&#123;smithButton&#125; 第四步：在template视图view中使用，&lt;smith-button&gt; &lt;/smith-button&gt; 问题有：smithButton命名，使用的时候则smith-button。23、聊聊你对Vue.js的template编译的理解？答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）详情步骤：首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）24、vue的组件是怎么定义的？父组件怎么给子组件传值？答：首先注册vue.components，第一个参数是组件名称，第二个参数是选项。直接绑定一个属性，然后在子组件props里面接收25、使用过element.ui吗？说下它其中两个组件的使用方法？ 答：使用过用过一个布局的，它是由24份，它的写法是:span后面带的数字它占24份里面的宽度。:offset是它 的间距，后面也是跟数字，也是从24份里面取的。 input按钮，标签是el-input，后面type跟上一个属性就是显示不同按钮的类型，有默认的default （默认的）、success（成功的）、warning（警告）、danger（危险）、info（）、primary（）26、说下你对mvvm的理解？双向绑定的理解?答：MVVM分为Model、View、ViewModel三者。Model 代表数据模型，数据和业务逻辑都在Model层中定义；View 代表UI视图，负责数据的展示；ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。27.请说下具体使用vue的理解？ 答：1、使用vue不必担心布局更改和类名重复导致的js重写，因为它是靠数据驱动双向绑定，底层是通过Object.defineProperty() 定义的数据 set、get 函数原理实现。 2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高， 3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。 4、js的代码无形的规范，团队合作开发代码可阅读性更高。28.你觉得哪些项目适合vue框架？ 答：1、数据信息量比较多的，反之类似企业网站就无需此框架了。 2、手机web和app应用多端共用一套界面的项目，因为使用vue.cli+webpack后的前端目录，非常有利于项目的跨平台部署。30、PC端项目你会在哪些场景使用Vue框架？答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的dom操作js和html都会有列表的html布局，迭代很困难。再一个dom节点的大面积添加会影响性能。那么vue为什么解决这些问题呢？第一：只需用v-for在view层一个地方遍历数据即可，无需复制一段html代码在js和html两个地方。第二：vue通过Virtual Dom就是在js中模拟DOM对象树来优化DOM操作。vuex1、vuex有哪几种属性？ 答：有五种，分别是 State、 Getter、Mutation 、Action、 Module2、vuex的State特性是？ 答： 一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data 二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新 三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中3、vuex的Getter特性是？ 答： 一、getters 可以对State进行计算操作，它就是Store的计算属性 二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用 三、 如果一个状态只在一个组件内使用，是可以不用getters4、vuex的Mutation特性是？ 答： 一、Action 类似于 mutation，不同在于： 二、Action 提交的是 mutation，而不是直接变更状态。 三、Action 可以包含任意异步操作5、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？ 答： 一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。 二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。6、不用Vuex会带来什么问题？ 答： 一、可维护性会下降，你要想修改数据，你得维护三个地方 二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的 三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。1、什么是vue生命周期？ 答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。2、vue生命周期的作用是什么？ 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。3、vue生命周期总共有几个阶段？ 答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后4、第一次页面加载会触发哪几个钩子？ 答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子5、DOM 渲染在 哪个周期中就已经完成？ 答：DOM 渲染在 mounted 中就已经完成了。6、简单描述每个周期具体适合哪些场景？ 答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom axios1、axios的特点有哪些？ 答： 一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API 二、它可以拦截请求和响应 三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据 四、安全性更高，客户端支持防御 XSRF2、axios有哪些常用方法？ 答： 一、axios.get(url[, config]) //get请求用于列表和信息查询 二、axios.delete(url[, config]) //删除 三、axios.post(url[, data[, config]]) //post请求用于信息的添加 四、axios.put(url[, data[, config]]) //更新操作3、说下你了解的axios相关配置属性？ 答： `url`是用于请求的服务器URL `method`是创建请求时使用的方法,默认是get `baseURL`将自动加在`url`前面，除非`url`是一个绝对URL。它可以通过设置一个`baseURL`便于为axios实例的方法传递相对URL `transformRequest`允许在向服务器发送前，修改请求数据，只能用在&apos;PUT&apos;,&apos;POST&apos;和&apos;PATCH&apos;这几个请求方法 `headers`是即将被发送的自定义请求头 headers:&#123;&apos;X-Requested-With&apos;:&apos;XMLHttpRequest&apos;&#125;, `params`是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象 params:&#123; ID:12345 &#125;, `auth`表示应该使用HTTP基础验证，并提供凭据 这将设置一个`Authorization`头，覆写掉现有的任意使用`headers`设置的自定义`Authorization`头 auth:&#123; username:&apos;janedoe&apos;, password:&apos;s00pers3cret&apos; &#125;, &apos;proxy&apos;定义代理服务器的主机名称和端口 `auth`表示HTTP基础验证应当用于连接代理，并提供凭据 这将会设置一个`Proxy-Authorization`头，覆写掉已有的通过使用`header`设置的自定义`Proxy-Authorization`头。 proxy:&#123; host:&apos;127.0.0.1&apos;, port:9000, auth::&#123; username:&apos;mikeymike&apos;, password:&apos;rapunz3l&apos; &#125; &#125;,keep-alivevue性能polyfill imort引入并执行 应用场景：页面开始一片空白1、vue响应式原理？ 当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。2、vue-router实现原理？3、为什么要选vue？与其它框架对比的优势和劣势？4、vue如何实现父子组件通信，以及非父子组件通信？5、vuejs与angularjs以及react的区别？6、vuex是用来做什么的？7、vue源码结构8、Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？示例：&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;addObjB&quot;&gt;添加obj.b&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; obj: &#123; a: &apos;obj.a&apos; &#125; &#125; &#125;, methods: &#123; addObjB () &#123; this.obj.b = &apos;obj.b&apos; console.log(this.obj) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;点击button会发现，obj.b 已经成功添加，但是视图并未刷新：原因在于在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api $set()： addObjB () &#123; // this.obj.b = &apos;obj.b&apos; this.$set(this.obj, &apos;b&apos;, &apos;obj.b&apos;) console.log(this.obj) &#125; $set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。9、delete和Vue.delete删除数组的区别delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。Vue.delete直接删除了数组 改变了数组的键值。var a=[1,2,3,4] var b=[1,2,3,4] delete a[1] console.log(a) 只是value值变为undefined this.$delete(b,1) console.log(b) 索引为1的这一项不存在，变成其他的了10、如何优化SPA应用的首屏加载速度慢的问题？将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；加一个首屏 loading 图，提升用户体验；11、前端如何优化网站性能？减少 HTTP 请求数量在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。CSS Sprites：国内俗称 CSS 精灵，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数。合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。采用 lazyLoad：俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。控制资源文件加载优先级浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。一般情况下都是 CSS 在头部，JS 在底部。利用浏览器缓存浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。减少重排（Reflow）基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。减少 DOM 操作图标使用 IconFont 替换12、网页从输入网址到渲染完成经历了哪些过程？大致可以分为如下7步：输入网址；发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；与web服务器建立TCP连接；浏览器向web服务器发送http请求；web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；浏览器下载web服务器返回的数据及解析html源文件；生成DOM树，解析css和js，渲染页面，直至显示完成；13、js 延迟加载的方式有哪些？方案一：&lt;script&gt;标签的 async=&quot;async&quot;属性（详细参见：script 标签的 async 属性） 方案二：&lt;script&gt;标签的 defer=&quot;defer&quot;属性方案三：动态创建&lt;script&gt;标签方案四：AJAX eval（使用 AJAX 得到脚本内容，然后通过 eval_r(xmlhttp.responseText) 来运行脚本）方案五：iframe 方式14、]]></content>
  </entry>
  <entry>
    <title><![CDATA[内置对象]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Math的常用方法1234567891011121314151617181920212223//绝对值Math.abs(num)//向上取整Math.ceil(num)//向下取整Math.floor(num)//返回多个数字的最大值Math.max(num)//返回多个数字的最小值Math.min(num)//返回一个0-1的随机数Math.random()//四舍五入Math.round(num)//返回一个数的整数部分Math.trunc(num) Date的常用方法1234567891011121314151617181920//创建当前时间 var dt = new Date()//获取年 var year = dt.getFullYear()//获取月 var month = dt.getMonth()+1//获取日 var day = dt.getDate()//获取时 var h = dt.getHours()//获取分 var m = dt.getMinutes()//获取秒 var s = dt.getSeconds() Array的常用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//返回数组的长度arr.length//返回一个截取的数组arr.slice(2,4)//对数组进行排序arr.sort()// 数组反转arr.reverse()//判断数组类型Array.isArray(arr)//等效于arr instanceof Array//判断数组中是否包含这个值arr.includes(5)//如果存在,则返回第一个元素的下标,否则返回-1arr.indexOf(5)//如果存在,则返回最后一个元素的下标,否则返回-1lastIndexOf(5)//数组遍历//循环遍历arr.forEach( x =&gt; console.log(x) )//对数组进行遍历测试,通过返回true,否则falsearr.every( x =&gt; x&gt;0 )//对数组进行遍历测试,通过返回false,否则truearr.some( x =&gt; x&gt;0 )//过滤数组,通过则返回当前元素arr.filter( x =&gt; x&gt;5 )//找到数组中满足条件,的第一个元素的值arr.find( x =&gt; x&gt;5 )//满足条件,则返回第一个元素的下标,否则返回0arr.findIndex( x =&gt; x&gt;5 )//对每一个元素调用函数并返回新数组arr.map( x =&gt; x+1 )//对所有元素求和arr.reduce( (x,y) =&gt; x+y )//也可以拼接字符串arr.reduce( (x,y) =&gt; x+&quot;,&quot;+y )数组操作//删除数组中最后一个元素,并返回该元素arr.pop()//删除数组中第一个元素,并返回该元素arr.shift()//将指定元素添加到数组的开头arr.unshift()//将元素追加到数组的最后arr.push()// 从索引为2的位置删除一项arr.splice(2, 1)// 在索引为2的位置插入10arr.splice(2, 0, 10)// 从索引为2的位置删除一项再插入10arr.splice(2, 1, 10)//把若干参数合并为数组Array.of(1,2,3)//合并两个数组并返回arr1.concat(arr2)//把字符串拆分成伪数组Array.from(&quot;string&quot;)//让数组以指定字符拼接arr.join(&quot;-&quot;)//把数组转换成字符串arr.toString()//可以转换时间,数字,字符串arr.toLocaleString() String1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 获取字符串的长度&apos;hello&apos;.length// 获取指定索引的字符&apos;hello&apos;.charAt(3)// 获取指定字符首次出现的索引&apos;hello&apos;.indexOf(&apos;l&apos;)// 获取指定字符最后出现的索引&apos;hello&apos;.lastIndexOf(&apos;l&apos;)// 查找指定字符出现的位置&apos;hello&apos;.search(&apos;l&apos;)// 对指定字符串进行替换&apos;hello&apos;.replace(&apos;l&apos;, &apos;o&apos;)// 把字符串分割成数组&apos;hello word&apos;.split(&apos; &apos;)// 大写转换小写&apos;HELLO&apos;.toLowerCase()// 小写转换大写&apos;hello&apos;.toUpperCase()// 大写转换小写(根据地区)&apos;HELLO&apos;.toLocaleLowerCase()// 小写转换大写(根据地区)&apos;hello&apos;.toLocaleUpperCase()// 把指定索引的字母转换成编码&apos;hello&apos;.codePointAt(0)// 把编码转换成字母String.fromCodePoint(65)// 截取指定索引字符串&apos;hello&apos;.slice(0, -3)// 截取指定长度的字符串&apos;hello&apos;.substr(1, 3)// 截取指定索引字符串&apos;hello&apos;.substring(1, 3)// 拼接字符串&apos;hello&apos;.concat(&apos;wo&apos;, &apos;rd&apos;)// 以指定长度在后面进行重复填充&apos;hello&apos;.padEnd(10, &apos;-&apos;)// 以指定长度在前面进行重复填充&apos;hello&apos;.padStart(10, &apos;-&apos;)// 将字符串重复整数次&apos;hello&apos;.repeat(2) // 判断是否包含指定字符&apos;hello&apos;.includes(&apos;ll&apos;)// 判断是否已指定字符开头&apos;hello&apos;.startsWith(&apos;he&apos;)// 判断是否以指定字符结尾&apos;hello&apos;.endsWith(&apos;lo&apos;)// 去除两边空格&apos;hello&apos;.trim()// 去除左边空格&apos;hello&apos;.trimLeft()// 去除右边空格&apos;hello&apos;.trimRight()]]></content>
  </entry>
  <entry>
    <title><![CDATA[H5C3]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2FH5C3%2F</url>
    <content type="text"><![CDATA[H5C3 API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861.存储数据1.1 sessionStorage 特点: 1.存储数据到本地，存储的容量5MB左右 2.这个数据本质是存储在当前页面的内存中 3.关闭页面数据会自动清除 window.sessionStorage.setItem(key,value); setItem(key,value);存储数据，以键值对的方式存储 getItem(key);获取数据，通过指定名称的key获取对应的value值 removeItem(key);删除数据,通过指定名称key删除对应的值 clear();清空所有存储的内容 如果没有存储就获取sessionStorage,那么获取的是null. 如果在删除数据的时候，key值错误,不会报错，但是也不会删除数据1.2 localStorage 特点: 1.存储的内容大概20MB 2.不同浏览器不能共享数据,但是在同一个浏览器的不同窗口中可以共享数据 3.永久生效，它的数据是存储在硬盘上，并不会随着页面或者浏览器的关闭而清除1.3 网络状态 // 通过window.navigator.onLine可以返回当前的网络状态 alert(window.navigator.onLine); window.addEventListener(&apos;online&apos;, function () &#123; //alert(&apos;online&apos;); $(&apos;.tips&apos;).text(&apos;网络已连接&apos;).fadeIn(500).delay(1000).fadeOut(); &#125;); window.addEventListener(&apos;offline&apos;, function () &#123; //alert(&apos;offline&apos;); $(&apos;.tips&apos;).text(&apos;网络已断开&apos;).fadeIn(500).delay(1000).fadeOut(); &#125;);1.4 文件读取 &lt;input type=&quot;file&quot; class=&quot;file&quot; multiple&gt; &lt;script&gt; /*获取到了文件表单元素*/ var file = document.querySelector(&apos;.file&apos;); /*选择文件后触发*/ file.onchange = function () &#123; /*初始化了一个文件读取对象*/ var reader = new FileReader(); /*读取文件数据 this.files[0] 文件表单元素选择的第一个文件 */ reader.readAsDataURL(this.files[0]); /*读取的过程就相当于 加载过程 */ /*读取完毕 预览 */ reader.onload = function () &#123; /*读取完毕 base64位数据 表示图片*/ console.log(this.result); document.querySelector(&apos;#img&apos;).src = this.result; &#125; &#125; &lt;/script&gt;1.5 拖拽 // 整个拖拽都会执行 box.addEventListener(&apos;drag&apos;, function (e) &#123; console.log(&apos;drag&apos;); &#125;); // 拖拽的点离开当前盒子 box.addEventListener(&apos;dragleave&apos;, function () &#123; console.log(&apos;dragleave&apos;); &#125;); // 拖拽开始 box.addEventListener(&apos;dragstart&apos;, function () &#123; this.style.backgroundColor = &apos;red&apos;; console.log(&apos;dragstart&apos;) &#125;); // 拖拽结束 box.addEventListener(&apos;dragend&apos;, function (ev) &#123; this.style.backgroundColor = &apos;&apos;; console.log(&apos;dragend&apos;); &#125;); //在目标元素上移动 container.addEventListener(&apos;dragover&apos;, function (e) &#123; this.style.backgroundColor = &apos;yellow&apos;; console.log(&apos;目标dragover&apos;); e.preventDefault(); &#125;); //在目标元素离开 container.addEventListener(&apos;dragleave&apos;, function (e) &#123; this.style.backgroundColor = &apos;&apos;; console.log(&apos;目标dragleave&apos;); e.preventDefault(); &#125;); //在目标元素松开 container.addEventListener(&apos;drop&apos;, function (e) &#123; this.style.backgroundColor = &apos;black&apos;; console.log(&apos;目标drop&apos;); e.preventDefault(); &#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[双飞翼布局]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[双飞翼布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .container &#123; height: 300px; &#125; .column &#123; float: left; height: 300px; &#125; .left &#123; width: 200px; background-color: pink; margin-left: -100%; &#125; .right &#123; width: 250px; background-color: purple; margin-left: -250px; &#125; .main &#123; width: 100%; background-color: orange; &#125; .inner &#123; margin: 0 250px 0 200px; word-break: break-all; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column main&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;!--双飞翼布局 内部添加了一个盒子--&gt; what&apos;s your name ? &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[###圣杯布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; min-width: 700px; &#125; .container &#123; height: 300px; padding: 0 250px 0 200px; &#125; .column &#123; float: left; height: 300px; &#125; .left &#123; width: 200px; background-color: pink; margin-left : -100%; position: relative; left: -200px; &#125; .right &#123; width: 250px; background-color: purple; margin-left: -250px; position: relative; right: -250px; &#125; .main &#123; width: 100%; background-color: orange; word-break: break-all; /*自动换行*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column main&quot;&gt; my name is andy &lt;/div&gt; &lt;div class=&quot;column left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuex状态管理流程]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fvuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vuex-状态管理流程1234组件中的数据:写在state中state:组件的数据声明 数据(组件之间需要共享/传值)声明Actions:发请求 和后台交互 异步操作 和后台交互的异步操作 =ajaxMutations:改数据 改变state的方法 1.1 vuex-state和mapState123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761.新建项目 vue init webpack-simple democd xx npm i npm run dev2.下载插件 npm i vuex3.导入main.jsimport Vuex from &apos;vuex&apos;配置Vue.use(Vuex);实例化 store仓库、存储const store = new Vuex.Store(&#123; state:&#123; num: 0; 可以在项目的任意一个组件中去使用 &#125;&#125;);4.挂载new Vue(&#123; el:&apos;&apos;, store: store, ......&#125;);5.App.vue&lt;template&gt; &lt;div&gt; 1.使用仓库中的数据 vuex中的store中的state中的数据num &#123;&#123;$store.state.num&#125;&#125; 2.把状态中的数据变成组件中的计算属性 &#123;&#123;abc&#125;&#125; 3.辅助函数mapState &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export defalut &#123; data()&#123; return&#123; msg: &apos;abc&apos; &#125; &#125;, 2.计算属性 computed: &#123; 计算属性名字：带有返回值的函数 abc()&#123; return this.$store.state.num; &#125; &#125; 3.辅助函数 mapState 1)导入 import &#123;mapState&#125; from &quot;vuex&quot;; 2)computed: mapState([]/&#123;&#125;); mapState()里面的参数可以是对象可以是数组 3.1.传对象 computed: mapState(&#123; 1. 计算属性的名字:仓库中的数据 带有返回值的函数 mapState的计算属性，内置一个参数,state count(state)&#123; return state.num; &#125; 2.简化 count: state =&gt;&#123; return state.num; &#125; 3. 简化 count: &quot;num&quot; &#125;) 3.2.传数组 computed: mapState([&quot;count&quot;]) 4.辅助函数 computed: &#123; ...mapState(&#123; num: &quot;num&quot; &#125;); mapState()方法有返回值,会返回一个对象，如果想使用对象里面的数据，需要通过解构赋值来使用 &#123;count: &quot;count&quot;&#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456789data和state中的数据都是响应式数据 数据声明state作用：写数据的声明state中的数据是响应式的state中的数据可以在任意组件使用配合计算属性和mapState一起使用computed: &#123; ...mapState(&#123;count: &quot;count&quot;&#125;); 对象 ...mapState([&quot;msg&quot;]); 数组&#125; 1.2 vuex-getters和mapGetters1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253当状态state中的数据比较复杂时,这个复杂数据写在状态中可以，但是不合理，此时，需要把状态中的复杂数据改写到getters中。main.jsimport Vuex from &apos;vuex&apos;Vue.use(Vuex);const store = new Vuex.Store(&#123; state:&#123; num: 0; msg: &apos;abc&apos; a是个复杂数据,依赖了其他state的数据,需要写在getters中，类似于计算属性 &#125;, getters: &#123; a是一个函数，而且带有返回值 a(state)&#123; return state.msg + &quot;xyz&quot;; &#125; &#125;&#125;);new Vue(&#123; el:&apos;&apos;, store: store, ......&#125;);App.vue1.通过插值表达式渲染&#123;&#123;$store.getters.a&#125;&#125;2.&#123;&#123;A&#125;&#125;import &#123;mapState,mapGetters&#125; form &quot;vuex&quot;export default &#123; 2.计算属性的用法 computed: &#123; A()&#123; return this.$store.getters.a; &#125; &#125; 3.getters辅助函数 computed: mapGetters(&#123; 3.1 A: &quot;a&quot; 3.2 3.3 不可行 3.2 A(getters)&#123; return getters.a; &#125; 3.3 A: (getters) =&gt; &#123; return getters.a; &#125; &#125;); 4. 传数组 computed: mapGetters([&quot;a&quot;]); 5.computed: &#123; ...mapGetters(&#123; a: &quot;a&quot; &#125;); &#125;&#125; 1234567891011getter中数据的用法和状态中数据的用法完全一样getters使用场景： 如果state中的数据很复杂,依赖了state中其他数据，此时需要把复杂数据写在getters中getters: &#123; A(state)&#123; return state.数据 + &apos;sfsaf&apos; return state.msg +&apos;sdsfsf&apos;; &#125;&#125;在组件中使用computed: mapGetters([&apos;A&apos;]); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 计算属性 // 第二种使用state状态中数据的方法 // computed: &#123; // num()&#123; // return this.$store.state.num; // &#125; // &#125;, // // 第三种使用计算属性的方法 辅助函数 // computed: mapState(&#123; // // 3.1 // // count(state)&#123; // // return state.num; // // &#125; // // 3.2 // // count: (state) =&gt; &#123; // // return state.num; // // &#125; // // 3.3 // // count: &quot;num&quot; // &#125;) // 第四种: 辅助函数中可以传入数组 // computed: mapState([ // &quot;num&quot; // ]) // 第五种 // computed: &#123; // ...mapState(&#123; // num: &apos;num&apos; // &#125;) // &#125; // getters使用 // 第一种使用方法 // computed: &#123; // count()&#123; // return this.$store.getters.count; // &#125; // &#125; // 第二种使用方法 // computed: mapGetters(&#123; // // count: &quot;count&quot; // &#125;) // 第三种方法 // computed: mapGetters([&quot;count&quot;]) // 第四种方法 // computed: &#123; // ...mapGetters(&#123; // count: &quot;count&quot; // &#125;) // &#125; 1.3 vue-mutations和mapMutations123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354mutations: 利用actions中返回的数据 修改state中的数据 写方法在vuex仓库中的mutations对象中定义函数在main.js文件中mutations: &#123; 因为是修改status中的数据，所以函数会自动传入参数status 方法一： fn(state)&#123; state.num ++; &#125; 方法二： count是形参 fn(state,count)&#123; state.num = state.num + count; &#125; 方法三： count 是一个对象 fn(state,count)&#123; state.num = state.num + count.age; &#125; 方法四： fn(state,count)&#123; state.num = state.num + count.age; &#125; 方法二、三、四： 调用方法时传实参,叫提交载荷 (payload)&#125;在组件中created()&#123; 方法一：通过仓库提交函数名 this.$store.commit(&apos;函数名&apos;); 方法二： commit参数可以传实参 this.$store.commit(&apos;函数名&apos;,100); 方法三： commit参数可以传实参 this.$store.commit(&apos;函数名&apos;,&#123; name: &apos;xxx&apos;, age: 20 &#125;); 方法四： fn1()&#123; this.$store.commit(&#123; type: &apos;fn&apos;, type:&apos;&apos; 函数名 age: 20 &#125;) &#125; 方法五： 导入 import &#123;mapState,mapGetters,mapMutations&#125; from &quot;vuex&quot;; ...mapMutations([&quot;fn&quot;]); 组件和vuex中的方法同名 这种方法如果要传参数，需要在组件中调用方法时传递参数 created()&#123; this.fn(&apos;mn); &#125; 相当于： fn()&#123; this.$store.commit(&apos;fn&apos;); &#125;&#125; main.js 12345678910111213141516171819202122232425262728293031323334import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;// 导入import vuex from &apos;vuex&apos;// 配置Vue.use(vuex);// 实例化 store 仓库const store = new vuex.Store(&#123; state: &#123; num: 100 &#125;, getters: &#123; count(state)&#123; return state.num + &apos;xyz&apos; &#125; &#125;, 调用方法修改state中的数据 mutations: &#123; fn(state)&#123; state.num ++; &#125; &#125;&#125;);new Vue(&#123; el: &apos;#app&apos;, data()&#123; return &#123; msg: &apos;abx&apos; &#125; &#125;, // 挂载 store, render: h =&gt; h(App)&#125;) app.vue 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;num&#125;&#125; &lt;button @click=&apos;fn1&apos;&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 通过辅助函数来使用state状态中的数据import &#123;mapState,mapGetters&#125; from &apos;vuex&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, // mutations使用 created()&#123; this.$store.commit(&apos;fn&apos;); &#125;, computed:&#123; ...mapState([&apos;num&apos;]) &#125;, methods:&#123; fn1()&#123; // 调用mutations中的方法,提交要执行的函数名字 this.$store.commit(&apos;fn&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 1.4 vuex-actions和maoActions12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061复习：main.jsimport Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;// 导入import vuex from &apos;vuex&apos;// 配置Vue.use(vuex);// 实例化 store 仓库const store = new vuex.Store(&#123; state: &#123; num: 100 &#125;, mutations: &#123; fn(state,payload)&#123; state.num = payload; &#125; &#125;&#125;);new Vue(&#123; el: &apos;#app&apos;, data()&#123; return &#123; msg: &apos;abx&apos; &#125; &#125;, // 挂载 store, render: h =&gt; h(App)&#125;)app.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;num&#125;&#125; &lt;button @click=&apos;fn&apos;&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 通过辅助函数来使用state状态中的数据import &#123;mapState,mapGetters, mapMutations&#125; from &apos;vuex&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; &#125; &#125;, created()&#123; this.fn(&quot;mn&quot;); &#125;, computed:&#123; ...mapState([&apos;num&apos;]) &#125;, methods:&#123; ...mapMutations([&apos;fn&apos;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657actions: 作用： 写方法/方法内部应该写的代码 是 异步操作 定时器 /ajax在异步操作有结果的位置调用mutations中的方法main.jsconst store = new vuex.Store(&#123; state: &#123; num: 100 &#125;, mutations: &#123; fn1(state,payload)&#123; state.num = payload; &#125; &#125;, // 作用：写方法／方法内部应该写的是 异步操作的代码 定时器／ajax // 在异步操作有结果的位置 调用mutations中的方法 actions: &#123; fn(context)&#123; // fn方法自带 context参数对象 contex t是仓库对象 ＝＝＝ this.$store setInterval(()=&gt; &#123; const temp = 2; // 调用mutations中的方法，同时传递temp context.commit(&apos;fn1&apos;,temp); &#125;); &#125; &#125;&#125;);app.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;num&#125;&#125; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 通过辅助函数来使用state状态中的数据import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from &apos;vuex&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; &#125; &#125;, created()&#123; this.fn1(&quot;mnmnm&quot;); this.fn(); &#125;, computed:&#123; ...mapState([&apos;num&apos;]) &#125;, methods:&#123; ...mapMutations([&apos;fn1&apos;]), ...mapActions([&quot;fn&quot;]) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 12345678910mutations: 中的方法是真正该数据的方法actions： 中的方法是从后台获取数据/定时器的方法 在异步操作有结果的位置 提交mutations中的方法，并且传递数据调用actions中的方法 组件 created()&#123; this.fn();&#125;,methods&#123; ...mapActions([&quot;fn&quot;])&#125; 1.5 vuex 总结123mutations: 必须是同步函数 修改state的数据state： 数据的声明actions: 异步获取数据的方法 在异步操作有结果的位置调用 mutations的方法 context.commit(&apos;函数名&apos;) 1.6]]></content>
  </entry>
  <entry>
    <title><![CDATA[组件通信]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信1.1 父子组件通信-子传父1234567891011121.vuex=&gt;解决vue项目的状态管理问题=&gt;数据管理=&gt;组件数据通信=&gt;组件传值2.父传子 组件通信 在子组件中使用父组件传来的数据（props）1)在子组件props:[&apos;&apos;,&apos;&apos;] 字符串数组2)使用组件时 &lt;child-a :mag=&apos;父组件data中的值&apos;&gt; &lt;/child-a&gt;3)在子组件的template &#123;&#123;msg&#125;&#125;3.子传父子组件中自定义事件 : this.$emit(&apos;事件名&apos;,数据);自己组件中定义的自定义事件，可以在父组件中调用组件时，使用该事件this.$emit(&apos;xxx&apos;); xxx是事件名this.$emit(&apos;xxx&apos;,数据); 可以传两个参数 &lt;child-a @xxx=&apos;add()&apos;&gt;&lt;/child-a&gt; add()函数是写在父组件中的 父传子组件通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344parent.vue&lt;template&gt; &lt;div&gt; &lt;button @click=&apos;add()&apos;&gt;点我有惊喜哟&lt;/button&gt; &lt;child-a AAA=&apos;aaa&apos; BBB=&apos;bbb&apos;&gt;&lt;/child-a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import childA from &apos;./childA&apos;export default &#123; data()&#123; num: 100 &#125;, components:&#123; &apos;child-a&apos;: childA &#125;, methods: &#123; add()&#123; // this.$emit(&apos;事件名&apos;,数据); 定义自定义事件 this.$emit(&apos;xxx&apos;,this.num); console.log(&apos;子组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;child.vue&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;AAA&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;BBB&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;childA&apos;, props: [&apos;AAA&apos;,&apos;BBB&apos;]&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子传父组件通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253parent.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; 子组件中定义的自定义事件可以传数据 &lt;child @xxx=&apos;fn&apos;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;引入子组件import child from &apos;./child&apos;export default &#123; name: &apos;app&apos;, components: &#123; child &#125;, methods:&#123; fn(num)&#123; console.log(num); console.log(&apos;父组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;child.vue&lt;template&gt; &lt;div&gt; &lt;button @click=&apos;add()&apos;&gt;点我有惊喜哟&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import childA from &apos;./childA&apos;export default &#123; data()&#123; return&#123; num: 100 &#125; &#125;, methods: &#123; add()&#123; // this.$emit(&apos;事件名&apos;,数据); 定义自定义事件 this.$emit(&apos;xxx&apos;,this.num); console.log(&apos;子组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 1.2 兄弟组件通信1234567891011中央事件总线: 多个事件共享一个vmvue绑定事件:1)标签中绑定事件&lt;button @xxx=&apos;fn&apos;&gt;&lt;/button&gt;2)在methods:&#123; this.$on(&apos;事件名&apos;,fn); 绑定事件 第一个：事件名 第二个:函数 this.$on(&apos;xxx&apos;,()=&gt;&#123;&#125;); this.$emit(&apos;事件名&apos;,数据); 触发事件&#125;3)绑定和触发自定义事件必须是一个vm实例对象4)数据A传给数据B 组件A触发事件 组件B绑定事件 vm.vue 123import Vue from &apos;./vue&apos;;const vm = new Vue(&#123;&#125;);export default vm; childA.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;button @click=&apos;add()&apos;&gt;点我有惊喜哟&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import vm from &apos;./vm.js&apos;export default &#123; data()&#123; return&#123; num: 100 &#125; &#125;, methods: &#123; add()&#123; 触发 传数据 vm.$emit(&apos;com&apos;,this.num); console.log(&apos;sadfffafs&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; childB.vue 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import vm from &apos;./vm.js&apos;export default &#123; created()&#123; 绑定事件 vm.$on(&apos;com&apos;,(num) =&gt; &#123; console.log(num); console.log(&apos;数据传过来了&apos;); &#125;); &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; app.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;child @xxx=&apos;fn&apos;&gt;&lt;/child&gt; &lt;childA&gt;&lt;/childA&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./child&apos;import childA from &apos;./childA&apos;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125;, components: &#123; child, childA &#125;, methods:&#123; fn(num)&#123; console.log(num); console.log(&apos;父组件&apos;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273## Git常用命令 &gt; 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。 ~~~ $ git config --list // 查看配置信息 $ git config [--global] user.name &quot;&quot; // 配置用户名 $ git config [--global] user.email &quot;&quot; // 配置邮箱 $ git init [project-name] // 在工作目录中初始化新仓库 $ git init --bare [project-name] // 在工作目录中初始化新仓库 只记录版本没有工作区 $ git clone [url] [project-name] // 从现有仓库克隆 $ git fetch [remote-name] [branch-name] // 从远程仓库抓取数据 // 注意：fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支 $ git fetch --all // 获取所有 $ git log FETCH_HEAD // 查看获取的最新远程HEAD $ git pull [remote-name] [branch-name] // 从远端仓库中抓取数据后，合并到工作目录中的当前分支 git fetch 和 git merge // 注意：由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。 $ git push [remote-name] [branch-name] // 推送数据到远程仓库 $ git push origin --delete serverfix // 删除远程分支 // 远程分支以 (remote)/(branch) 形式命名 $ git remote [-v] // 查看当前的远程库 $ git remote add [shortname] [url] // 添加远程仓库 $ git remote show [remote-name] // 查看远程仓库信息 $ git ls-remote [remote-name] // 显式获得远程引用的完整列表 $ git checkout -b serverfix origin/serverfix // 创建分支并跟踪远程 $ git checkout --track origin/serverfix // 创建和远程一样的分支并跟踪 $ git branch -u origin/serverfix // 设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支 $ git branch -vv // 所有跟踪分支 $ git add [. *.*] // 跟踪新文件，已跟踪的文件放到暂存区，把有冲突的文件标记为已解决状态等 $ git status // 检查当前文件状态 $ git commit [-m &apos;&apos;] // 提交更新 $ git commit -a -m &apos;&apos; // 跳过使用暂存区域 提交更新 $ git diff // 比较工作目录中当前文件和暂存区域快照之间的差异 $ git diff --cached // 已经暂存起来的文件和上次提交时的快照之间的差异 $ git diff --staged // 已经暂存起来的文件和上次提交时的快照之间的差异 $ git rm // 移除已跟踪文件(暂存区域移除) 并从工作目录中删除指定的文件 $ git rm --cached // 移除已跟踪文件(暂存区域移除) 保留在当前工作目录 $ git mv // 移动文件 (相当于 mv file1 file2 , git rm file1 ,git add file2) $ git log // 查看提交历史 $ git log [-p] [-2] // -p显示每次提交的内容差异 -2仅显示最近的两次更新 $ git log --oneline --decorate --graph --all // 查看分叉历史 $ git commit --amend // 修改最后一次提交 $ git reset HEAD &lt;file&gt;... // 取消已经暂存的文件 $ git checkout -- &lt;file&gt;... // 取消对文件的修改 $ git branch [branch] // 创建分支 $ git checkout [branch] // 切换分支 $ git checkout -b [branch] // 创建并切换分支 $ git branch -d [branch] // 删除分支 $ git branch // 当前所有分支列表 $ git branch -v // 当前所有分支列表和最后一次提交 $ git branch --merged // 已经合并到当前分支的分支列表 $ git branch --no-merged // 尚未合并到当前分支的分支列表 // 在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 // merage 分为 快进合并 和 整合合并 $ git merge [branch] // 合并分支 $ git merge origin/master // 合并 $ git rebase origin/master // 变基 $ git rebase --abort // 来取消目前的rebase进程 $ git rebase --cqontinue // 继续目前的rebase进程 $ git rebase --onto master server client // m&gt;s&gt;c 从一个特性分支里再分出一个特性分支的提交历史 git reset --hard 版本号 //回滚版本 $ git diff // 不加参数即默认比较工作区与暂存区 $ git diff --cached [&lt;path&gt;...] // 较暂存区与最新本地版本库（本地库中最近一次commit的内容） $ git diff HEAD [&lt;path&gt;...] // 比较工作区与最新本地版本库 HEAD是master分支可以换成master $ git diff commit-id [&lt;path&gt;...] // 比较工作区与指定commit-id的差异 $ git diff --cached [&lt;commit-id&gt;] [&lt;path&gt;...] // 比较暂存区与指定commit-id的差异 $ git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;] // 比较两个commit-id之间的差异 $ $ git help &lt;verb&gt; //帮助命令 $ git &lt;verb&gt; --help //帮助命令 $ man git-&lt;verb&gt; //帮助命令 ~~~ ![1c5be00301acbe5334ce5eceb8f5088f.png](evernotecid://8329B9A2-63B9-46FA-BDF0-A91CD1917B8C/appyinxiangcom/11049585/ENResource/p13) ![1ce791a6bab444cc113010199b656a04.png](evernotecid://8329B9A2-63B9-46FA-BDF0-A91CD1917B8C/appyinxiangcom/11049585/ENResource/p14) &gt; 只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 git最常用指令123456789git clone 链接地址cd 目录名git add *git statusgit commit -m &quot;注释&quot;git push配置 git config --global user.email &quot;&quot; git config --global user.name &quot;&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324251.注册github 搭建github pages2.安装nodejs3.安装hexo hexo init 文件夹名 cd 文件夹 npm i 4.配置_config.yml # Site title: web前端总结 subtitle: 前端知识点 description: 面试及项目 keywords: author: Fang Ren language: timezone: 配置服务器 github: # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: github生成的github pages网址 5.新建页面 hexo new &quot;文件名&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue项目后台管理系统]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F13%2Fvue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1.项目介绍12完成用户管理、权限管理、商品管理、分类参数、订单管理、数据统计功能技术栈:vue+vue-cli+webpack+vue-router+axios+element-ui第三方主流UI库 2. 环境搭建1234561.运行sql文件2.启动服务器 把项目跑起来 后端使用的是node.js 安装node_modules npm i 在config文件夹中打开default.json文件中配置数据库连接信息 到后台根目录下启动服务器 node app.js3.接口文件 api-server-&gt;vue后台-&gt;docs/index.html 3. vue-cli创建项目结构12345678910111213141.vue init webpack shop2.回车 项目名字 描述 编译方式 for most users 安装vue-router y 使用ESLint检测你的代码 y 选择要使用的代码规范 standard:代码末尾不能有分号 set up unit tests? 是否设置单元测试 n Setup e2e tests no3.npm run dev 默认不会打开浏览器4.不会自动打开浏览器 1）在文件package.json中 配置 scripts: dev 后面添加--open 重新运行npm run dev打开浏览器 2）在config文件夹中的index.js文件中设置autoOpenBrowser:true即可 3.1 使用预处理器scss管理样式12345678910111213141516171819202122232425参考地址: https://vue-loader.vuejs.org/zh/guide/pre-processors.html#sass-vs-scss安装: npm install -D sass-loader node-sass 使用cnpm安装,否则会安装失败在webpack中配置： module.exports = &#123; module: &#123; rules: [ // ... 忽略其它规则 // 普通的 `.scss` 文件和 `*.vue` 文件中的 // `&lt;style lang=&quot;scss&quot;&gt;` 块都应用它 &#123; test: /\.scss$/, use: [ &apos;vue-style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos; ] &#125; ] &#125;, // 插件忽略 &#125;&lt;style lang=&apos;scss&apos;&gt;&lt;/style&gt; 4. element-ui4.1 文档分析4.2 安装-引入123456789101112131415161.安装 npm i element-ui -S2.如果需要与webpack配合使用，在main.js文件中引入 1)完整引入 import Vue from &apos;vue&apos;; import ElementUI from &apos;element-ui&apos;; import &apos;element-ui/lib/theme-chalk/index.css&apos;; import App from &apos;./App.vue&apos;; Vue.use(ElementUI); new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App) &#125;); 2)按需引入完整引入可以在任意组件的template中使用element-ui里面的组件 5. 项目模板简化-调整1删除模板中不用的图片、样式、js文件 6. git-版本控制123456789git init git statusgit add .git commit -m &quot;&quot;新建远程仓库关联仓库 git remote add origin 链接推送 git push -u origin mastergit branch 查看分支 git checkout -b 分支名 新建某个分支并且切换到该分支 7. 登录7.1 新建分支-login组件-配置路由index.js==&gt;router.js 12345678910111213141516171819202122import Vue from &apos;vue&apos;import vueRouter from &apos;vue-router&apos;Vue.use(vueRouter);import Login from &quot;../components/login.vue&quot;;在webpack模板中提供新功能 @自动锁定srcimport Login from &quot;@/components/login.vue&quot;;export default new Router(&#123; routes: [ &#123; name: &apos;home&apos;, path: &apos;/&apos;, redirect: &#123; name: &apos;login&apos; &#125; &#125;, &#123; name: &apos;login&apos;, path: &apos;/login&apos;, component: Login &#125; ]&#125;); login.vue 12345678910&lt;template&gt; &lt;div&gt;登录&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 7.2 引入表单组件12341.找组件2.引入标签3.提供该组件的属性值和数据/方法web前端助手-&gt;FEHelper 7.3 样式调整-水平垂直居中123456789101112131415161718192021222324252627281.form水平垂直居中2.背景色3.圆角4.按钮宽度.wrap &#123; height: 100%; background-color: #324152; 让里面的元素水平垂直居中 display: flex; justify-content: center; align-items: center;&#125;.wrap form &#123; background-color: #fff; border-radius: 10px; width: 400px; padding: 300px;&#125;.wrap .form &#123; width: 100%;&#125;公共样式：html,body&#123; height: 100%; margin: 0; padding: 0;&#125; 7.4 axios插件1234567891011121314151617181920212223241.安装axios npm i axios 2.使用axios第一种写法 import axios from &apos;axios&apos;; Vue.prototype.$http = axios;3.导入1)http.jsimport axios from &apos;axios&apos;; 将axios变成vue的插件const Http = &#123;&#125;;Http.install = function (Vue, options) &#123; Vue.prototype.$http = axios;&#125;2)导出export default Http;3)在main.js文件中导入import Http from &apos;@plugins/http.js&apos;;使用vue的插件Vue.use(Http);4)在login.vue文件中export default &#123; mounted()&#123; console.log(this.$http); &#125;&#125; 7.5 发送登录请求1234567891011121314151617181920212223接口: 登录验证接口 login post 点击按钮发送请求1.配置基准url http.jsaxios.defaults.baseURL = &apos;...&apos;;2.login.vue&lt;button @click=&apos;handleLogin()&apos;&gt;登录&lt;/button&gt;export default &#123; methods: &#123; handleLogin()&#123; this.$http.post(&apos;login&apos;,this.formdata) .then(res =&gt; &#123; const &#123;data:&#123;meta:&#123;mag,status&#125;&#125;&#125; = res; if(status === 200)&#123; alert(msg); &#125;else&#123; alert(msg); &#125; &#125;); &#125; &#125;&#125;存在的用户: admin 123456 7.6 引入提示框组件123456789101112http://element-cn.eleme.io/#/zh-CN/component/messageif(status === 200)&#123; this.$message(&#123; message: msg, type: &apos;success&apos; &#125;);&#125;else&#123; this.$message(&#123; message: msg, type: &apos;warning&apos; &#125;);&#125; 7.7 登录成功-进入home组件12345678910if(status === 200)&#123; this.$message(&#123; message: msg, type: &apos;success&apos; &#125;); 第一步:成功后跳转到首页:改标识 修改页面 this.$router.push(&#123; name: &apos;home&apos; &#125;);&#125; router.js 123456789101112导入home.vue 文件import Home from &apos;@/components/home.vue&apos;; export default new Router(&#123; routes: [ 渲染首页 &#123; name: &apos;home&apos;, path: &apos;／&apos;, component: Home &#125; ]&#125;) home.vue 12345678910&lt;template&gt; &lt;div&gt;首页内容&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 7.8 简化登录请求代码-async和await121.找到异步操作 在前面加await2.找到距离异步操作最近的函数 前面加async 异步操作 12345678910111213export default &#123; methods: &#123; async handleLogin()&#123; const res = await this.$http.post(&apos;login&apos;,this.formdata); const &#123;data:&#123;meta:&#123;mag,status&#125;&#125;&#125; = res; if(status === 200)&#123; ... &#125;else&#123; ... &#125; &#125; &#125;&#125; 7.9 保存token值123456789101112登录成功后 后台会返回用户信息 token发送axios之后的响应,res,打印console.log(res);里面的data数据中data中有token,是唯一标识if(status === 200)&#123; 保存用户token 值 localStorage.setItem(&apos;token&apos;,data.data.token); this.$message.success(msg); this.$router.push(&#123; name: &apos;home&apos; &#125;);&#125;else&#123; ...&#125; 8. 首页8.1 侧边栏－导航组件－文档1234567891011121314http://element-cn.eleme.io/#/zh-CN/component/menu 导航栏default-active 当前激活菜单的 index unique-opened 是否只保持一个子菜单的展开router 是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转&lt;el-aside width=&quot;200px&quot; class=&apos;aside&apos;&gt; &lt;el-menu default-active=&quot;2&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;el-menu-item-group title=&quot;分组2&quot;&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;&lt;/el-aside&gt; 8.2 侧边栏－引入导航组件－调整123456unique-opened 是否只保持一个子菜单的展开default-active 当前激活菜单的 index调整列表：显示几级 控制点击哪个哪个下拉列表展开一级导航 el-submenu二级导航 el-menu-item注意:每个Index值不一样 8.3 头部-退出功能1234567891011121314151617181920点击退出: 1.清除token session 2.回到登录页 3.给出提示1)&lt;a href=&apos;#&apos; @click.prevent = &quot;handleLoginout()&quot;&gt;&lt;/a&gt;2)export default &#123; methods: &#123; 退出 handleLoginout()&#123; 1.清除token localStorage localStorage.clear(); 2.退出到登录页 this.$router.push(&#123; name: &apos;login&apos; &#125;); 3.提示 this.$message.success(&apos;退出成功&apos;); &#125; &#125;&#125; 8.4 进入首页的权限验证home.vue 12345678910beforeCreate()&#123; 如果没有token，则跳转到登录页 if(!localStorage.getItem(&apos;token&apos;))&#123; this.$message.warining(&apos;请先登录&apos;); 重定向 this.$router.push(&#123; name: &apos;login&apos; &#125;); &#125;&#125; 9. 用户管理9.1 用户列表9.1.1 新建组件-路由配置12341.el-menu开启路由模式 router2.home.vue el-main里面是router-view 3.新建users.vue4.配置路由(在home的路由配置里面children) 123456789101112home.vuedefault-active 当前激活菜单的 indexunique-opened 是否只保持一个子菜单的展开router 是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转&lt;el-menu default-active=&quot;2&quot; unique-opened router&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;el-menu-item-group&gt; &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt; &lt;el-menu-item index=&quot;users&quot;&gt;用户列表&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt;&lt;/el-menu&gt; router.js 123456789101112131415161718192021导入组件&lt;el-main class=&apos;main&apos;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/el-main&gt;import Users from &apos;users&apos;;export default new Router&#123; routes: [ &#123; name: &apos;home&apos;, path: &apos;/home&apos;, component: Home, children: [ &#123; name: &apos;users&apos;, path: &apos;/users&apos;, component: Users &#125; ] &#125; ]&#125; users.vue 123&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 9.1.2 面包屑和搜索框123456789101112131415161718192021222324252627282930313233343536373839整体:卡片面包屑+搜索框+按钮users.vue卡片&lt;el-card class=&quot;card&quot;&gt; 面包屑 &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;用户管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;用户列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; 搜索框 &lt;el-row&gt; &lt;el-col&gt; &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;query&quot; class=&quot;input-with-select&quot;&gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;el-button type=&quot;primary&quot;&gt;添加用户&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/el-card&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; query: &apos;&apos; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .card &#123; height: 100% &#125; .input-with-select &#123; margin-top: 20px; width: 350px; &#125;&lt;/style&gt; 9.1.3 引入表格组件1234567891011121314151617181920212223242526272829303132333435363738394041424344表格data属性值是表格中的数据&lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt;&lt;/el-table&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; query: &apos;&apos;, tableData: [&#123; date: &apos;2016-05-02&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1518 弄&apos; &#125;, &#123; date: &apos;2016-05-04&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1517 弄&apos; &#125;, &#123; date: &apos;2016-05-01&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1519 弄&apos; &#125;, &#123; date: &apos;2016-05-03&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1516 弄&apos; &#125;] &#125; &#125; &#125; &lt;/script&gt; 9.1.4 请求数据users.vue 12345678910111213141516171819202122232425262728293031323334353637383940接口：用户数据列表 users getexport default &#123; data()&#123; return &#123; query: &apos;&apos;, tableData: [], query: &apos;&apos;, pagenum: 1, pagesize: 2, total: -1 &#125; &#125;, created()&#123; this.getTableDate(); &#125;, methods: &#123; 获取用户列表 async getTableDate()&#123; 授权token 需要设置为token的值 const AUTH_TOKEN = localStorage.getItem(&apos;token&apos;); axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=$&#123;this.query&#125;&amp;pagenum=$&#123;this.pagenum&#125;$pagesize=$&#123;this.pagesize&#125;&apos;); console.log(res); 获取到的数据为Null 因为token无效 原因是 所有接口数据中 除了登录不需要授权 其他所有的请求都需要授权 必须要在axios文件中设置一个请求头,在Http.js文件中添加请求头axios发送请求,vue将axios封装成vue插件 const &#123;meta:&#123;status,msg&#125;,data:&#123;total,users&#125;&#125; = res.data; 判断状态。。。。。。。 &#125; &#125;&#125;或者async getData()&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); this.$http.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=&apos;+this.query+&apos;&amp;pagenum=&apos;+this.pagenum+&apos;&amp;pagesize=&apos;+this.pagesize); console.log(res);&#125; http.js 12345678导入import axios from &apos;axios&apos;;const Http = &#123;&#125;;Http.install = function(Vue,options)&#123; 设置基准值 axios.defaults.baseURL = &apos;http://localhost:8888/api/private/v1/&apos;; 授权token,如果写在这 那么所有发送请求都会授权token,所以不能写在这&#125; 9.1.5 渲染数据-一般数据123456789101112131415161718192021221.this.tableData = res.data.data.users2.给prop赋值3.表格数据分为两类 一般数据(单元格的内容就是prop的值) 特殊数据if(status === 200)&#123; this.tableData = users; this.total = total; this.$message.success(msg);&#125;else&#123; this.$message.warning(msg);&#125;&lt;el-table&gt; prop=&apos;id&apos; prop=&apos;username&apos; prop=&apos;email&apos; prop=&apos;mobile&apos; prop=&apos;create_time&apos; prop=&apos;mg_state&apos;&lt;/el-table&gt; 9.1.6 渲染数据-日期格式处理12345678910111213141516171819202122232425262728293031321.使用全局过滤器 main.js文件中 导入 import moment from &apos;moment&apos;; Vue.filter(&apos;fmDate&apos;,(v) =&gt; &#123; return moment(v).format(&apos;YYYY-MM-DD&apos;); &#125;);2.安装moment npm i moment;3.在main.js文件中引入 import moment from &apos;moment&apos;;4.在users.vue文件中prop的值不支持过滤器的使用&lt;el-table-column prop=&apos;create_time&apos; label=&quot;创建日期&quot; width=&quot;150&quot;&gt;&lt;/el-table-column&gt;5.如果单元格的内容不是prop的key对应的值，此时，需要给被显示内容的外层包裹容器template目的:在里层使用外层tableData-&gt;组件传值slot-scope作用:承上启下/传递数据&apos;tableData&apos;自动获取上层数据的值 : data=&apos;tableData&apos;在里层通过tableDat.row来使用&lt;el-table-column label=&quot;创建日期&quot; width=&quot;150&quot;&gt; &lt;template slot-scope=&apos;tableData&apos;&gt; &#123;&#123;tableData.row.create_time|fmDate&#125;&#125; &lt;/template&gt;&lt;/el-table-column&gt;6.注意: slot-scope的值可以是任意值,一般都是scope通过template的属性slot-scope可以把上层数据tableData传递给里层进行使用&lt;el-table-column label=&quot;创建日期&quot; width=&quot;150&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &#123;&#123;scope.row.create_time|fmDate&#125;&#125; &lt;/template&gt;&lt;/el-table-column&gt;scope会自动获取上层有数据的值 :data=&apos;tableData&apos;scope.row是数据源中的每个元素slot-scope和element-ui没任何关系,是vue的API 9.1.7 用户状态开关12345678910111213element-ui 开关&lt;el-table-column label=&quot;用户状态&quot; width=&quot;180&quot;&gt; 1）如果单元格的内容不是prop的key对应的值，此时，需要给被显示内容的外层包裹容器template 2）通过slot-scope获取上层数据 &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-switch 3)获取数据 scope.row.mg_state v-model=&quot;scope.row.mg_state&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt; &lt;/el-switch&gt; &lt;/template&gt;&lt;/el-table-column&gt; 9.1.8 操作123456789align=&apos;center&apos; :文本居中header-align=&apos;center&apos;: 表头居中&lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 9.2 分页组件9.2.1 分页文档引入12345678910111213141516171819202122232425分页组件@size-change:每页显示的数据条数改变时@current-change:当前页显示数据条数改变时current-page:当前页码page-sizes:当前页显示数据条数数组page-size:当前页显示的条数total：总条数&lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;currentPage4&quot; :page-sizes=&quot;[100, 200, 300, 400]&quot; :page-size=&quot;100&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;400&quot;&gt;&lt;/el-pagination&gt;方法:methods: &#123; handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); &#125;&#125; 9.2.2 配置数据12345678910111213141516171819202122232425262728293031323334353637383940414243组件配置：&lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pagenum&quot; :page-sizes=&quot;[2, 4, 6, 8]&quot; :page-size=&quot;2&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt;&lt;/el-pagination&gt;数据data()&#123; return &#123; input: &apos;&apos;, tableData: [], query:&apos;&apos;, pagenum: 1, pagesize: 2, total: -1 &#125;&#125;,methods: &#123; handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); &#125;, async getData()&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); this.$http.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=&apos;+this.query+&apos;&amp;pagenum=&apos;+this.pagenum+&apos;&amp;pagesize=&apos;+this.pagesize); console.log(res); const &#123;data:&#123;pagenum,total,users&#125;,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); this.tableData = users; this.total = total; &#125;else&#123; this.$message.warning(msg); &#125; &#125;&#125; 10.2.3 分页请求1234567891011121314151617181920212223242526272829303132接口:用户数据列表 get users点击页码时,发送新请求每页娴熟数据条数改变时，发送新请求methods: &#123; 每页条数改变时,重新渲染页面 handleSizeChange(val) &#123; this.pagenum = 1; this.pagesize = val; this.getData(); console.log(`每页 $&#123;val&#125; 条`); &#125;, 当前页面改变时,重新渲染页面 handleCurrentChange(val) &#123; this.pagenum = val; this.getData(); console.log(`当前页: $&#123;val&#125;`); &#125;, async getData()&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); this.$http.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; const res = await this.$http.get(&apos;users?query=&apos;+this.query+&apos;&amp;pagenum=&apos;+this.pagenum+&apos;&amp;pagesize=&apos;+this.pagesize); console.log(res); const &#123;data:&#123;pagenum,total,users&#125;,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); this.tableData = users; this.total = total; &#125;else&#123; this.$message.warning(msg); &#125; &#125; &#125; 9.3 搜索用户1234567891011121314151617181920211）点击搜索按钮,将this.input的值赋给query查询参数,渲染表格2)点击输入框的清空,触发清空事件,渲染所有数据 给输入框加 clearable 属性,可清空 清空事件 @clear=&apos;&apos;&lt;el-col&gt; &lt;el-input placeholder=&quot;请输入内容&quot; clearable @clear=&apos;getAllUser()&apos; v-model=&quot;input&quot; class=&quot;input-with-select&quot;&gt; &lt;el-button slot=&quot;append&quot; @click=&apos;searchUser()&apos; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;el-button plain&gt;朴素按钮&lt;/el-button&gt;&lt;/el-col&gt;//清空数据时触发getAllUser()&#123; this.query = this.input; 如果不重新设置this.query = &apos;&apos; 还是原来的值 this.getData();&#125;,//搜索用户searchUser()&#123; 设置第一页开始显示 this.pagenum = 1; this.query = this.input; this.getData();&#125; 9.4 添加用户9.4.1 打开对话框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647对话框组件&lt;el-button plain @click = &apos;openDialog()&apos;&gt;添加用户&lt;/el-button&gt;对话框&lt;el-dialog title=&quot;添加用户&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.email&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.mobile&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisible = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;数据data()&#123; return &#123; //添加用户的值 默认为false隐藏 dialogFormVisible:false, //对话框数据 form: &#123; username: &apos;&apos;, password: &apos;&apos;, email: &apos;&apos;, mobile:&apos;&apos; &#125;, //对话框宽度 formLabelWidth: &apos;150px&apos; &#125;&#125;,methods: &#123; //点击按钮显示对话框 openDialog()&#123; 清空对话框中的数据 this.form = &#123;&#125;; this.dialogFormVisible = true; &#125;&#125; 9.4.2 发送请求1234567891011121314151617181920212223242526添加用户:添加用户 users post&lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addUser()&quot;&gt;确 定&lt;/el-button&gt;&lt;/div&gt;1)点击确定按钮,发送请求，请求成功之后,关闭对话框,重新渲染页面,给出提示,打开对话框清空数据//添加用户 async addUser()&#123; const res = await this.$http.post(&apos;users&apos;,this.form); //console.log(res); const &#123;meta: &#123;msg,status&#125;&#125; = res.data; if(status == 201)&#123; this.dialogFormVisible = false; this.getData(); this.$message.success(msg); &#125;else &#123; this.$message.warning(msg); &#125; &#125;, //点击按钮显示对话框 openDialog()&#123; 清空数据 this.form = &#123;&#125;; this.dialogFormVisible = true; &#125;2)点击取消,关闭对话框 9.5 删除用户9.5.1 打开确认框123456789101112131415161718&lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser()&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;&lt;/template&gt;删除处理//删除用户deleteUser()&#123; this.$confirm(&apos;确认删除该用户?&apos;, &apos;提示&apos;, &#123; confirmButtonText: &apos;确定&apos;, cancelButtonText: &apos;取消&apos;, type: &apos;warning&apos; &#125;).then(() =&gt; &#123; this.$message.success(&apos;删除成功!&apos;); &#125;).catch(() =&gt; &#123; this.$message.info(&apos;已取消删除!&apos;); &#125;);&#125; 9.5.2 处理响应123456789101112131415161718192021222324252627接口: 删除单个用户 delete users/:id点击删除框中的确认按钮=&gt;发送请求 如果删除成功,重新渲染列表，设置从第一页开始渲染 如果删除失败,给出提示//删除用户deleteUser(id)&#123; this.$confirm(&apos;确认删除该用户?&apos;, &apos;提示&apos;, &#123; confirmButtonText: &apos;确定&apos;, cancelButtonText: &apos;取消&apos;, type: &apos;warning&apos; &#125;).then(async () =&gt; &#123; const res = await this.$http.delete(`users/$&#123;id&#125;`); console.log(res); const &#123;meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); this.pagenum = 1; this.getData(); &#125;else&#123; this.$message.info(msg); &#125; &#125;).catch(() =&gt; &#123; this.$message.info(&apos;已取消删除!&apos;); &#125;);&#125;注意:传参 async的位置 9.6 编辑9.6.1 点击按钮显示对话框123456789101112131415161718192021222324252627282930313233343536371.点击编辑按钮,注册点击事件&lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;edit(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;&lt;/template&gt;2.弹出对话框&lt;el-dialog title=&quot;编辑用户&quot; :visible.sync=&quot;dialogFormVisibleEdit&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;姓名&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.username&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮箱&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.email&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;电话&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.mobile&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleEdit = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;editUser()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;3.数据data()&#123; return &#123; dialogFormVisibleEdit:false &#125;&#125;,methods: &#123; //编辑用户 edit()&#123; 弹出对话框 this.dialogFormVisibleEdit = true; &#125;&#125; 9.6.2 显示编辑数据12345678910111213接口: 根据 ID 查询用户信息 users/:id get//编辑用户 打开对话框,根据传递过来的数据进行查询数据，并渲染到表单async edit(id)&#123; this.dialogFormVisibleEdit = true; //根据id查询数据 const res = await this.$http.get(`users/$&#123;id&#125;`); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.form = data; &#125;else&#123; this.$message.warning(msg); &#125;&#125; 9.6.3 发送请求123456789101112131415接口: 编辑用户提交 users/:id put//修改数据async editUser()&#123; const res = await this.$http.put(`users/$&#123;this.form.id&#125;`,this.form); const &#123;meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); //关闭对话框 //this.dialogFormVisibleEdit = false; //重新渲染页面 //this.getData(); &#125;else&#123; this.$message.warning(msg); &#125;&#125; 9.6.4 修改用户状态12345678910111213141516接口: 修改用户状态 users/:uId/state/:type put1.开关状态改变时,触发change事件 开关是表单元素,v-model是数据双向绑定的,所以不需要重新渲染页面&lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;用户状态&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-switch @change=&apos;changeStatue(scope.row)&apos; v-model=&quot;scope.row.mg_state&quot; active-color=&quot;#13ce66&quot; inactive-color=&quot;#ff4949&quot;&gt; &lt;/el-switch&gt; &lt;/template&gt;&lt;/el-table-column&gt;2.//修改用户状态 参数写在url中 id 和typeasync changeStatue(user)&#123; const res = await this.$http.put(`users/$&#123;user.id&#125;/state/$&#123;user.mg_state&#125;`);&#125; 9.7 分配角色9.7.1 点击按钮，弹出对话框123456789101112131415161718192021222324252627282930313233343536371.&lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;edit(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRole(scope.row)&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;&lt;/template&gt;2.&lt;el-dialog title=&quot;分配角色&quot; :visible.sync=&quot;dialogFormVisibleRole&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;用户名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &#123;&#123;currentUserName&#125;&#125; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;角色名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-select v-model=&apos;currentId&apos;&gt; &lt;el-option label=&quot;请选择&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;测试&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleRole = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogFormVisibleRole = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;3.data()&#123; return &#123; //分配角色 dialogFormVisibleRole: false, currentId: -1, roles:[], 角色数组 currentUserName: &apos;&apos; &#125;&#125;,methods:&#123; //分配角色 showRole(user)&#123; this.dialogFormVisibleRole = true; &#125;&#125; 9.7.2 显示对话框-下拉列表1234select:v-model写在select中如果v-model绑定数据的值和option的value一样,默认显示option(label值)如果选择了某个option，此时,v-model绑定的数据值就是被选中的option的value值 9.7.3 显示当前用户的名字和角色12345678910111213141516171819202122232425262728接口:角色列表 get roles 打开对话框,获取数据,将获取到的数据显示在下拉框中label显示的是下拉框中的内容,value是id号如果:value和:value不加:冒号,则显示的是字符串 v.rolename不是内容methods:&#123; //分配角色 async showRole(user)&#123; 显示当前用户的名字 this.currentUserName = user.username; this.dialogFormVisibleRole = true; const res = await this.$http.get(&apos;roles&apos;); console.log(res); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.roles = data; &#125;else&#123; this.$message.info(msg); &#125; &#125;&#125;渲染数据&lt;el-form-item label=&quot;角色名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-select v-model=&apos;currentId&apos;&gt; &lt;el-option label=&quot;请选择&quot; disabled value=&quot;shanghai&quot;&gt;&lt;/el-option&gt; &lt;el-option v-for=&apos;(v,i) in roles&apos; :key=&apos;i&apos; :label=&quot;v.roleName&quot; :value=&quot;v.id&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt;&lt;/el-form-item&gt; 9.7.4 点击确定-修改角色12345678910111213141516171819202122232425261.显示当前用户名定义数据 currentUserName 方法中传入一个参数 scope.rowthis.currentUserName = scope.row.username;在标签中使用: &#123;&#123;currentUserName&#125;&#125;2.显示当前用户的角色名字 根据用户id查询角色id,将查询到的角色id赋值给select的v-model值,从而显示出来//分配角色async showRole(user)&#123; //显示当前用户的名字 console.log(user); this.currentUserName = user.username; this.dialogFormVisibleRole = true; const res = await this.$http.get(&apos;roles&apos;); console.log(res); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.roles = data; &#125;else&#123; this.$message.info(msg); &#125; //根据当前用户id请求角色id const res2 = await this.$http.get(`users/$&#123;user.id&#125;`); //console.log(res2); this.currentId = res2.data.data.rid;&#125; 9.7.5 修改用户角色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869接口： 分配用户角色 users/:id/role put1. &lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;edit(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;deleteUser(scope.row.id)&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRole(scope.row)&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt;2.&lt;el-dialog title=&quot;分配角色&quot; :visible.sync=&quot;dialogFormVisibleRole&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;用户名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &#123;&#123;currentUserName&#125;&#125; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;角色名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-select v-model=&apos;currentId&apos;&gt; &lt;el-option label=&quot;请选择&quot; disabled value=&quot;shanghai&quot;&gt;&lt;/el-option&gt; &lt;el-option v-for=&apos;(v,i) in roles&apos; :key=&apos;i&apos; :label=&quot;v.roleName&quot; :value=&quot;v.id&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleRole = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;setRole()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;3.data()&#123; return &#123; //分配角色 dialogFormVisibleRole: false, currentId: -1, roles: [], currentUserName: &apos;&apos;, currentUserId:&apos;&apos; &#125; &#125;, methods: &#123; //修改角色 async setRole()&#123; const res = await this.$http.put(`users/$&#123;this.currentUserId&#125;/role`,&#123;rid:this.currentId&#125;); const &#123;meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.$message.success(msg); //关闭对话框 this.dialogFormVisibleRole = false; &#125; &#125;, //分配角色 async showRole(user)&#123; //console.log(user); //显示当前用户的名字 this.currentUserName = user.username; //当前用户的id this.currentUserId = user.id; this.dialogFormVisibleRole = true; const res = await this.$http.get(&apos;roles&apos;); console.log(res); const &#123;data,meta:&#123;msg,status&#125;&#125; = res.data; if(status == 200)&#123; this.roles = data; &#125;else&#123; this.$message.info(msg); &#125; //根据当前用户id请求角色id const res2 = await this.$http.get(`users/$&#123;user.id&#125;`); //console.log(res2); //当前角色id this.currentId = res2.data.data.rid; &#125;&#125; 12345678git branchgit status git add .git commit -m &quot;&quot;git checkout master 切换到主分支git status 查看状态git merge dev-users 合并分支git push 推 10. 权限管理10.1 权限列表10.1.1 自定义面包屑组件12345678910111213141516171819202122232425262728293031cusBread.vue&lt;template&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&#123;&#123;this.level1&#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&#123;&#123;this.level2&#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt;&lt;/template&gt;&lt;script&gt; export default &#123; //组件名字 name: &apos;my-bread&apos;, props: [&apos;level1&apos;,&apos;level2&apos;] &#125;&lt;/scpript&gt;&lt;style&gt;&lt;/style&gt;main.jsimport MyBread from &apos;@/components/cusBread.vue&apos;//定义全局组件Vue.component(&quot;my-bread&quot;,MyBread);在rights.vue中使用&lt;my-bread &apos;level1=&apos;权限管理&apos; level2=&apos;权限列表&apos;&gt;&lt;/my-bread&gt;组件： 场景|特点:当页面中有多个位置有一样的标签结构时,封装成一个组件 组件中的数据来源是其他组件,数据不能写在data中，要写在prop中 组件通信: 父传子 组件分类:全局|局部 10.1.2 axios-拦截器统一设置请求头123456789101112131415161718192021222324axios文档中拦截器: 在请求或和响应被then和catch处理前拦截他们 由于在非登录请求中都要设置 token,所以在axios拦截器中发送请求之前要先处理tokenmain.js文件中//设置发送请求baseUrlaxios.defaults.baseURL = &apos;http://localhost:8888/api/private/v1/&apos;;// 设置请求拦截// 添加一个请求拦截器axios.interceptors.request.use(function (config) &#123; //在发送请求之前希望做些什么 //如果请求的不是登录请求，则设置拦截进行下面的代码 //根据config.url可以获取当前请求的地址 console.log(config); if(config.url !== &apos;login&apos;)&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); config.headers.Authorization = AUTH_TOKEN; &#125; return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;);Vue.prototype.$http = axios;设置拦截之后就不需要在发送请求之前设置头部token 10.1.3 表格展示-显示层级123456789101112131415161.如果组件的内容是开始和结束标签的里面,此时需要给内容的外层套一个template2.如果内容里面用到了数据,并且数据来源label是当前组件的父组件的数据el-table,此时需要加一个slot-scope&lt;template slot-scope=&apos;scope&apos;&gt; &lt;span v-if=&quot;scope.row.level === &apos;0&apos;&quot;&gt;一级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;1&apos;&quot;&gt;二级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;2&apos;&quot;&gt;三级&lt;/span&gt;&lt;/template&gt;要显示的层级不是 0 1 2,而是一级、二级、三级&lt;el-table-column label=&quot;层级&quot; width=&quot;240&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;span v-if=&quot;scope.row.level === &apos;0&apos;&quot;&gt;一级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;1&apos;&quot;&gt;二级&lt;/span&gt; &lt;span v-if=&quot;scope.row.level === &apos;2&apos;&quot;&gt;三级&lt;/span&gt; &lt;/template&gt;&lt;/el-table-column&gt; 10.2 角色列表10.2.1 表格展示-展开行功能分析12345678910111213141516171819202122232425262728表格展开功能： 通过设置 type=&quot;expand&quot; 和 Scoped slot 可以开启展开行功能，el-table-column 的模板会被渲染成为展开行的内容，展开行可访问的属性与使用自定义列模板时的 Scoped slot 相同。&lt;el-table :data=&quot;roles&quot; height=&apos;480px&apos; style=&quot;width: 100%&quot;&gt; 表格可展开 &lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;right&apos;&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项一&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项二&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt;&lt;span&gt;选项三&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;#&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleName&quot; label=&quot;角色名称&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleDesc&quot; label=&quot;角色描述&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; 10.2.2 表格展示-展开行-一级权限12345678910111213&lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-row v-for=&apos;(item1,i) in scope.row.children&apos;&gt; &lt;el-col&gt;&lt;span&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt; &lt;el-row&gt; &lt;el-col&gt;&lt;span&gt;选项二&lt;/span&gt;&lt;/el-col&gt; &lt;el-col&gt;&lt;span&gt;选项三&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt;&lt;/el-table-column&gt; 10.2.3 表格展示-展开行-二级三级权限1234567891011121314151617181920212223242526272829&lt;el-table :data=&quot;roles&quot; height=&apos;480px&apos; style=&quot;width: 100%&quot;&gt; &lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-row v-for=&apos;(item1,i) in scope.row.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;span&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; &lt;el-col :span=&apos;20&apos;&gt; 二级权限 &lt;el-row v-for=&apos;(item2,i) in item1.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;span&gt;&#123;&#123;item2.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; 三级权限 &lt;el-col :span=&apos;20&apos;&gt;&lt;span v-for=&apos;(item3,i) in item2.children&apos; :key=&apos;i&apos;&gt; &#123;&#123;item3.authName&#125;&#125;&lt;/span&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column type=&quot;index&quot; label=&quot;#&quot; width=&quot;100&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleName&quot; label=&quot;角色名称&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;roleDesc&quot; label=&quot;角色描述&quot; width=&quot;240&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column align=&apos;center&apos; header-align=&apos;center&apos; label=&quot;操作&quot; width=&quot;230&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-edit&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-delete&quot;&gt;&lt;/el-button&gt; &lt;el-button round plain size=&apos;mini&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt;添加样式： 标记 把所有span标签换成 el-tag 10.2.4 展开行-样式调整-处理无权限123456789101112131415161718192021222324252627282930311.给每个标签添加x号 给每个&lt;el-tag&gt;标签添加 closable&lt;el-tag closable&gt;&lt;/el-tag&gt;2添加箭头符号 &gt; element-ui图标 &lt;i class=&apos;el-icon-arrow-right&apos;&gt;&lt;/i&gt;3.在展开行的位置处理无权限的内容&lt;el-row v-if=&apos;v-if=&apos;&apos;scope.row.children.length===0&apos;&gt; &lt;el-col&gt; &lt;span&gt;该角色未分配权限&lt;/span&gt; &lt;/el-col&gt;&lt;/el-row&gt;代码：&lt;el-table-column type=&quot;expand&quot; width=&quot;100&quot;&gt; &lt;template slot-scope=&apos;scope&apos;&gt; &lt;el-row v-for=&apos;(item1,i) in scope.row.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;el-tag closable&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/el-tag&gt;&lt;i class=&apos;el-icon-arrow-right&apos;&gt;&lt;/i&gt;&lt;/el-col&gt; &lt;el-col :span=&apos;20&apos;&gt; &lt;el-row v-for=&apos;(item2,i) in item1.children&apos; :key=&apos;i&apos;&gt; &lt;el-col :span=&apos;4&apos;&gt;&lt;el-tag closable&gt;&#123;&#123;item2.authName&#125;&#125;&lt;/el-tag&gt;&lt;i class=&apos;el-icon-arrow-right&apos;&gt;&lt;/i&gt;&lt;/el-col&gt; &lt;el-col :span=&apos;20&apos;&gt;&lt;el-tag closable v-for=&apos;(item3,i) in item2.children&apos; :key=&apos;i&apos;&gt;&#123;&#123;item3.authName&#125;&#125;&lt;/el-tag&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row v-if=&apos;v-if=&apos;&apos;scope.row.children.length===0&apos;&gt; &lt;el-col&gt; &lt;span&gt;该角色未分配权限&lt;/span&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt;&lt;/el-table-column&gt; 10.3 修改权限-树形结构10.3.1 显示对话框123456789101112131415点击√弹出对话框 1.&lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRights()&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt; 2.点击√,对话框显示 data()&#123; return &#123; roles: [], dialogVisible: false &#125;&#125;,methods: &#123; //分配权限 showRights()&#123; this.dialogVisible = true; &#125;&#125; 10.3.1 文档分析1234567891011121314151617181920212223242526272829301.打开对话框的同时,获取所有的权限，并查询当前角色下的所有权限，将有的权限打勾2.树形控件 tree3.树形结构data: 树形结构的数据源node-key： 每个节点的位移标识 通常是 data中的id值default-expanded-keys设置默认展开的节点 数组:[id值]default-checked-keys设置默认选中的节点 数组:[id值]props 配置选项 = &#123;label,children&#125;label和children值来源于data数据中的key名每个节点都有半选和全选:如果子节点全部选中,则节点全选显示树形结构&lt;el-dialog title=&quot;分配权限&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;50%&quot;&gt; &lt;el-tree default-expand-all ref=&apos;tree&apos; :data=&quot;treeData&quot; show-checkbox node-key=&quot;id&quot; :default-expanded-keys=&quot;expandedArr&quot; :default-checked-keys=&quot;checkedArr&quot; :props=&quot;defaultProps&quot;&gt; &lt;/el-tree&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt;&lt;/el-dialog&gt; 10.3.2 配置数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576接口:获取树形权限列表获取所有选项,将所有选项显示在弹出框中,并将所有的id保存在默认展开的数组中1.注册点击事件&lt;el-button round plain size=&apos;mini&apos; @click=&apos;showRights(scope.row)&apos; type=&quot;primary&quot; icon=&quot;el-icon-check&quot;&gt;&lt;/el-button&gt;2.弹出框&lt;el-tree default-expand-all 展开所有节点 :data=&quot;treeData&quot; show-checkbox node-key=&quot;id&quot; 默认展开的权限id :default-expanded-keys=&quot;expandedArr&quot; 默认选中的权限id :default-checked-keys=&quot;checkedArr&quot; :props=&quot;defaultProps&quot;&gt;&lt;/el-tree&gt;3.数据配置export default &#123; data()&#123; return &#123; roles: [], //树形结构配置 dialogVisible: false, //树形结构数据 treeData: [], //默认展开的权限的id expandedArr:[], //默认选中的权限的id checkedArr:[], //树形结构配置 defaultProps: &#123; children: &apos;children&apos;, label: &apos;authName&apos; &#125; &#125; &#125;, created()&#123; this.getRoles(); &#125;, methods: &#123; //分配权限 async showRights()&#123; //显示对话框 this.dialogVisible = true; //获取树形结构的权限数据 const res = await this.$http.get(`rights/tree`); console.log(res); this.treeData = res.data.data; 第一种方法:获取所有权限的id //const tempArr = []; //this.treeData.forEach(item1 =&gt; &#123; // tempArr.push(item1.id); // item1.children.forEach(item2 =&gt; &#123; // tempArr.push(item2.id); // item2.children.forEach(item3 =&gt; &#123; // tempArr.push(item3.id); // &#125;); // &#125;); //&#125;); //this.expandedArr = tempArr; 第二种方法: 给标签添加属性 default-expand-all 是否默认展开所有节点 &#125;, //删除权限 async deleRights(role,rights)&#123; const res = await this.$http.delete(`roles/$&#123;role.id&#125;/rights/$&#123;rights.id&#125;`); console.log(res); this.roles = res.data.data; &#125;, //渲染权限列表 async getRoles()&#123; const res = await this.$http.get(`roles`); console.log(res); //this.roles = res.data.data; &#125; &#125;&#125; 10.3.3 显示已有权限123456789101112131415161718192021222324接口:获取所有权限列表获取当前角色所拥有的权限，将权限保存在默认勾选的数组中//分配权限async showRights()&#123; //显示对话框 this.dialogVisible = true; //获取树形结构的权限数据 const res = await this.$http.get(`rights/tree`); console.log(res); this.treeData = res.data.data; //获取当前角色拥有的权限id const tempArr = []; role.children.forEach(item1 =&gt; &#123; 前两个不需要添加,因为只要里面的id选中，外面的id会自动选中 //tempArr.push(item1.id); item1.children.forEach(item2 =&gt; &#123; //tempArr.push(item2.id); item2.children.forEach(item3 =&gt; &#123; tempArr.push(item3.id); &#125;); &#125;); &#125;); this.checkedArr = tempArr;&#125; 10.3.4 分配权限-分析1234567891.点击确定按钮 -&gt;发送请求 setRights()2.获取节点中全选的节点的id 3.获取节点中半选的节点的id 4.发送请求 const res = await this.$http.post(`posts/$&#123;this.currRoleId&#125;/rights`,&#123; rids:以,分割的权限id的列表 &#125;);5.关闭对话框6.更新表格 10.3.5 分配权限-实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596接口:角色授权1.&lt;el-button type=&quot;primary&quot; @click=&quot;setRights()&quot;&gt;确 定&lt;/el-button&gt;&lt;/el-button&gt;2.&lt;el-tree ref=&apos;tree&apos; :data=&quot;treeData&quot; show-checkbox node-key=&quot;id&quot; :default-expanded-keys=&quot;expandedArr&quot; :default-checked-keys=&quot;checkedArr&quot; :props=&quot;defaultProps&quot;&gt;&lt;/el-tree&gt;3.&lt;script&gt; export default &#123; data()&#123; return &#123; roles: [], //树形结构配置 dialogVisible: false, //树形结构 treeData: [], //默认展开的权限的id expandedArr:[], //默认选中的权限的id checkedArr:[], //树形结构配置 defaultProps: &#123; children: &apos;children&apos;, label: &apos;authName&apos; &#125;, currRoleId:&apos;&apos; &#125; &#125;, created()&#123; this.getRoles(); &#125;, methods: &#123; //点击确定按钮分配权限 async setRights()&#123; //通过tree树形结构的方法自动获取id 通过获取元素来操作方法 vue中通过ref来操作DOM元素 //1.获取节点中全选的节点的id //2.获取节点中半选的节点的id const arr1 = this.$refs.tree.getCheckedKeys(); const arr2 = this.$refs.tree.getHalfCheckedKeys(); //以,分割的权限id的列表 或者通过数组的方法 arr1.concat(arr2) const arr = [...arr1,...arr2]; //3.发送请求 //const res = await this.$http.post(`posts/$&#123;this.currRoleId&#125;/rights`,&#123; // rids:以,分割的权限id的列表 //&#125;); const res = await this.$http.post(`posts/$&#123;this.currRoleId&#125;/rights`,&#123; rids:arr.join(&apos;,&apos;) &#125;); console.log(res); //4.关闭对话框 this.dialogVisible = false; //5.更新表格 this.getRoles(); &#125;, //分配权限 async showRights(role)&#123; //获取当前角色的id this.currRoleId = role.id; //显示对话框 this.dialogVisible = true; //获取树形结构的权限数据 const res = await this.$http.get(`rights/tree`); console.log(res); this.treeData = res.data.data; &#125;, //删除权限 async deleRights(role,rights)&#123; const res = await this.$http.delete(`roles/$&#123;role.id&#125;/rights/$&#123;rights.id&#125;`); console.log(res); this.roles = res.data.data; //获取当前角色拥有的权限id const tempArr = []; role.children.forEach(item1 =&gt; &#123; //tempArr.push(item1.id); item1.children.treeData.forEach(item2 =&gt; &#123; // tempArr.push(item2.id); item2.children.treeData.forEach(item3 =&gt; &#123; tempArr.push(item3.id); &#125;); &#125;); &#125;); this.checkedArr = tempArr; &#125;, //渲染权限列表 async getRoles()&#123; const res = await this.$http.get(`roles`); console.log(res); //this.roles = res.data.data; &#125; &#125; &#125;&lt;/scpript&gt; 11. 首页-侧边栏-动态导航12345678910111213141516171819202122232425262728293031321.&lt;el-submenu v-for=&quot;(item1,i) in menus&quot; :index=&quot;&apos;&apos;+item1.order&quot; :key=&apos;item1.id&apos;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;item1.authName&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item :index=&quot;item2.path&quot; v-for=&apos;(item2,i) in item1.children&apos; :key=&apos;item2.id&apos;&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;&#123;&#123;item2.authName&#125;&#125; &lt;/el-menu-item&gt; &lt;/el-submenu&gt;2.data()&#123; return &#123; menus: [] &#125; &#125;, created()&#123; this.getMenus(); &#125;, beforeCreate()&#123; if(!window.localStorage.getItem(&apos;token&apos;))&#123; this.$message.warning(&apos;请先登录&apos;); this.$router.push(&#123; name: &apos;login&apos; &#125;); &#125; &#125;, methods: &#123; //侧边栏-动态导航 async getMenus()&#123; const res = await this.$http.get(`menus`); console.log(res); this.menus = res.data.data; &#125; 12. 导航守卫-路由拦截器123456789101112131415161718192021在home渲染之前,判断是否登录在路由配置生效之前,判断是否登录在每个标识生效之前，判断是不是登录标识,如果是则继续,如果不是,判断有没有token,则跳转到登录页面全局守卫://导航守卫router.beforeEach((to,from,next) =&gt; &#123; if(to.name === &apos;login&apos;)&#123; next(); &#125;else&#123; if(!window.localStorage.getItem(&apos;token&apos;))&#123; 提示消息 Message.warning(&apos;请先登录&apos;); router.push(&#123; name: &apos;login&apos; &#125;); &#125;else&#123; next(); &#125; &#125;&#125;);export default router; 13. 商品管理13.1 添加商品-步骤条121.添加提示框2.添加步骤条 goodslist.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;el-card&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1&quot;&gt; &lt;el-step title=&quot;步骤 1&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 2&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 3&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 4&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;步骤 5&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/scpript&gt;&lt;style&gt;&lt;/style&gt; 13.2 添加商品-tabs标签1234567891011121314151617181920212223242526272829303132333435363738394041当选中的是下面哪个el-tab-pane时,v-model值是当前选中的name值&lt;template&gt; &lt;el-card&gt; &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &apos;/&apos; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;商品列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &#123;&#123;active&#125;&#125; &lt;el-tabs v-model=&quot;active&quot; tab-position=&quot;left&quot; style=&quot;height: 350px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt;基本信息&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt;商品参数&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt;商品属性&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt;商品图片&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt;商品内容&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; active: &quot;1&quot; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 13.3 添加商品基本信息-绑定表单数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667接口:添加商品因为添加商品,最后是要提交数据的，所以添加一个表单&lt;template&gt; &lt;el-card&gt; &lt;my-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/my-bread&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; 添加表单： &lt;el-form v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; &lt;el-tabs v-model=&quot;active&quot; tab-position=&quot;left&quot; style=&quot;height: 500px&quot; class=&apos;tabs&apos;&gt; 添加表单数据 &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_cat&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; ...级联选择器 &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt;商品参数&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt;商品属性&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt;商品图片&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt;商品内容&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; active: &quot;1&quot;, 数据名来源于接口数据 form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: &apos;&apos;, attrs: &apos;&apos; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; 13.4 级联选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758接口:商品数据列表1.&lt;!--级联选择器 表单元素 options： 绑定数据 v-model绑定的是一个数组:被选中的label的value值 props=&#123;label/children/value&#125;配置选项 值来源是options绑定的数据的key名 @change选择发生改变时会触发--&gt;&lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt;&lt;/el-form-item&gt;2.export default &#123; data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: &apos;&apos;, attrs: &apos;&apos; &#125;, //级联数据要使用的数据 options: &apos;&apos;, selectedOptions2: [], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125; &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; console.log(this.options); &#125; &#125; &#125; 13.5 商品参数-获取动态参数数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950接口:分类参数管理-参数列表如果要获取动态参数，必须选择商品的三级分类1.&lt;el-form label-position=&apos;top&apos; v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; 第一:给tab注册tab 被选中时触发 的事件 tab-click 来检测是不是第二个tab栏被选中 &lt;el-tabs v-model=&quot;active&quot; @tab-click = &apos;changeTab()&apos; tab-position=&quot;left&quot; style=&quot;height: 550px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_cat&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt;商品参数&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt;商品属性&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt;商品图片&lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt;商品内容&lt;/el-tab-pane&gt; &lt;/el-tabs&gt;&lt;/el-form&gt;2.tab栏被选中//当tab栏选中切换时async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; $&#123;this.selectedOptions2[2]&#125;:当前选中的三级分类的id const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125;&#125; 13.6 商品参数-复选框组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172731.使用组件复选框 是表单元素 所以需要外层需要使用el-for-item&lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item v-for=&apos;(item1,i) in arrDy&apos; :key=&apos;item1.attr_id&apos; :label=&quot;item1.attr_name&quot;&gt; &lt;el-checkbox-group v-model=&quot;checkList&quot;&gt; &lt;el-checkbox v-for=&apos;(item2,i) in item1.attr_vals&apos; :key=&apos;i&apos; :label=&quot;item2&quot;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt;&lt;/el-tab-pane&gt;2.export default &#123; data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: &apos;&apos;, attrs: &apos;&apos; &#125;, //级联数据要使用的数据 options: [], selectedOptions2: [1,3,6], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, //复选框组数据 checkList: [], //动态参数数组 arrDy: [] &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //当tab栏选中切换时 async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; 因为获取参数值中attr-vals的值是字符串所以必须先转为数组 判断如果输入的是空格|空字符串的可能,如果是空字符串,则返回空数组 也要考虑中间有空格的情况 this.arrDy.forEach(item =&gt; &#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; &#125;, //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; &#125; &#125; &#125; 13.7 图片上传-文档12345678910111213Upload上传&lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload action=&quot;https://jsonplaceholder.typicode.com/posts/&quot; :on-remove=&quot;handleRemove&quot; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt;&lt;/el-tab-pane&gt; 13.8 图片上传-配置属性123456789101112131415161718192021222324252627282930313233接口:图片上传请求路径中需要添加前缀:因为设置的baseUrl只是针对axios请求的,而上传图片不针对axios1.&lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload 图片请求地址 action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&quot;handleSuccess&quot; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt;&lt;/el-tab-pane&gt;2.data()&#123; return &#123; &#125;&#125;,//上传文件的函数handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file);&#125;,handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); 图片存储服务器临时路径里面 response.data.tmp_path&#125; 14.3 商品内容-富文本编辑器1234567891011121314151617https://github.com/surmon-china/vue-quill-editorvue资源: 富文本编辑器 Rich Text Editing1.安装: npm install vue-quill-editor --save2.引入: 局部引入 import &apos;quill/dist/quill.core.css&apos; import &apos;quill/dist/quill.snow.css&apos; import &apos;quill/dist/quill.bubble.css&apos; import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos; export default &#123; //富文本编辑器 components: &#123; quillEditor &#125; &#125;3.在template中使用&lt;quill-editor&gt;&lt;/quill-editor&gt; goodsadd.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;template&gt; &lt;el-card&gt; &lt;my-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/my-bread&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-form label-position=&apos;top&apos; v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; &lt;el-tabs v-model=&quot;active&quot; @tab-click = &apos;changeTab()&apos; tab-position=&quot;left&quot; style=&quot;height: 550px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_weight&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item v-for=&apos;(item1,i) in arrDy&apos; :key=&apos;item1.attr_id&apos; :label=&quot;item1.attr_name&quot;&gt; &lt;!-- v-model控制的是全部选中的元素 --&gt; &lt;el-checkbox-group v-model=&quot;item1.attr_vals&quot;&gt; &lt;el-checkbox v-for=&apos;(item2,i) in item1.attr_vals&apos; :key=&apos;i&apos; :label=&quot;item2&quot; border&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&apos;(item,i) in arrStatic&apos; :key=&apos;item.attr_id&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;el-form-item&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&quot;handleSuccess&quot; :headers = &apos;headers&apos; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt; &lt;el-form-item&gt; &lt;el-button&gt;添加商品&lt;/el-button&gt; //富文本编辑器 &lt;quill-editor v-model=&apos;form.goods_introduce&apos;&gt;&lt;/quill-editor&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; // 富文本编辑器局部引入 import &apos;quill/dist/quill.core.css&apos; import &apos;quill/dist/quill.snow.css&apos; import &apos;quill/dist/quill.bubble.css&apos; import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos; export default &#123; //富文本编辑器 components: &#123; quillEditor //quill-editor:quill-edito &#125;, data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_cat: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, pics: [], attrs: [] &#125;, //级联数据要使用的数据 options: [], selectedOptions2: [1,3,6], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, //复选框组数据 //checkList: [], //动态参数数组 arrDy: [], //静态参数数组 arrStatic: [], //上传图片 headers: &#123; Authorization: window.localStorage.getItem(&apos;token&apos;) &#125; &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //上传文件的函数 handleRemove(file)&#123; console.log(&apos;移除成功&apos;); console.log(file); &#125;, handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); console.log(response); //response.data.tmp_path &#125;, //当tab栏选中切换时 async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); console.log(res); this.arrDy = res.data.data; this.arrDy.forEach(item =&gt; &#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; //判断当前是不是商品属性这一项,如果是的话判断有没有选中三级分类,有则获取静态商品数据 if(this.active === &apos;3&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; &#125;, //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;.form &#123; height: 400px; overflow: auto;&#125;.quill-editor &#123; margin-top: 10px;&#125;.ql-editor &#123; height: 200px;&#125;&lt;/style&gt; 13.10 表单数据处理-分类和图片123456789101112131415161718192021222324252627接口:添加商品发送添加商品请求，处理数据数据处理： 处理分类id goods_cat 图片临时路径//添加商品addGoods()&#123; //处理数据 商品分类 级联选择器数据 数组用,号分割开的字符串 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;);&#125;,//上传文件的函数handleRemove(file)&#123; console.log(&apos;移除成功&apos;); const index = this.form.pics.findIndex((item) =&gt; &#123; return item.pic === file.response.data.tmp_path; &#125;); // console.log(index); this.form.pics.splice(index,1);&#125;,handleSuccess(response)&#123; console.log(&apos;上传成功&apos;); //console.log(response); //把临时路径放在数组中 this.form.pics.push(&#123; pic: response.data.tmp_path &#125;); //console.log(this.form.pics); //response.data.tmp_path&#125; 13.11 表单数据处理1234567891011121314151617将动态参数和静态参数数据的id和value放入attrs数组//添加商品addGoods()&#123; // 发送请求之前先处理数据 // goods_cat:商品id以,分割的字符串 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;); // 处理临时路径 this.form.pics // 处理 attrs 静态参数和动态参数id const arr1 = this.arrDy; const arr2 = this.arrStatic; const arr = [...arr1, ...arr2]; const newArr = arr.map(item =&gt; &#123; return &#123;attr_id: item.attr_id,attr_vals: item.attr_vals&#125;; &#125;); console.log(newArr); this.form.attrs = newArr;&#125; 13.12 发送请求-回到商品列表页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;template&gt; &lt;el-card&gt; &lt;my-bread level1=&apos;商品管理&apos; level2=&apos;商品列表&apos;&gt;&lt;/my-bread&gt; &lt;el-row class=&apos;info&apos;&gt; &lt;el-col&gt; &lt;el-alert title=&quot;添加商品信息&quot; type=&quot;info&quot; center show-icon :closable=&quot;false&quot;&gt;&lt;/el-alert&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-steps :active=&quot;1*active&quot;&gt; &lt;el-step title=&quot;基本信息&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品参数&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品属性&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品图片&quot;&gt;&lt;/el-step&gt; &lt;el-step title=&quot;商品内容&quot;&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;el-form label-position=&apos;top&apos; v-model=&apos;form&apos; height=&apos;400px&apos; class=&apos;form&apos;&gt; &lt;el-tabs v-model=&quot;active&quot; @tab-click = &apos;changeTab()&apos; tab-position=&quot;left&quot; style=&quot;height: 550px&quot; class=&apos;tabs&apos;&gt; &lt;el-tab-pane name=&apos;1&apos; label=&quot;基本信息&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;form.goods_name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;form.goods_price&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品重量&quot;&gt; &lt;el-input v-model=&quot;form.goods_weight&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品数量&quot;&gt; &lt;el-input v-model=&quot;form.goods_number&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品分类&quot;&gt; &lt;el-cascader clearable expand-trigger=&quot;hover&quot; :options=&quot;options&quot; v-model=&quot;selectedOptions2&quot; :props = &quot;defaultProp&quot; @change=&quot;handleChange&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;2&apos; label=&quot;商品参数&quot;&gt; &lt;el-form-item v-for=&apos;(item1) in arrDy&apos; :key=&apos;item1.attr_id&apos; :label=&quot;item1.attr_name&quot;&gt; &lt;!-- v-model控制的是全部选中的元素 --&gt; &lt;el-checkbox-group v-model=&quot;item1.attr_vals&quot;&gt; &lt;el-checkbox v-for=&apos;(item2,i) in item1.attr_vals&apos; :key=&apos;i&apos; :label=&quot;item2&quot; border&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;3&apos; label=&quot;商品属性&quot;&gt; &lt;el-form-item :label=&quot;item.attr_name&quot; v-for=&apos;(item) in arrStatic&apos; :key=&apos;item.attr_id&apos;&gt; &lt;el-input v-model=&quot;item.attr_vals&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;4&apos; label=&quot;商品图片&quot;&gt; &lt;el-form-item&gt; &lt;!-- action：图片上传的地址 :on-remove: 移除图片触发的函数 list-type: picture 图片以列表缩略图显示--&gt; &lt;el-upload action=&quot;http://localhost:8888/api/private/v1/upload&quot; :on-remove=&quot;handleRemove&quot; :on-success=&quot;handleSuccess&quot; :headers = &apos;headers&apos; list-type=&quot;picture&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;点击上传&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane name=&apos;5&apos; label=&quot;商品内容&quot;&gt; &lt;el-form-item&gt; &lt;el-button @click=&apos;addGoods()&apos;&gt;添加商品&lt;/el-button&gt; //富文本编辑器 &lt;quill-editor v-model=&apos;form.goods_introduce&apos;&gt;&lt;/quill-editor&gt; &lt;/el-form-item&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-form&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt; // 富文本编辑器局部引入 import &apos;quill/dist/quill.core.css&apos; import &apos;quill/dist/quill.snow.css&apos; import &apos;quill/dist/quill.bubble.css&apos; import &#123; quillEditor &#125; from &apos;vue-quill-editor&apos; export default &#123; //富文本编辑器 components: &#123; quillEditor //quill-editor:quill-edito &#125;, data()&#123; return &#123; active: &quot;1&quot;, form: &#123; goods_name: &apos;&apos;, goods_price: &apos;&apos;, goods_number: &apos;&apos;, goods_weight: &apos;&apos;, goods_introduce: &apos;&apos;, goods_cat: &apos;&apos;, pics: [], attrs: [] &#125;, //级联数据要使用的数据 options: [], selectedOptions2: [1,3,6], defaultProp: &#123; label: &apos;cat_name&apos;, value: &apos;cat_id&apos;, children: &apos;children&apos; &#125;, //复选框组数据 //checkList: [], //动态参数数组 arrDy: [], //静态参数数组 arrStatic: [], //上传图片 headers: &#123; Authorization: window.localStorage.getItem(&apos;token&apos;) &#125; &#125; &#125;, mounted()&#123; this.getGoodsCate(); &#125;, methods:&#123; //添加商品 async addGoods()&#123; // 发送请求之前先处理数据 // goods_cat:商品id以,分割的字符串 this.form.goods_cat = this.selectedOptions2.join(&apos;,&apos;); // 处理临时路径 this.form.pics // 处理 attrs 静态参数和动态参数id const arr1 = this.arrDy; const arr2 = this.arrStatic; const arr = [...arr1, ...arr2]; const newArr = arr.map(item =&gt; &#123; return &#123;attr_id: item.attr_id,attr_vals: item.attr_vals&#125;; &#125;); // console.log(newArr); this.form.attrs = newArr; const res = await this.$http.post(`goods`,this.form); console.log(res.data.meta.status); if(res.data.meta.status === 201)&#123; this.$router.push(&#123; name: &apos;goods&apos; &#125;); &#125; &#125;, //上传文件的函数 handleRemove(file)&#123; // console.log(&apos;移除成功&apos;); //console.log(file); const index = this.form.pics.findIndex(item =&gt; &#123; return file.response.data.tmp_path === item.pic; &#125;); //console.log(index); this.form.pics.splice(index,1); &#125;, handleSuccess(response)&#123; //console.log(&apos;上传成功&apos;); //console.log(response); this.form.pics.push(&#123; pic: response.data.tmp_path &#125;); //response.data.tmp_path &#125;, //当tab栏选中切换时 async changeTab()&#123; // 判断当前是不是商品参数这一项,如果是的话，判断有没有选中三级分类，有则获取动态商品参数 //当选中哪一项,v-model的值就是该name的值 if(this.active === &apos;2&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=many`); //console.log(res); this.arrDy = res.data.data; this.arrDy.forEach(item =&gt; &#123; item.attr_vals = item.attr_vals.trim().length === 0 ? [] : item.attr_vals.trim().split(&apos;,&apos;); &#125;); &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; //判断当前是不是商品属性这一项,如果是的话判断有没有选中三级分类,有则获取静态商品数据 if(this.active === &apos;3&apos;)&#123; if(this.selectedOptions2.length === 3)&#123; const res = await this.$http.get(`categories/$&#123;this.selectedOptions2[2]&#125;/attributes?sel=only`); //console.log(res); this.arrStatic = res.data.data; &#125;else&#123; this.$message.warning(&apos;请选择完整的三级分类&apos;); &#125; &#125; &#125;, //级联选择器中内容改变时触发 handleChange()&#123; &#125;, //获取商品数据列表 级联数据 async getGoodsCate()&#123; const res = await this.$http.get(`categories?type=3`); //console.log(res); this.options = res.data.data; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;.form &#123; height: 400px; overflow: auto;&#125;.quill-editor &#123; margin-top: 10px;&#125;.ql-editor &#123; height: 200px;&#125;&lt;/style&gt; 14. 树形插件-商品分类14.1 准备组件-配置路由121.引入goodsCate.vue文件2.配置路由 14.2 element-tree-grid文档1234567891.安装 npm install element-tree-grid --save2.局部导入 先引入 var ElTreeGrid = require(&apos;element-tree-grid&apos;); 局部注册 var ElTreeGrid = require(&apos;element-tree-grid&apos;); Vue.component(ElTreeGrid.name,ElTreeGrid);3.使用&lt;el-tree-grid&gt;&lt;/el-tree-grid&gt; 14.3 element-tree-grid配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 &lt;!-- 表格 --&gt; 1. &lt;el-table height=&quot;450&quot; :data=&quot;list&quot; style=&quot;width: 100%&quot;&gt; &lt;!-- 表格展开为树形结构 --&gt; &lt;!-- treeKey 相当于 nodeKey 每个节点唯一标识 值来源于list数据中的key名 parentkey 父节点的数据的标识 cat_id levelKey 自己层级标识 childkey 子节点的数据所在key--&gt; &lt;el-tree-grid prop=&apos;cat_name&apos; label=&apos;分类名称&apos; treeKey = &apos;cat_id&apos; parentkey = &apos;cat_pid&apos; levelKey = &apos;cat_level&apos; childkey = &apos;children&apos;&gt; &lt;/el-tree-grid&gt; &lt;el-table-column label=&quot;级别&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_level===0&quot;&gt;一级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===1&quot;&gt;二级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===2&quot;&gt;三级&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;是否有效&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_deleted===false&quot;&gt;有效&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_deleted===true&quot;&gt;无效&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;2.&lt;script&gt;// 引入 element-tree-gridvar ElTreeGrid = require(&apos;element-tree-grid&apos;);export default &#123; components: &#123; ElTreeGrid &#125;, data() &#123; return &#123; list: [], pagenum: 1, pagesize: 10, total: 1, dialogFormVisibleAdd: false, form: &#123; cat_pid: -1, cat_name: &quot;&quot;, cat_level: -1 &#125;, formLabelWidth: &quot;140px&quot;, // 级联选择器要用的数据 caslist: [], selectedOptions: [], defaultProp: &#123; value: &quot;cat_id&quot;, label: &quot;cat_name&quot;, children: &quot;children&quot; &#125; &#125;; &#125;, created() &#123; this.getGoodsCate(); &#125;, methods: &#123; // 添加分类 - 发送请求 async addCate() &#123;&#125;, // 添加分类- 显示对话框 async addGoodsCate() &#123; // 获取两级分类的数据 const res = await this.$http.get(`categories?type=2`); this.caslist = res.data.data; this.dialogFormVisibleAdd = true; &#125;, // 获取所有分类 async getGoodsCate() &#123; const res = await this.$http.get( `categories?type=3&amp;pagenum=$&#123;this.pagenum&#125;&amp;pagesize=$&#123;this.pagesize&#125;` ); // console.log(res) this.list = res.data.data.result; // console.log(this.list); this.total = res.data.data.total; &#125;, // 分页的相关方法 handleSizeChange(val) &#123; // console.log(`每页 $&#123;val&#125; 条`) this.pagesize = val; this.pagenum = 1; this.getGoodsCate(); &#125;, handleCurrentChange(val) &#123; // console.log(`当前页: $&#123;val&#125;`) // this.pagenum = 2 = val this.pagenum = val; this.getGoodsCate(); &#125; &#125;&#125;;&lt;/script&gt; 14.4 添加分类-打开对话框123点击添加分类按钮,打开对话框,获取数据级联选择器二级分类数据(type=2)配置对话框中级联选择器的数据注意:添加分类,只能添加一二三级分类 14.5 添加分类-发送请求12接口： 添加分类数据点击确定按钮，发送请求 处理请求体参数数据 关闭弹出框 刷新表格 清空弹出框数据 123456789101112131415161718192021222324252627async addCate() &#123; // 处理请求体中的参数 // cat_name: &quot;&quot;, 绑定的表单数据 // cat_pid: -1, // cat_level: -1 if(this.selectedOptions.length === 0)&#123; this.form.cat_pid = 0; this.form.cat_level = 0; &#125; if(this.selectedOptions.length === 1)&#123; this.form.cat_pid = this.selectedOptions[0]; this.form.cat_level = 1; &#125; if(this.selectedOptions.length === 2)&#123; this.form.cat_pid = this.selectedOptions[1]; this.form.cat_level = 2; &#125; const res = await this.$http.post(`categories`,this.form); //console.log(res); // 清空弹出框数据 this.form = &#123;&#125;; this.selectedOptions = []; // 刷新 this.getGoodsCate(); // 关闭弹出框 this.dialogFormVisibleAdd = false; &#125; goodscate.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;template&gt; &lt;el-card class=&quot;box-card&quot;&gt; &lt;!-- 面包屑 --&gt; &lt;my-bread level1=&quot;商品管理&quot; level2=&quot;商品分类&quot;&gt;&lt;/my-bread&gt; &lt;!-- 搜索框 --&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot; class=&quot;searchArea&quot;&gt; &lt;el-button type=&quot;success&quot; @click=&quot;addGoodsCate()&quot;&gt;添加分类&lt;/el-button&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!-- 添加分类的对话框 --&gt; &lt;el-dialog title=&quot;添加分类&quot; :visible.sync=&quot;dialogFormVisibleAdd&quot;&gt; &lt;el-form :model=&quot;form&quot;&gt; &lt;el-form-item label=&quot;分类名称&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-input v-model=&quot;form.cat_name&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 级联选择器 (表单元素) --&gt; &lt;el-form-item label=&quot;分类&quot; :label-width=&quot;formLabelWidth&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; change-on-select clearable :options=&quot;caslist&quot; v-model=&quot;selectedOptions&quot; :props=&quot;defaultProp&quot; &gt;&lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogFormVisibleAdd = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addCate()&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;!-- 表格 --&gt; &lt;el-table height=&quot;350&quot; :data=&quot;list&quot; style=&quot;width: 100%&quot;&gt; &lt;!-- 表格展开为树形结构 --&gt; &lt;!-- treeKey 相当于 nodeKey 每个节点唯一标识 值来源于list数据中的key名 parentkey 父节点的数据的标识 cat_id levelKey 自己层级标识 childkey 子节点的数据所在key--&gt; &lt;el-tree-grid prop=&apos;cat_name&apos; label=&apos;分类名称&apos; treeKey = &apos;cat_id&apos; parentkey = &apos;cat_pid&apos; levelKey = &apos;cat_level&apos; childkey = &apos;children&apos;&gt; &lt;/el-tree-grid&gt; &lt;el-table-column label=&quot;级别&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_level===0&quot;&gt;一级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===1&quot;&gt;二级&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_level===2&quot;&gt;三级&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;是否有效&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span v-if=&quot;scope.row.cat_deleted===false&quot;&gt;有效&lt;/span&gt; &lt;span v-else-if=&quot;scope.row.cat_deleted===true&quot;&gt;无效&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle size=&quot;mini&quot; plain&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页 --&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pagenum&quot; :page-sizes=&quot;[5, 10, 15,20]&quot; :page-size=&quot;pagesize&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;total&quot; &gt;&lt;/el-pagination&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt;// 引入 element-tree-gridvar ElTreeGrid = require(&apos;element-tree-grid&apos;);export default &#123; components: &#123; ElTreeGrid &#125;, data() &#123; return &#123; list: [], pagenum: 1, pagesize: 10, total: 1, dialogFormVisibleAdd: false, form: &#123; cat_pid: -1, cat_name: &quot;&quot;, cat_level: -1 &#125;, formLabelWidth: &quot;140px&quot;, // 级联选择器要用的数据 caslist: [], selectedOptions: [], defaultProp: &#123; value: &quot;cat_id&quot;, label: &quot;cat_name&quot;, children: &quot;children&quot; &#125; &#125;; &#125;, created() &#123; this.getGoodsCate(); &#125;, methods: &#123; // 添加分类 - 发送请求 async addCate() &#123; // 处理请求体中的参数 // cat_name: &quot;&quot;, 绑定的表单数据 // cat_pid: -1, // cat_level: -1 if(this.selectedOptions.length === 0)&#123; this.form.cat_pid = 0; this.form.cat_level = 0; &#125; if(this.selectedOptions.length === 1)&#123; this.form.cat_pid = this.selectedOptions[0]; this.form.cat_level = 1; &#125; if(this.selectedOptions.length === 2)&#123; this.form.cat_pid = this.selectedOptions[1]; this.form.cat_level = 2; &#125; const res = await this.$http.post(`categories`,this.form); //console.log(res); // 清空弹出框数据 this.form = &#123;&#125;; this.selectedOptions = []; // 刷新 this.getGoodsCate(); // 关闭弹出框 this.dialogFormVisibleAdd = false; &#125;, // 添加分类- 显示对话框 async addGoodsCate() &#123; // 获取两级分类的数据 const res = await this.$http.get(`categories?type=2`); this.caslist = res.data.data; this.dialogFormVisibleAdd = true; &#125;, // 获取所有分类 async getGoodsCate() &#123; const res = await this.$http.get( `categories?type=3&amp;pagenum=$&#123;this.pagenum&#125;&amp;pagesize=$&#123;this.pagesize&#125;` ); // console.log(res) this.list = res.data.data.result; // console.log(this.list); this.total = res.data.data.total; &#125;, // 分页的相关方法 handleSizeChange(val) &#123; // console.log(`每页 $&#123;val&#125; 条`) this.pagesize = val; this.pagenum = 1; this.getGoodsCate(); &#125;, handleCurrentChange(val) &#123; // console.log(`当前页: $&#123;val&#125;`) // this.pagenum = 2 = val this.pagenum = val; this.getGoodsCate(); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.box-card &#123; height: 100%;&#125;.searchArea &#123; margin-top: 10px; margin-bottom: 10px;&#125;.searchArea .searchInput &#123; width: 350px;&#125;&lt;/style&gt; 16. 订单管理16.1 订单列表-配置路由-省市区引入123456orders/ 省市区插件没有请求接口,因为几乎所有设备都需要使用1.引入 // catlist是一个数组import catlist from &apos;@/assets/city_data2017_element.js&apos;;2.点击编辑按钮弹出弹出框,在弹出框里设置数据this.catlist = catlist; 17. 数据统计17.1 数据报表-Echarts-配置路由123456789101112131415161718192021222324252627282930313233343536373839404142百度地图 www.echartsjs.com1.安装 npm install echarts --save2.导入import echarts from &apos;echarts&apos;;3.定义标签 &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; 4.// 引入图表文件import echarts from &apos;echarts&apos;;export default &#123; 要操作DOM需要在mounted中 mounted()&#123; this.initEcharts(); &#125;, methods: &#123; initEcharts()&#123; // 初始化 var myChart = echarts.init(document.getElementById(&apos;main&apos;)); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: &apos;ECharts 入门示例&apos; &#125;, tooltip: &#123;&#125;, legend: &#123; data:[&apos;销量&apos;] &#125;, xAxis: &#123; data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &apos;销量&apos;, type: &apos;bar&apos;, data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &#125;&#125; 17.2 数据报表-Echarts-配置123456789文档接口参数不正确: 获取图表所需数据接口: reports/:type接口文档没写怎么传: :type 测试: reports/:type reports reports/type=bing reports?type=1 reports/type/1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;el-card&gt; &lt;!-- 面包屑 --&gt; &lt;my-bread level1=&quot;数据统计&quot; level2=&quot;数据报表&quot;&gt;&lt;/my-bread&gt; &lt;!-- 图表 --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 800px;height:400px;margin-top:20px&quot;&gt;&lt;/div&gt; &lt;/el-card&gt;&lt;/template&gt;&lt;script&gt;// 引入图表文件import echarts from &apos;echarts&apos;;export default &#123; data()&#123; return &#123; &#125; &#125;, mounted()&#123; this.initEcharts(); &#125;, methods: &#123; async initEcharts()&#123; // 初始化折线图 var myChart = echarts.init(document.getElementById(&apos;main&apos;)); // 获取图标数据 const res = await this.$http.get(`reports/type/1`); //console.log(res); const option1 = res.data.data; // 指定图表的配置项和数据 const option2 = &#123; title: &#123; text: &apos;堆叠区域图&apos; &#125;, tooltip : &#123; trigger: &apos;axis&apos;, axisPointer: &#123; type: &apos;cross&apos;, label: &#123; backgroundColor: &apos;#6a7985&apos; &#125; &#125; &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, grid: &#123; left: &apos;3%&apos;, right: &apos;4%&apos;, bottom: &apos;3%&apos;, containLabel: true &#125; &#125;; const option = &#123;...option1, ...option2&#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 18. 优化-加载动画1234567组件: loading加载1.通过自定义指令给表格添加 属性 数据loading为布尔值&lt;el-table v-loading=&quot;loading&quot; :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt;2.默认数据为false，请求数据之前设置this.loading = true,请求获取之后设置为true 19. 优化-拦截器统一处理响应main.js第一种写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;// 引入element-ui;import ElementUI from &apos;element-ui&apos;import &apos;element-ui/lib/theme-chalk/index.css&apos;import &apos;@/assets/index.css&apos;import moment from &apos;moment&apos;import MyBread from &apos;@/components/cusBread.vue&apos;// import Http from &apos;@/http/http.js&apos;// Vue.use(Http);import axios from &apos;axios&apos;import &#123;Message&#125; from &apos;element-ui&apos;axios.defaults.baseURL = &quot;http://localhost:8888/api/private/v1/&quot;;// 添加一个请求拦截器axios.interceptors.request.use(function (config) &#123; //在发送请求之前希望做些什么 //如果请求的不是登录请求，则设置拦截进行下面的代码 //根据config.url可以获取当前请求的地址 //console.log(config); if(config.url !== &apos;login&apos;)&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); config.headers.Authorization = AUTH_TOKEN; &#125; return config;&#125;, function (error) &#123; // Do something with request error return Promise.reject(error);&#125;);//添加响应拦截器// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; console.log(response); const msg = response.data.meta.msg; const status = response.data.meta.status; if(status !== 200 &amp;&amp; status !== 201)&#123; Message.warning(msg); &#125; return response;&#125;, function (error) &#123;// 对响应错误做点什么 return Promise.reject(error);&#125;);Vue.prototype.$http = axios;Vue.use(ElementUI)Vue.config.productionTip = false//定义全局组件Vue.component(&quot;my-bread&quot;,MyBread);// 格式化日期的过滤器Vue.filter(&apos;fmDate&apos;,(v) =&gt; &#123; return moment(v).format(&apos;YYYY-MM-DD&apos;);&#125;);/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) main.js第二种写法 12import Http from &apos;@/http/http.js&apos;Vue.use(Http); http.js 12345678910111213141516171819202122232425262728293031323334353637import axios from &apos;axios&apos;import &#123;Message&#125; from &apos;element-ui&apos;const Http = &#123;&#125;Http.install = function(Vue, options) &#123; axios.defaults.baseURL = &quot;http://localhost:8888/api/private/v1/&quot;; // 添加一个请求拦截器 axios.interceptors.request.use(function (config) &#123; //在发送请求之前希望做些什么 //如果请求的不是登录请求，则设置拦截进行下面的代码 //根据config.url可以获取当前请求的地址 //console.log(config); if(config.url !== &apos;login&apos;)&#123; const AUTH_TOKEN = window.localStorage.getItem(&apos;token&apos;); config.headers.Authorization = AUTH_TOKEN; &#125; return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;); //添加响应拦截器 // 添加响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(response); const msg = response.data.meta.msg; const status = response.data.meta.status; if(status !== 200 &amp;&amp; status !== 201)&#123; Message.warning(msg); &#125; return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); Vue.prototype.$http = axios;&#125;export default Http 20. 优化-路由懒加载123456789101112131415161718192021222324首屏加载慢: 一次性加载所有组件使用哪个组件加载哪个组件vueejs.com 路由懒加载把所有index.js组件中所有的路由配置修改为const Vue = () =&gt; import(&apos;vue&apos;);将页面中需要的标识对应的组件，写成懒加载形式import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import &#123;Message&#125; from &apos;element-ui&apos;const Login = () =&gt; import(&apos;@/components/login.vue&apos;)const Home = () =&gt; import(&apos;@/components/home.vue&apos;)const Users = () =&gt; import(&apos;@/components/users.vue&apos;)const Rights = () =&gt; import(&apos;@/components/rights.vue&apos;)const Roles = () =&gt; import(&apos;@/components/roles.vue&apos;)const Goodslist = () =&gt; import(&apos;@/components/goodslist.vue&apos;)const Goodsadd = () =&gt; import(&apos;@/components/goodsadd.vue&apos;)const Params = () =&gt; import(&apos;@/components/params.vue&apos;)const Goodscate = () =&gt; import(&apos;@/components/goodsCate.vue&apos;)const Order = () =&gt; import(&apos;@/components/order.vue&apos;)const Reports = () =&gt; import(&apos;@/components/reports.vue&apos;)多会需要多会加载如果不处理 - 打包后 -项目中所有的组件 会生成一个js文件如果路由懒加载 - 打包后 - 项目中每个组件-&gt;会生成自己的js文件npm run build 打包 21. nextTick方法12345678改变数据需要时间-经过时间-&gt;渲染视图修改过数据之后，立马获取DOM元素的数据，获取到的是之前的数据,执行完数据之后，需要经过updata和beforeUpdata钩子函数之后，数据才能改变,而这一过程需要时间,所以,如果想要实时获取DOM元素的数据,可以在获取元素时,1）使用定时器2）使用vue实例的 $nextTick()方法this.$nextTick(() =&gt; &#123; console.log(this.$refs.p.innerText);&#125;); 111.html 1234567891011121314151617181920212223242526&lt;div class=&quot;main&quot;&gt; &lt;button @click=&apos;add()&apos;&gt;按钮&lt;/button&gt;&#123;&#123;num&#125;&#125; &lt;p ref=&apos;p&apos;&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &apos;.main&apos;, data: &#123; num: &apos;&apos; &#125;, methods: &#123; add()&#123; this.num ++; console.log(this.$refs.p.innerText); 打印的p标签中的值是++之前的值,因为数据加完之后，执行update函数还需要一段时间，如果想要获取++之后的值,需要添加定时器或者使用vue的$nextTick函数 1)setInterval(() =&gt; &#123; console.log(this.$refs.p.innerText); &#125;); 2)this.$nextTick(() =&gt; &#123; console.log(this.$refs.p.innerText); &#125;); &#125; &#125; &#125;); &lt;/script&gt; 22. 优化－CDN配置123456789101112131415161718192021222324１.项目中引用的资源是通过node_module来获取，在打包过程中，node_modelu也会被打包－＞项目包会很大２.项目资源改成从网络资源获取，从CDN获取３.package.json 文件中 依赖项 dependencies配置项中的内容都是从npm下载的, 把里面的资源改成cdn引入package.json文件&quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.2&quot;, &quot;vue-router&quot;: &quot;^3.0.1&quot;, &quot;element-ui&quot;: &quot;^2.6.1&quot;, &quot;axios&quot;: &quot;^0.18.0&quot;, &quot;moment&quot;: &quot;^2.24.0&quot;, &quot;echarts&quot;: &quot;^4.2.1&quot;, &quot;element-tree-grid&quot;: &quot;^0.1.3&quot;, &quot;vue-quill-editor&quot;: &quot;^3.0.6&quot; &#125;４.在vue官网找到对应得cdn资源，将cdn添加到index.html文件中&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/moment.js/2.24.0/moment.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.1-rc1/echarts.min.js&quot;&gt;&lt;/script&gt;５.所有的主流框架和三方资源都可以在CDN网站中找到https://www.bootcdn.cn6.小的插件资源找不到 文件大小比较小 不替换也可以 1234567891011121314151617181920212223241.找到package.json中使用的包2.找包的对应cdn网址 － 官网＋bootcdn3.引入 index.html src4.修改webpack打包配置 https://www.webpackjs.com/在webpack网站配置查找cdn配置方法webpack.base.config.jsmodule.exports = &#123; //... externals: &#123; key =&gt; 包名 =&gt; package.json value =&gt; 该包源码中暴露在全局中的变量名 &quot;vue&quot;: &apos;Vue&apos;, &quot;vue-router&quot;: &apos;vueRouter&apos;, &quot;element-ui&quot;: &apos;ELEMENT&apos;, &quot;axios&quot;: &apos;axios&apos;, &quot;moment&quot;: &apos;moment&apos;, &quot;echarts&quot;: &apos;echarts&apos; &#125;&#125;;5.把页面中所有导包所接收的变量与上面的全局中的变量名一样import Vue from &apos;vue&apos;;注意： 配置js的CDN资源－全局变量名－源码前几行define／exports／require／globallink的src不需要单独配置 －在main.js中 把之前引入.css文件的代码删除掉]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fsongfang0%2F2019%2F04%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
